<!DOCTYPE HTML>
<html lang="kr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>넷평의 Unity Shader 노트</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="study.unity-shader">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/juxtapose.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html">둘러보기</a></li><li class="chapter-item expanded "><a href="Pipeline.html">파이프라인</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">기본</li><li class="chapter-item expanded "><a href="Basic/Vector.html">Vector</a></li><li class="chapter-item expanded "><a href="Basic/Mesh.html">Mesh</a></li><li class="chapter-item expanded "><a href="Basic/Coordinate.html">Coordinate</a></li><li class="chapter-item expanded "><a href="Basic/Alpha.html">Alpha</a></li><li class="chapter-item expanded "><a href="Basic/NormalMap.html">NormalMap</a></li><li class="chapter-item expanded "><a href="Basic/Cubemap.html">Cubemap</a></li><li class="chapter-item expanded "><a href="Basic/Stencil.html">Stencil</a></li><li class="chapter-item expanded "><a href="Basic/Depth.html">Depth</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">라이팅</li><li class="chapter-item expanded "><a href="Lighting/LightingModel.html">LightingModel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Lighting/LightingModel-NPR.html">LightingModel-NPR</a></li><li class="chapter-item expanded "><a href="Lighting/LightingModel-PBR.html">LightingModel-PBR</a></li></ol></li><li class="chapter-item expanded "><a href="Lighting/HemisphereLight.html">HemisphereLight</a></li><li class="chapter-item expanded "><a href="Lighting/HairAnisotropic.html">HairAnisotropic</a></li><li class="chapter-item expanded "><div>WIP</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Lighting/WIP_BRDF.html">WIP_BRDF</a></li><li class="chapter-item expanded "><a href="Lighting/WIP_PBR.html">WIP_PBR</a></li><li class="chapter-item expanded "><a href="Lighting/WIP_FlatShader.html">WIP_FlatShader</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">심화</li><li class="chapter-item expanded "><a href="Advanced/LOD.html">LOD</a></li><li class="chapter-item expanded "><a href="Advanced/Shadow.html">Shadow</a></li><li class="chapter-item expanded "><div>WIP</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Advanced/_Dithering.html">wip_Dithering</a></li><li class="chapter-item expanded "><a href="Advanced/_Geometry.html">wip_Geometry</a></li><li class="chapter-item expanded "><a href="Advanced/_Lightmap.html">wip_Lightmap</a></li><li class="chapter-item expanded "><a href="Advanced/_LPV.html">wip_LPV</a></li><li class="chapter-item expanded "><a href="Advanced/_Noise.html">wip_Noise</a></li><li class="chapter-item expanded "><a href="Advanced/_Ray.html">wip_Ray</a></li><li class="chapter-item expanded "><a href="Advanced/_SDF.html">wip_SDF</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">SRP</li><li class="chapter-item expanded "><a href="SRP/SRP_Overview.html">SRP_Overview</a></li><li class="chapter-item expanded "><a href="SRP/linear_and_gamma.html">Linear And Gamma</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="SRP/shader_model_and_platform.html">셰이더 모델과 플렛폼</a></li></ol></li><li class="chapter-item expanded "><a href="SRP/SRP.html">SRP</a></li><li class="chapter-item expanded "><a href="SRP/ShaderLab.html">ShaderLab</a></li><li class="chapter-item expanded "><a href="SRP/URP/URP.html">URP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="SRP/URP/CheatSheet_URP.html">CheatSheet_URP</a></li><li class="chapter-item expanded "><a href="SRP/URP/urp_and_builtin.html">URP 랑 Built-in</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">포스트프로세스</li><li class="chapter-item expanded "><a href="Postprocess/PostProcess.html">PostProcess</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Postprocess/Filter.html">Filter</a></li><li class="chapter-item expanded "><a href="Postprocess/Bloom.html">Bloom</a></li><li class="chapter-item expanded "><a href="Postprocess/ColorGradingLUT.html">ColorGradingLUT</a></li><li class="chapter-item expanded "><a href="Postprocess/ColorSpace.html">ColorSpace</a></li><li class="chapter-item expanded "><a href="Postprocess/EyeAdaptation.html">EyeAdaptation</a></li><li class="chapter-item expanded "><a href="Postprocess/FXAA.html">FXAA</a></li><li class="chapter-item expanded "><a href="Postprocess/LightStreak.html">LightStreak</a></li><li class="chapter-item expanded "><a href="Postprocess/SSAO.html">SSAO</a></li><li class="chapter-item expanded "><a href="Postprocess/ToneMapping.html">ToneMapping</a></li></ol></li><li class="chapter-item expanded "><div>WIP</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Postprocess/_ChromaticAberration.html">wip_ChromaticAberration</a></li><li class="chapter-item expanded "><a href="Postprocess/_DOF.html">wip_DOF</a></li><li class="chapter-item expanded "><a href="Postprocess/_HDR.html">wip_HDR</a></li><li class="chapter-item expanded "><a href="Postprocess/_LensFlare.html">wip_LensFlare</a></li><li class="chapter-item expanded "><a href="Postprocess/_LightShaft_postprocess.html">wip_LightShaft_postprocess</a></li><li class="chapter-item expanded "><a href="Postprocess/_MotionBlur.html">wip_MotionBlur</a></li><li class="chapter-item expanded "><a href="Postprocess/_SSGI.html">wip_SSGI</a></li><li class="chapter-item expanded "><a href="Postprocess/_SSR.html">wip_SSR</a></li><li class="chapter-item expanded "><a href="Postprocess/_TAA.html">wip_TAA</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">환경</li><li class="chapter-item expanded "><a href="Environment/CrossFadeShader.html">CrossFadeShader</a></li><li class="chapter-item expanded "><a href="Environment/CrackedIce.html">CrackedIce</a></li><li class="chapter-item expanded "><a href="Environment/FakeThicknessWindow.html">FakeThicknessWindow</a></li><li class="chapter-item expanded "><a href="Environment/ScreenSpaceDecal.html">ScreenSpaceDecal.md</a></li><li class="chapter-item expanded "><div>WIP</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Environment/_Rain.html">_Rain</a></li><li class="chapter-item expanded "><a href="Environment/_Sky.html">_Sky</a></li><li class="chapter-item expanded "><a href="Environment/_Grass.html">_Grass</a></li><li class="chapter-item expanded "><a href="Environment/Water.html">Water</a></li><li class="chapter-item expanded "><a href="Environment/_Ice.html">_Ice</a></li><li class="chapter-item expanded "><a href="Environment/_InteriorMapping.html">_InteriorMapping</a></li><li class="chapter-item expanded "><a href="Environment/_Vegetation.html">_Vegetation</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Fx</li><li class="chapter-item expanded "><a href="Fx/Billboard.html">Billboard</a></li><li class="chapter-item expanded "><a href="Fx/Dissolve.html">Dissolve</a></li><li class="chapter-item expanded "><a href="Fx/FlowMap.html">FlowMap</a></li><li class="chapter-item expanded "><a href="Fx/Hatching.html">Hatching</a></li><li class="chapter-item expanded "><a href="Fx/MatCap.html">MatCap</a></li><li class="chapter-item expanded "><a href="Fx/Outline.html">Outline</a></li><li class="chapter-item expanded "><a href="Fx/ParallaxMapping.html">ParallaxMapping</a></li><li class="chapter-item expanded "><a href="Fx/SSS.html">SSS</a></li><li class="chapter-item expanded "><div>WIP</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Fx/_ForceFieldShield.html">_ForceFieldShield</a></li><li class="chapter-item expanded "><a href="Fx/_LightShaft_Mesh.html">_LightShaft_Mesh</a></li><li class="chapter-item expanded "><a href="Fx/_RimLight.html">_RimLight</a></li><li class="chapter-item expanded "><a href="Fx/_SnowStick.html">_SnowStick</a></li><li class="chapter-item expanded "><a href="Fx/_Toon.html">_Toon</a></li><li class="chapter-item expanded "><a href="Fx/_ToonFire.html">_ToonFire</a></li><li class="chapter-item expanded "><a href="Fx/_Imposter.html">_Imposter</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">디퍼드 렌더링</li><li class="chapter-item expanded "><a href="DeferredRendering/_Deferred.html">_Deferred</a></li><li class="chapter-item expanded affix "><li class="part-title">기타</li><li class="chapter-item expanded "><a href="Etc/Direction.html">Direction</a></li><li class="chapter-item expanded "><a href="Etc/CodingStandard.html">CodingStandard</a></li><li class="chapter-item expanded "><a href="Etc/TroubleShooting.html">TroubleShooting</a></li><li class="chapter-item expanded "><div>WIP</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Etc/_CommandBuffer.html">_CommandBuffer</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">최적화</li><li class="chapter-item expanded "><a href="Optimize/ChromaSubsampling.html">ChromaSubsampling</a></li><li class="chapter-item expanded "><a href="Optimize/OptimizeCombineTexture.html">OptimizeCombineTexture</a></li><li class="chapter-item expanded "><a href="Optimize/OptimizeTip.html">OptimizeTip</a></li><li class="chapter-item expanded "><a href="Optimize/PostProcessUberShader.html">PostProcessUberShader</a></li><li class="chapter-item expanded "><a href="Optimize/SpecularPowApproximation.html">SpecularPowApproximation</a></li><li class="chapter-item expanded "><a href="Optimize/VertexMultipleLight.html">VertexMultipleLight</a></li><li class="chapter-item expanded "><div>WIP</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Optimize/_AnimationTexture.html">WIP_AnimationTexture</a></li><li class="chapter-item expanded "><a href="Optimize/_DrawCall.html">WIP_DrawCall</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">참고</li><li class="chapter-item expanded "><a href="Link/Tool.html">Tool</a></li><li class="chapter-item expanded "><a href="Link/Presentation.html">Presentation</a></li><li class="chapter-item expanded "><a href="Link/Reference.html">Reference</a></li><li class="chapter-item expanded "><a href="Link/EtcLink.html">EtcLink</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">넷평의 Unity Shader 노트</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/netpyoung/study.unity-shader" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="둘러보기"><a class="header" href="#둘러보기">둘러보기</a></h1>
<p>Unity Shader 노트</p>
<ul>
<li>
<p><a href="https://github.com/netpyoung/nf.example.shader">github: nf.example.shader</a></p>
<ul>
<li><a href="https://github.com/netpyoung/nf.example.shader/tree/master/nf.example.shader/Assets">collections</a></li>
<li><a href="https://github.com/netpyoung/nf.example.shader/tree/master/nf.example.srp/Assets">SRP</a></li>
</ul>
</li>
<li>
<p><a href="https://github.com/netpyoung/unity.shader.sandbox">ShaderArt 관련</a></p>
</li>
<li>
<p><a href="https://github.com/netpyoung/nf.example.computeshader">ComputeShader 관련</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h1>
<p>텍스쳐</p>
<p>메쉬
VertexBuffer
pos/uv/normal/color
IndexBuffer</p>
<p>Gamma / Linear Pipeline (HDR)</p>
<p>Rendering
Forward
Forward Plus
Deferred</p>
<p>CPU =DrawCall=&gt; GPU</p>
<p>Culling</p>
<p>Input Assembly
Shader:Vertex
object/world/camera/clip
Shader:Hull
Shader:Tesselator
Shader:Domain
Shader:Geometry</p>
<pre><code>Rasterizer
    정점간 보간
Early Depth Testing

Shader:Pixel

Depth Testing
</code></pre>
<p>Render Target Output</p>
<p>포스트프로세스
(HDR)Luminance
(HDR)Bloom
(HDR)Eye Adaptation
(HDR)Tone Mapping</p>
<p>SSR
SSAO
SSGI
Motion Blur</p>
<p>Depth of Field - Bokeh(geometry / gather)
Color Filtering
Gamma Control</p>
<p>AA</p>
<p>LOD
HLOD
Lumen</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<h2 id="swizzling"><a class="header" href="#swizzling"><a href="https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)">Swizzling</a></a></h2>
<p>벡터의 요소들을 이용 임의의 순서로 구성가능</p>
<pre><code class="language-hlsl">float4 A = float4(1, 2, 3, 4);

A.x     == 1
A.xy    == float2(1, 2)
A.wwxy  == float4(4, 4, 1, 2)
A.rgba  == float4(1, 2, 3, 4)
</code></pre>
<h2 id="내적-외적"><a class="header" href="#내적-외적">내적 외적</a></h2>
<ul>
<li>내적과 외적 공식.</li>
<li>내적과 외적을 시각적으로 생각할 수 있어야 함.</li>
<li>이거 이름 햇갈리기 쉬움.</li>
</ul>
<h3 id="-내적--dot-product----inner-product-"><a class="header" href="#-내적--dot-product----inner-product-">| 내적 | Dot Product   | Inner Product |</a></h3>
<ul>
<li>닷은 점이니까 모이는건 내적</li>
<li>점이니까 두개 모아서 하나가 됨.</li>
<li>하나로 모이니 두 벡터 사이의 각도를 구할 수 있음.</li>
<li>각도니까 cos연산 들어감.</li>
<li><a href="https://rfriend.tistory.com/145">https://rfriend.tistory.com/145</a></li>
<li>교환법칙이 성립</li>
</ul>
<pre><code class="language-ref">| 각도 | 값  |
| ---- | --- |
|    0 |  1  |
|   90 |  0  |
|  180 | -1  |
| -270 |  0  |

        1
        |
        |
0-------+------ 0
        |
        |
       -1
</code></pre>
<h3 id="-외적--cross-product--outer-product-"><a class="header" href="#-외적--cross-product--outer-product-">| 외적 | Cross Product | Outer Product |</a></h3>
<ul>
<li>크로스는 삐죽하니까 외적으로 외울껏.</li>
<li>X 니까 삐저나옴.</li>
<li>X가 직각이니 수직 구할때 씀.</li>
<li><a href="https://rfriend.tistory.com/146">https://rfriend.tistory.com/146</a></li>
<li>교환법칙 성립안함</li>
</ul>
<h2 id="matrix"><a class="header" href="#matrix">Matrix</a></h2>
<p>If w == 1, then the vector (x,y,z,1) is a position in space.
If w == 0, then the vector (x,y,z,0) is a direction</p>
<pre><code class="language-hlsl">// 순서주의
TransformedVector = TranslationMatrix * RotationMatrix * ScaleMatrix * OriginalVector;
</code></pre>
<pre><code class="language-txt">// ref: https://www.3dgep.com/3d-math-primer-for-game-programmers-matrices/#Rotation_about_an_arbitrary_axis

이동행렬
|  1  0  0  x  |
|  0  1  0  y  |
|  0  0  1  z  |
|  0  0  0  1  |

스케일
|  x  0  0  0  |
|  0  y  0  0  |
|  0  0  z  0  |
|  0  0  0  1  |


X축 회전
|    1    0    0    0 |
|    0  cos -sin    0 |
|    0  sin  cos    0 |
|    0    0    0    1 |

Y축 회전
|  cos    0  sin    0 |
|    0    1    0    0 |
| -sin    0  cos    0 |
|    0    0    0    1 |

Z축 회전
|  cos -sin    0    0 |
|  sin  cos    0    0 |
|    0    0    1    0 |
|    0    0    0    1 |


임의의 N축 회전
s : sin
c : cos
ic: 1 - cos

| ic * NxNx + c      | ic * NxNy - s * Nz | ic * NzNx + s * Ny | 0 |
| ic * NxNy + s * Nz | ic * NyNy + c      | ic * NyNz - s * Nx | 0 |
| ic * NzNx - s * Ny | ic * NyNz + s * Nx | ic * NzNz + c      | 0 |
|                  0 |                  0 |                  0 | 1 |
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh"><a class="header" href="#mesh">Mesh</a></h1>
<ul>
<li><a href="https://docs.unity3d.com/ScriptReference/Mesh.html">https://docs.unity3d.com/ScriptReference/Mesh.html</a></li>
</ul>
<pre><code class="language-cs">// (0,1) +----+ (1,1)
//       |    |
// (0,0) +----+ (1,0)
//
//     2 +----+ 3
//       |    |
//     0 +----+ 1


Mesh mesh = new Mesh();
Vector3[] vertices = new Vector3[4] {
    new Vector3(0, 0, 0),
    new Vector3(1, 0, 0),
    new Vector3(0, 1, 0),
    new Vector3(1, 1, 0)
};

int[] tris = new int[6] {
    // lower left triangle
    0, 2, 1,

    // upper right triangle
    2, 3, 1
};

Vector2[] uv = new Vector2[4] {
    new Vector2(0, 0),
    new Vector2(1, 0),
    new Vector2(0, 1),
    new Vector2(1, 1)
};

Vector3[] normals = new Vector3[4] {
    -Vector3.forward,
    -Vector3.forward,
    -Vector3.forward,
    -Vector3.forward
};

mesh.vertices = vertices;
mesh.triangles = tris;
mesh.uv = uv;
mesh.normals = normals;
</code></pre>
<h2 id="topology"><a class="header" href="#topology">Topology</a></h2>
<ul>
<li><a href="https://docs.unity3d.com/ScriptReference/MeshTopology.html">https://docs.unity3d.com/ScriptReference/MeshTopology.html</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>MeshTopology</th></tr></thead><tbody>
<tr><td>Points</td></tr>
<tr><td>Lines</td></tr>
<tr><td>LineStrip</td></tr>
<tr><td>Triangles</td></tr>
<tr><td>Quads</td></tr>
</tbody></table>
</div>
<pre><code class="language-cs">MehsFilter mf = GetComponent&lt;MeshFilter&gt;();
mf.mesh.SetIndice(mf.mesh.GetIndices(0), MeshTopology.Points, 0);
</code></pre>
<pre><code class="language-cs">public void SetIndices(int[] indices, MeshTopology topology, int submesh, bool calculateBounds = true, int baseVertex = 0);
</code></pre>
<p>메쉬토폴로지를 변경시켜 좀 더 그럴듯한 효과를 얻을 수 있다.</p>
<h2 id="ref"><a class="header" href="#ref">Ref</a></h2>
<ul>
<li><a href="https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html">https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coordinate"><a class="header" href="#coordinate">Coordinate</a></h1>
<ul>
<li>좌표공간</li>
</ul>
<p><img src="Basic/../res/coordinate.png" alt="res/coordinate.png" /></p>
<h2 id="유니티-정의-positions"><a class="header" href="#유니티-정의-positions">유니티 정의 positions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>position</th><th>Space</th><th>AKA</th><th>타입</th><th>설명</th></tr></thead><tbody>
<tr><td>positionOS</td><td>Object</td><td>Local / Model</td><td>float3</td><td></td></tr>
<tr><td>positionWS</td><td>World</td><td>Global</td><td>float3</td><td></td></tr>
<tr><td>positionVS</td><td>View</td><td>Camera / Eye</td><td>float3</td><td>카메라에서 바라볼때</td></tr>
<tr><td>positionCS</td><td>Homogeneous Clip</td><td></td><td>float4</td><td>카메라 시야에서 안보인 것은 제외, Orthogonal 적용</td></tr>
<tr><td>positionNDC</td><td>Homogeneous Normalized Device Coordinate</td><td></td><td>float4</td><td>[ 0, w] : (x, y, z, w)</td></tr>
</tbody></table>
</div>
<h2 id="내가-임의로-정한것"><a class="header" href="#내가-임의로-정한것">내가 임의로 정한것</a></h2>
<div class="table-wrapper"><table><thead><tr><th>이름 붙여봄 position</th><th>Space</th><th>타입</th><th>설명</th></tr></thead><tbody>
<tr><td>ndc</td><td>Nonhomogeneous Normalized Device Coordinate</td><td>float3</td><td>[-1, 1] : PerspectiveDivision * 2 - 1</td></tr>
<tr><td>uv_Screen</td><td>Screen</td><td>float2</td><td>[ 0, 1] : PerspectiveDivision</td></tr>
<tr><td>positionScreen</td><td>ViewPort</td><td>float2</td><td>[화면 넓이, 화면 높이]</td></tr>
</tbody></table>
</div>
<h2 id="공간-변환-그림-예"><a class="header" href="#공간-변환-그림-예">공간 변환 그림 예</a></h2>
<p>예1)</p>
<p><img src="Basic/../res/opengl_renderpipeline.png" alt="res/opengl_renderpipeline.png" /></p>
<p>예2)</p>
<p><img src="Basic/../res/newtranspipe.png" alt="res/newtranspipe.png" /></p>
<h2 id="unity_matrix"><a class="header" href="#unity_matrix">UNITY_MATRIX</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Matrix</th><th>설명</th></tr></thead><tbody>
<tr><td>UNITY_MATRIX_M</td><td>renderer.localToWorldMatrix</td></tr>
<tr><td>UNITY_MATRIX_V</td><td>camera.worldToCameraMatrix</td></tr>
<tr><td>UNITY_MATRIX_P</td><td>GL.GetGPUProjectionMatrix(camera.projectionMatrix, false);</td></tr>
</tbody></table>
</div>
<ul>
<li>localToWorldMatrix
<ul>
<li>유니티 4까지는 GPU에 넘겨주기전에 스케일을 가공하여</li>
<li>renderer.localToWorldMatrix, transform.localToWorldMatrix가 달랐으나 지금은 같음.</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>카메라 관련</th><th>렌더링(UNITY_MATRIX_)의 뷰 전방은 <code>-z</code>. 카메라 행렬은 에디터와 동일하게 <code>+z</code>를 앞으로 사용</th></tr></thead><tbody>
<tr><td>UNITY_MATRIX_V</td><td>cam.worldToCameraMatrix</td></tr>
<tr><td>unity_WorldToCamera</td><td>Matrix4x4(cam.transform.position, cam.transform.rotation, Vector3.one)</td></tr>
<tr><td>UNITY_MATRIX_I_V</td><td>cam.cameraToWorldMatrix</td></tr>
<tr><td>unity_CameraToWorld</td><td>Matrix4x4(cam.transform.position, cam.transform.rotation, Vector3.one).inverse</td></tr>
<tr><td>UNITY_MATRIX_P</td><td>GL.GetGPUProjectionMatrix(camera.projectionMatrix, false)</td></tr>
<tr><td>unity_CameraProjection</td><td>cam.projectionMatrix</td></tr>
<tr><td>UNITY_MATRIX_I_P</td><td>GL.GetGPUProjectionMatrix(camera.projectionMatrix, false).inverse</td></tr>
<tr><td>unity_CameraInvProjection</td><td>cam.projectionMatrix.inverse</td></tr>
</tbody></table>
</div>
<pre><code class="language-txt">OS  ----------------------- Object Space
 | UNITY_MATRIX_M * OS
WS  ----------------------- World Space
 | UNITY_MATRIX_V * WS
VS  ----------------------- View Space
 | UNITY_MATRIX_P * VS
CS  ----------------------- Homogeneous Clip Space
 | NDC    = CS * 0.5
 | NDC.x  =  NDC.x + NDC.w
 | NDC.y  =  NDC.y + NDC.w // DirectX
 | NDC.y  = -NDC.y + NDC.w // OpenGL
 | NDC.zw = CS.zw
NDC ---------------------- Homogeneous Normalized Device Coordinate [0..w]
 | pd = (NDC.xyz / NDC.w); // [0, 1] : perspective divide
 | ndc = pd * 2.0 - 1.0;   // [-1, 1]
ndc ---------------------- Nonhomogeneous Normalized Device Coordinate [-1..1]
</code></pre>
<pre><code class="language-hlsl">// com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl
struct VertexPositionInputs
{
    float3 positionWS; // World space position
    float3 positionVS; // View space position
    float4 positionCS; // Homogeneous clip space position
    float4 positionNDC;// Homogeneous normalized device coordinates
};

// com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl
VertexPositionInputs GetVertexPositionInputs(float3 positionOS)
{
    VertexPositionInputs input;
    input.positionWS = TransformObjectToWorld(positionOS);      // UNITY_MATRIX_M
    input.positionVS = TransformWorldToView(input.positionWS);  // UNITY_MATRIX_V
    input.positionCS = TransformWorldToHClip(input.positionWS); // UNITY_MATRIX_VP

    float4 ndc = input.positionCS * 0.5f;
    input.positionNDC.xy = float2(ndc.x, ndc.y * _ProjectionParams.x) + ndc.w;
    input.positionNDC.zw = input.positionCS.zw;

    return input;
}

// com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl
TransformObjectToWorld - UNITY_MATRIX_M
TransformWorldToView   - UNITY_MATRIX_V
TransformWViewToHClip  - UNITY_MATRIX_P
TransformWorldToHClip  - UNITY_MATRIX_VP
</code></pre>
<div class="table-wrapper"><table><thead><tr><th><a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">_ProjectionParams</a></th><th>x</th><th>y</th><th>z</th><th>w</th></tr></thead><tbody>
<tr><td>DirectX</td><td>1</td><td>near plane</td><td>far plane</td><td>1 / farplane</td></tr>
<tr><td>OpenGL</td><td>-1</td><td>near plane</td><td>far plane</td><td>1 / farplane</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th>UNITY_REVERSED_Z</th><th>UNITY_NEAR_CLIP_VALUE</th><th>UNITY_RAW_FAR_CLIP_VALUE</th></tr></thead><tbody>
<tr><td>DirectX</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>Vulkan</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>OpenGL</td><td>0</td><td>-1</td><td>1</td></tr>
</tbody></table>
</div>
<h2 id="ndc"><a class="header" href="#ndc">NDC</a></h2>
<pre><code class="language-hlsl">// [0, w] // Homogeneous Normalized Device Coordinate
float4 positionNDC = GetVertexPositionInputs(positionOS).positionNDC;

// [0, 1] // Perspective Division
float3 pd = positionNDC.xyz / positionNDC.w;

// [-1, 1] // Nonhomogeneous Normalized Device Coordinate
float3 ndc = pd * 2.0 - 1.0;

// [0, 1]
float2 uv_Screen = positionNDC.xy / positionNDC.w;

// [0, screenWidth] / [0, screenHeight]
float2 positionScreen = uv_Screen * _ScreenParams.xy;
</code></pre>
<pre><code class="language-hlsl">// float4 ndc = input.positionCS * 0.5f;
// input.positionNDC.xy = float2(ndc.x, ndc.y * _ProjectionParams.x) + ndc.w;
// input.positionNDC.zw = input.positionCS.zw;
NDC = float4(
    (0.5 * CS.x                       ) + 0.5 * CS.w,
    (0.5 * CS.y *  _ProjectionParams.x) + 0.5 * CS.w,
    CS.z,
    CS.w
);

// pd = NDC.xyz / NDC.w
pd = float3(
    (0.5 * CS.x                        / CS.w) + 0.5,
    (0.5 * CS.y *  _ProjectionParams.x / CS.w) + 0.5,
    CS.z / CS.w
);

// ndc = pd * 2 - 1
ndc = float3(
    (CS.x                       / CS.w),
    (CS.y * _ProjectionParams.x / CS.w),
    (CS.z                       / CS.w) * 2  - 1,
);

// uv_Screen = NDC.xy / NDC.w
uv_Screen = float2(
    (CS.x                       / CS.w),
    (CS.y * _ProjectionParams.x / CS.w)
);

// positionScreen = uv_Screen * _ScreenParams.xy
positionScreen = float2(
    (CS.x                       / CS.w) * _ScreenParams.x,
    (CS.y * _ProjectionParams.x / CS.w) * _ScreenParams.y
);
</code></pre>
<h2 id="normal"><a class="header" href="#normal">Normal</a></h2>
<ul>
<li><a href="Basic/./NormalMap.html">./NormalMap.md</a></li>
</ul>
<h2 id="pserspective-camera"><a class="header" href="#pserspective-camera">Pserspective Camera</a></h2>
<ul>
<li><a href="https://chengkehan.github.io/ReconstructPositionFromDepth.html">https://chengkehan.github.io/ReconstructPositionFromDepth.html</a></li>
</ul>
<p><img src="Basic/../res/projectionMatrix.jpg" alt="./res/projectionMatrix.jpg" /></p>
<pre><code class="language-cs">// Find our current location in the camera's projection space.
Vector3 pt = Camera.main.projectionMatrix.MultiplyPoint(transform.position);

// Matrix4x4.MultiplyPoint
public Vector3 MultiplyPoint(Matrix4x4 mat, Vector3 v)
{
    Vector3 result;
    result.x = mat.m00 * v.x + mat.m01 * v.y + mat.m02 * v.z + mat.m03;
    result.y = mat.m10 * v.x + mat.m11 * v.y + mat.m12 * v.z + mat.m13;
    result.z = mat.m20 * v.x + mat.m21 * v.y + mat.m22 * v.z + mat.m23;
    float num = mat.m30 * v.x + mat.m31 * v.y + mat.m32 * v.z + mat.m33;
    num = 1 / num;
    result.x *= num;
    result.y *= num;
    result.z *= num;
    return result;
}

// z값 구하지 않으면
public Vector3 MultiplyPoint(Matrix4x4 mat, Vector3 v)
{
    Vector3 result;
    result.x = mat.m00 * v.x + mat.m01 * v.y + mat.m02 * v.z + mat.m03;
    result.y = mat.m10 * v.x + mat.m11 * v.y + mat.m12 * v.z + mat.m13;
    float num = mat.m30 * v.x + mat.m31 * v.y + mat.m32 * v.z + mat.m33;
    num = 1 / num;
    result.x *= num;
    result.y *= num;
    return result;
}

// 값을 대입하면
public Vector3 MultiplyPoint(Matrix4x4 mat, Vector3 v)
{
    Vector3 result;
    result.x = mat.m00 * v.x + 0 * v.y + 0 * v.z + 0;
    result.y = 0 * v.x + mat.m11 * v.y + 0 * v.z + 0;
    float num = 0 * v.x + 0 * v.y + -1 * v.z + 0;
    num = 1 / num;
    result.x *= num;
    result.y *= num;
    return result;
}

// 최종적으로
public Vector3 MultiplyPoint(Matrix4x4 mat, Vector3 v)
{
    Vector3 result;
    result.x = mat.m00 * v.x;
    result.y = mat.m11 * v.y;
    float num = -1 * v.z;
    num = 1 / num;
    result.x *= num;
    result.y *= num;
    return result;
}

(X, Y, linearEyeDepth)
positionNDC // [-1, 1]
X = positionNDC.x * linearEyeDepth / mat.m00
Y = positionNDC.x * linearEyeDepth / mat.m11


The zero-based row-column position:
|  _m00, _m01, _m02, _m03 |
|  _m10, _m11, _m12, _m13 |
|  _m20, _m21, _m22, _m23 |
|  _m30, _m31, _m32, _m33 |

The one-based row-column position:
|   _11,  _12,  _13,  _14 |
|   _21,  _22,  _23,  _24 |
|   _31,  _32,  _33,  _34 |
|   _41,  _42,  _43,  _44 |

</code></pre>
<h2 id="uv"><a class="header" href="#uv">UV</a></h2>
<p>texel(TExture + piXEL) coordinate</p>
<pre><code class="language-txt">Direct X
(0,0)            (1,0)
  +-------+-------+
  |       |       |
  |       |       |
  +-------+-------+
  |       |       |
  |       |       |
  +-------+-------+
(0,1)            (1,1)


OpenGL / UnityEngine
(0,1)            (1,1)
  +-------+-------+
  |       |       |
  |       |       |
  +-------+-------+
  |       |       |
  |       |       |
  +-------+-------+
(0,0)            (1,0)
</code></pre>
<ul>
<li>수학적으로 바라보면 모든 2D좌표계를 OpenGL방식으로하면 좌표계를 헷갈릴 걱정이 없다. 하지만, 프로그래밍 하는 입장에서는 DirectX방식이 좀 더 와닿을 것이다.</li>
</ul>
<h2 id="ref-1"><a class="header" href="#ref-1">Ref</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=u_qKLcszwXA">Computergrafik - Vorlesung 6 - Coordinate Systems</a></li>
<li><a href="https://www.sysnet.pe.kr/2/0/11633">Unity - shader의 World matrix(unity_ObjectToWorld)를 수작업으로 구성</a></li>
<li><a href="https://www.sysnet.pe.kr/2/0/11692">Unity - shader의 Camera matrix(UNITY_MATRIX_V)를 수작업으로 구성</a></li>
<li><a href="https://www.sysnet.pe.kr/2/0/11697">Unity - unity_CameraWorldClipPlanes 내장 변수 의미</a></li>
<li><a href="https://www.sysnet.pe.kr/2/0/11695">Unity - shader의 원근 투영(Perspective projection) 행렬(UNITY_MATRIX_P)을 수작업으로 구성</a></li>
<li><a href="http://rapapa.net/?p=3531">렌더링 파이프라인의 좌표 공간들</a></li>
<li><a href="https://shahriyarshahrabi.medium.com/look-at-transformation-matrix-in-vertex-shader-81dab5f4fc4">Look At Transformation Matrix in Vertex Shader</a></li>
<li><a href="https://docs.unity3d.com/ScriptReference/Transform-localToWorldMatrix.html">transform.localToWorldMatrix</a></li>
<li><a href="https://docs.unity3d.com/ScriptReference/Renderer-localToWorldMatrix.html">Renderer.localToWorldMatrix</a></li>
<li><a href="https://docs.unity3d.com/ScriptReference/Camera-worldToCameraMatrix.html">Camera.worldToCameraMatrix</a></li>
<li><a href="https://docs.unity3d.com/ScriptReference/Camera-projectionMatrix.html">Camera.projectionMatrix</a></li>
<li><a href="https://docs.unity3d.com/ScriptReference/GL.GetGPUProjectionMatrix.html">GL.GetGPUProjectionMatrix</a></li>
<li><a href="http://blog.hvidtfeldts.net/index.php/2014/01/combining-ray-tracing-and-polygons/">http://blog.hvidtfeldts.net/index.php/2014/01/combining-ray-tracing-and-polygons/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alpha"><a class="header" href="#alpha">Alpha</a></h1>
<ul>
<li>알파쓰면 Testing(discard)이나 Blend가 할 것 없이 성능 잡아먹는다.
<ul>
<li>구형 모바일 디바이스에선 Blend쪽이 성능이 잘 나오는 경향이 있었다.</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">SubShader
{
    Tags // SubShader의 Tags는 Pass의 Tags와 다름.
    {
        "RenderPipeline" = "UniversalRenderPipeline"

        // "IgnoreProjector" &lt;&lt;&lt; 요놈은 URP에서 안씀

        // for cutout
        "Queue" = "AlphaTest"              // 렌더순서
        "RenderType" = "TransparentCutout" // 그룹핑(전체 노말맵같이 한꺼번에 바꾸어 그릴때 이용)

        // for blend
        "Queue" = "Transparent"
        "RenderType" = "Transparent"
    }

    Pass
    {
        Tags
        {
            "LightMode" = "UniversalForward"
        }

        // https://docs.unity3d.com/Manual/SL-Blend.html
        Blend A B

        // http://docs.unity3d.com/Manual/SL-CullAndDepth.html
        ZWrite &lt;On | Off&gt; // default: On 
        ZTest &lt;(Less | Greater | LEqual | GEqual | Equal | NotEqual | Always)&gt; // default: LEqual 
    }
}
</code></pre>
<ul>
<li>Blend
<ul>
<li>색 혼합 방법</li>
</ul>
</li>
<li>ZWrite
<ul>
<li>Z 값을 기록할지 안할지 결정.</li>
</ul>
</li>
<li>ZTest
<ul>
<li>Z 값이 씌여져 있는 상태를 읽어서(ZRead), 그려져도 되는지를 결정.</li>
</ul>
</li>
</ul>
<p><img src="Basic/../res/unity_blend.png" alt="unity_blend" /></p>
<h2 id="alpha-cutout--alpha-testing"><a class="header" href="#alpha-cutout--alpha-testing">Alpha Cutout / Alpha Testing</a></h2>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-clip">clip</a>(<a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/texkill---ps">texkill</a>)을 이용</li>
<li>간편. sorting걱정 안해도 됨.</li>
<li>구형 모바일에서는 AlphaBlend 보다 성능이 안나오는 경향이 있음.
<ul>
<li>요즘은 AlphaTesting이 더 낳을지도</li>
<li>모바일(A11(ios), PowerVR 등)은 메모리와 대역폭을 줄이기위해 타일별 렌더링을 하는 TBDR(tile-based deferred rendering)을 이용함.</li>
<li>알파테스팅을 이용할시, 실제 보여지는지 여부를 알파테스팅이 끝날때까지 알 수 없으므로 Deffered 최적화를 방해함.</li>
</ul>
</li>
<li>풀, 나무, 머리카락, 털 등...</li>
<li>clip하여 너무 각지는게 보기 싫어질 정도면 blend를 잘 쓰자</li>
<li>// if ZWrite is Off, clip() is fast enough on mobile, because it won't write the DepthBuffer, so no GPU pipeline stall(confirmed by ARM staff).</li>
</ul>
<p><img src="Basic/../res/TBDR.jpg" alt="TBDR.jpg" /></p>
<pre><code class="language-hlsl">SubShader
{
    Tags // SubShader의 Tags는 Pass의 Tags와 다름.
    {
        "RenderPipeline" = "UniversalRenderPipeline"
        "Queue" = "AlphaTest"
        "RenderType" = "TransparentCutout"
    }

    Pass
    {
        Tags
        {
            "LightMode" = "UniversalForward"
        }

        HLSLPROGRAM
        ...
        half4 frag(VStoFS IN) : SV_Target
        {
            half alpha = ...;
            clip(alpha - _Cutoff);

            return half4(1, 0, 0, 1);
        }
        half4 
        ENDHLSL
    }
}
</code></pre>
<pre><code class="language-hlsl">// URP에선 `_ALPHATEST_ON` 여부로 할지 말지 결정하는 함수가 있다.
// https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl
void AlphaDiscard(real alpha, real cutoff, real offset = real(0.0))
{
    #ifdef _ALPHATEST_ON
        clip(alpha - cutoff + offset);
    #endif
}
</code></pre>
<h2 id="alpha-blend"><a class="header" href="#alpha-blend">Alpha Blend</a></h2>
<ul>
<li>이펙트에서 주로 쓰임</li>
<li>Alpha Testing보다 디테일 살릴때...</li>
<li>불투명 유리</li>
</ul>
<pre><code class="language-hlsl">SubShader
{
    Tags // SubShader의 Tags는 Pass의 Tags와 다름.
    {
        "RenderPipeline" = "UniversalRenderPipeline"
        "Queue" = "Transparent"
        "RenderType" = "Transparent"
    }

    Pass
    {
        ZWrite Off // 픽셀 중복으로 출력됨.
        Blend SrcAlpha OneMinusSrcAlpha

        Tags
        {
            "LightMode" = "UniversalForward"
        }
    }
}
</code></pre>
<ul>
<li><code>ZWrite Off</code> - 뒷면까지 렌더링하는게 문제가됨
<ul>
<li>2Pass로 보이는면 랜더링</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">SubShader
{
    Tags // SubShader의 Tags는 Pass의 Tags와 다름.
    {
        "RenderPipeline" = "UniversalRenderPipeline"
        "Queue" = "Transparent"
        "RenderType" = "Transparent"
    }

    Pass
    {
        Tags
        {
            "LightMode" = "SRPDefaultUnlit"
        }
        ZWrite On
        ColorMask 0 // 색 렌더링 안함
        Cull Front

        HLSLPROGRAM
        ...
        ENDHLSL
    }

    Pass
    {
        Tags
        {
            "LightMode" = "UniversalForward"
        }

        ZWrite Off
        Cull Back
        Blend SrcAlpha OneMinusSrcAlpha

        HLSLPROGRAM
        ...
        ENDHLSL
    }
}

</code></pre>
<h2 id="ref-2"><a class="header" href="#ref-2">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/crjl5/2-205467251">Jihoo Oh - 이펙트 쉐이더 2강 - 알파 / 블랜딩</a></li>
<li><a href="https://www.gamedev.net/forums/topic/656826-why-the-alphablend-is-a-better-choice-than-alphatest-to-implement-transparent-on-mobile-device/5154785/">https://www.gamedev.net/forums/topic/656826-why-the-alphablend-is-a-better-choice-than-alphatest-to-implement-transparent-on-mobile-device/5154785/</a></li>
<li><a href="https://ozlael.tistory.com/24">모바일 기기의 Tile Based Rendering(타일 기반 렌더링)과 유니티에서의 주의 사항 #2 : TBR 대응 리소스 제작시 주의점</a></li>
<li><a href="https://blog.naver.com/dasoong15/221356325748">https://blog.naver.com/dasoong15/221356325748</a></li>
<li><a href="http://powervr-graphics.github.io/WebGL_SDK/WebGL_SDK/Documentation/Architecture%20Guides/PowerVR%20Performance%20Recommendations.The%20Golden%20Rules.pdf">PowerVR Performance Recommendations The Golden Rules</a></li>
<li>Z 버퍼의 Read / Write 개념 by 김윤정
<ul>
<li><a href="http://chulin28ho.egloos.com/5267860">1부. Z 값과 Z 버퍼</a></li>
<li><a href="http://chulin28ho.egloos.com/5268685">2부. 개악마 알파 블렌딩1편</a></li>
<li><a href="http://chulin28ho.egloos.com/5269434">3부. 개악마 알파 블렌딩2편</a></li>
<li><a href="http://chulin28ho.egloos.com/5270691">4부. 개악마 알파 블렌딩3편</a></li>
<li><a href="http://chulin28ho.egloos.com/5271687">5부, 알파 테스팅</a></li>
<li><a href="http://chulin28ho.egloos.com/5272883">6부, Z Read/Write</a></li>
<li><a href="http://chulin28ho.egloos.com/5284164">7부, Z Read On / Write Off</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="normalmap"><a class="header" href="#normalmap">NormalMap</a></h1>
<pre><code class="language-hlsl">inline void ExtractTBN(in half3 normalOS, in float4 tangent, inout half3 T, inout half3  B, inout half3 N)
{
    N = TransformObjectToWorldNormal(normalOS);
    T = TransformObjectToWorldDir(tangent.xyz);
    B = cross(N, T) * tangent.w * unity_WorldTransformParams.w;
}

inline half3 CombineTBN(in half3 tangentNormal, in half3 T, in half3  B, in half3 N)
{
    return mul(tangentNormal, float3x3(normalize(T), normalize(B), normalize(N)));
}

Varyings vert(Attributes IN)
{
    ExtractTBN(IN.normalOS, IN.tangent, OUT.T, OUT.B, OUT.N);
}

half4 frag(Varyings IN) : SV_Target
{
    half3 normalTex = UnpackNormal(SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex, IN.uv));
    half3 N = CombineTBN(normalTex, IN.T, IN.B, IN.N);
}
</code></pre>
<ul>
<li>NormalMap(법선맵)을 쓰는 이유?</li>
<li>TBN이란?</li>
<li>world-Normal 구하는 법?</li>
<li>노말맵 혹은 법선맵(tangent space)에서 g채널을 뒤집는 이유?</li>
</ul>
<h2 id="법선맵을-쓰는-이유"><a class="header" href="#법선맵을-쓰는-이유">법선맵을 쓰는 이유</a></h2>
<ul>
<li>정점(vertex)을 많이 밖아서 디테일을 표시하면, 실시간으로 정점을 처리하는데 부하가 걸린다(주로 CPU).</li>
<li>셰이더 계산시 법선맵에서 가상의 정점을 생성해 빛을 계산하면 디테일을 살릴 수 있다.</li>
</ul>
<h2 id="object-space-vs-tangent-space"><a class="header" href="#object-space-vs-tangent-space">Object Space vs Tangent Space</a></h2>
<ul>
<li>리깅을 사용하는 모델의 경우 정점이 몰핑되면서 노말 벡터의 방향이 바뀌게 되는데 이때는 고정된 오브젝트 의 공간좌표계는 의미가 없어짐.</li>
</ul>
<h2 id="tbn"><a class="header" href="#tbn">TBN</a></h2>
<div class="table-wrapper"><table><thead><tr><th>TBN</th><th>Source</th><th>xyz</th><th>UV</th></tr></thead><tbody>
<tr><td><code>T</code>angent</td><td>TANGENT</td><td>x</td><td>u</td></tr>
<tr><td><code>B</code>inormal</td><td>cross(T, N)</td><td>y</td><td>v</td></tr>
<tr><td><code>N</code>ormal</td><td>NORMAL</td><td>z</td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-shader">N = mul(mat_I_M, normalOS);
T = mul(tangentOS, mat_M);
B = mul(binormalOS, mat_M);
// unity같이 binormalOS를 못어올 경우 N, T를 이용하여 B를 만들 수 있다.
// B = cross(N, T) * tangentOS.w

======== 월드공간 T / B / N 을 구하고 TBN매트릭스(tangent -&gt; world)를 만든다
float3x3 TBN_Tangent2World = float3x3(normalize(Input.T), normalize(Input.B), normalize(Input.N));
| Tx Ty Tz |
| Bx By Bn |
| Nx Ny Nz |

mul(tangentNormal, TBN_Tangent2World);   // 왠지 이케 해버리면 앞서 말한 NormalScaleProblem에 걸릴것 같음


======== TBN은 직교행렬, 직교행렬의 역행렬은 전치행렬.
TBN_World2Tangent = transpose(TBN_Tangent2World);
| Tx Bx Nx |
| Ty By Ny |
| Yz Bz Nz |

mul(TBN_World2Tangent, tangentNormal);   // 이케하면 되겠지?

======== 뇌피셜
// 위에꺼도 맞긴 맞는데...
// TBN은 직교행렬, 직교행렬의 역행렬은 전치행렬.
// traspose(inverse(M)) == M
mul(tangentNormal, TBN_Tangent2World);  // 따라서 이케해도 문제될꺼 없음? 확인해봐야함
</code></pre>
<h2 id="normal-flatten"><a class="header" href="#normal-flatten">normal flatten</a></h2>
<pre><code class="language-hlsl">
//                               T, B, N
const float3 vec_TBN_UP = float3(0, 0, 1);

normalTS = lerp(normalTS, vec_TBN_UP, _Flatteness);
</code></pre>
<h2 id="block-compression"><a class="header" href="#block-compression">Block Compression</a></h2>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3d10/d3d10-graphics-programming-guide-resources-block-compression#bc3">https://docs.microsoft.com/en-us/windows/win32/direct3d10/d3d10-graphics-programming-guide-resources-block-compression#bc3</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>DXT5</td><td>BC3 format</td><td>(x, y, 0, 1)</td></tr>
<tr><td>DXT5nm</td><td>DXT5의 R채널값이 A채널로 이동된것</td><td>(1, y, 0, x)</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>BC3</th><th>channel</th><th>bit</th></tr></thead><tbody>
<tr><td>x</td><td>a0, a1</td><td>16</td></tr>
<tr><td></td><td>alpha indices</td><td>48</td></tr>
<tr><td>y</td><td>color0,1</td><td>32</td></tr>
<tr><td></td><td>color indices</td><td>32</td></tr>
</tbody></table>
</div>
<p><img src="Basic/../res/d3d10-compression-bc3.png" alt="d3d10-compression-bc3.png" /></p>
<div class="table-wrapper"><table><thead><tr><th>BC5</th><th>channel</th><th>bit</th></tr></thead><tbody>
<tr><td>x</td><td>r0, r1</td><td>16</td></tr>
<tr><td></td><td>red indices</td><td>48</td></tr>
<tr><td>y</td><td>g0, g1</td><td>32</td></tr>
<tr><td></td><td>green indices</td><td>32</td></tr>
</tbody></table>
</div>
<p><img src="Basic/../res/d3d10-compression-bc5.png" alt="d3d10-compression-bc5.png" /></p>
<h3 id="unity_no_dxt5nm"><a class="header" href="#unity_no_dxt5nm">UNITY_NO_DXT5nm</a></h3>
<p>DXT5nm이 아닌 경우(UNITY_NO_DXT5nm) 는 다음과 같은 공식을 썼으나,</p>
<pre><code class="language-shader">real3 UnpackNormalRGBNoScale(real4 packedNormal)
{
    return packedNormal.rgb * 2.0 - 1.0;
}
</code></pre>
<p>아닌경우 UnpackNormalmapRGorAG을 사용 DXT5, DXT5nm을 처리할 수 있게한다.</p>
<pre><code class="language-hlsl">real3 UnpackNormal(real4 packedNormal)
{
#if defined(UNITY_ASTC_NORMALMAP_ENCODING)
    return UnpackNormalAG(packedNormal, 1.0);
#elif defined(UNITY_NO_DXT5nm)
    return UnpackNormalRGBNoScale(packedNormal);
#else
    // Compiler will optimize the scale away
    return UnpackNormalmapRGorAG(packedNormal, 1.0);
#endif
}

// Unpack normal as DXT5nm (1, y, 0, x) or BC5 (x, y, 0, 1)
real3 UnpackNormalmapRGorAG(real4 packedNormal, real scale = 1.0)
{
    // Convert to (?, y, 0, x)
    packedNormal.a *= packedNormal.r;
    return UnpackNormalAG(packedNormal, scale);
}

real3 UnpackNormalAG(real4 packedNormal, real scale = 1.0)
{
    real3 normal;
    normal.xy = packedNormal.ag * 2.0 - 1.0;
    normal.z = max(1.0e-16, sqrt(1.0 - saturate(dot(normal.xy, normal.xy))));

    // must scale after reconstruction of normal.z which also
    // mirrors UnpackNormalRGB(). This does imply normal is not returned
    // as a unit length vector but doesn't need it since it will get normalized after TBN transformation.
    // If we ever need to blend contributions with built-in shaders for URP
    // then we should consider using UnpackDerivativeNormalAG() instead like
    // HDRP does since derivatives do not use renormalization and unlike tangent space
    // normals allow you to blend, accumulate and scale contributions correctly.
    normal.xy *= scale;
    return normal;
}
</code></pre>
<ul>
<li>xyzw, wy =&gt; _g_r =&gt; rg =&gt; xyn // r이 뒤로 있으므로, 한바퀴 돌려줘야함.</li>
<li><code>normal.xy = packednormal.wy * 2 - 1;</code> (0 ~ 1 =&gt; -1 ~ 1)</li>
<li><code>Z</code>는 쉐이더에서 계산. 단위 벡터의 크기는 1인것을 이용.(sqrt(x^2 + y^2 + z^2) = 1) <code>sqrt(1 - saturate(dot(normal.xy, normal.xy)))</code></li>
</ul>
<h2 id="normal-scale-problem"><a class="header" href="#normal-scale-problem">Normal Scale Problem</a></h2>
<ul>
<li><a href="https://paroj.github.io/gltut/Illumination/Tut09%20Normal%20Transformation.html">Normal Transformation</a></li>
</ul>
<p>오브젝트를 스케일시킬때 Normal의 변화의 문제</p>
<p>A라는 도형을 x에 대해서 2만큼 스케일 업하고 싶다고 가정하면,</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>정점</th><th>x 스케일</th><th>노말</th></tr></thead><tbody>
<tr><td>A</td><td>(1, 1)</td><td>1</td><td>(1, 1)</td></tr>
<tr><td>B</td><td>(2, 1)</td><td>2</td><td>(2, 1)</td></tr>
<tr><td>C</td><td>(2, 1)</td><td>2</td><td>(0.5, 1)</td></tr>
</tbody></table>
</div>
<p><img src="Basic/../res/scaleproblem.png" alt="res" /></p>
<p>C처럼 x의 스케일 2배 됐다고, 노멀의 x값에 <code>곱하기</code> 2를 해서는 안된다. 역인 <code>나누기</code> 2 를 해야한다.</p>
<p>위치(position)에 대해서는 <code>world-Position = mul(obj-Position, M )</code>이 정상적으로 성립되었다.</p>
<p>하지만, <code>world-Normal = mul( obj-Normal, M )</code> 처럼 적용했을시 앞+선 <code>B</code>와 같은 문제가 발생한다.</p>
<p>월드행렬(M)식으로 나타내면</p>
<p><img src="Basic/../res/normal-1.png" alt="normal-1" /></p>
<p>우리가 구하고 싶은 행렬을 M-want라 했을시 <code>world-Normal = mul(M-want, obj-Normal)</code></p>
<p><img src="Basic/../res/normal-2.png" alt="normal-2" /></p>
<p><img src="Basic/../res/DeriveInvTrans_1.svg" alt="1" />
<img src="Basic/../res/FactorOutTranspose_2.svg" alt="2" />
<img src="Basic/../res/FactorOutInverse_3.svg" alt="3" /></p>
<p>즉 <code>M-want     = traspose(inverse(M))</code>.</p>
<p>DirectX기준 <code>row-major</code>에서의 메트릭스와 벡터의 인자 순서: <code>mul(벡터, 메트릭스) =  mul( transpose(메트릭스), 벡터 )</code></p>
<p>아레 예는 <code>row-major</code> 기준으로 작성.</p>
<pre><code class="language-formula">M          = ObjectToWorld
inverse(M) = WorldToObject
M-want     = traspose(inverse(M))

world-Normal
= mul(obj-Normal   , M-want              )
= mul(obj-Normal   , traspose(inverse(M)))
= mul(inverse(M)   , obj-Normal          )
= mul(WorldToObject, obj-Normal          )
</code></pre>
<h2 id="노말맵-혹은-법선맵tangent-space에서-g채널을-뒤집는-이유"><a class="header" href="#노말맵-혹은-법선맵tangent-space에서-g채널을-뒤집는-이유">노말맵 혹은 법선맵(tangent space)에서 g채널을 뒤집는 이유</a></h2>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=Y3rn-4Nup-E">pope - 노말맵은 왜 파란가?</a></p>
</li>
<li>
<p><a href="https://victorkarp.wordpress.com/2020/06/26/inverting-a-normal-map-in-blender/">https://victorkarp.wordpress.com/2020/06/26/inverting-a-normal-map-in-blender/</a></p>
</li>
<li>
<p>단위벡터의 크기가 1이지만, (-1, 0, 0)과 같은게 있으므로, 정규화된 법선벡터의 범위는 <code>-1...1</code>이다.</p>
</li>
<li>
<p>바이너리로 저장하기위해 범위를 <code>0...1</code>로 줄이려면 0.5를 곱하고 다시 0.5를 더해주면 된다.</p>
</li>
<li>
<p>셰이더에서 저장된 범위 <code>0...1</code>을 <code>-1...1</code>로 확장시키려면 2를 곱하고 1을 빼주면 <code>-1...1</code>의 범위로 확장된다.</p>
</li>
</ul>
<p>노말맵에서 z값이 강한 경우가 있는데 그럼 이미지가 퍼렇게 보이면서 돌출이 아닌 움푹 패인듯한 느낌이 든다.</p>
<ul>
<li>표면 안쪽으로 향하는(z의 값이 음수인) 경우가 없다.
<ul>
<li>범위는 <code>0 ~ 1</code></li>
<li>바이너리 저장시 범위가 <code>0.5 ~ 1</code>로 변경되면서 0.5부터 값이 시작된다.</li>
</ul>
</li>
<li>따라서 맵이 퍼렇게 보이면서, 돌출되는 부분이 이미지상 움푹들어간 모습처럼 보인다.</li>
</ul>
<p>그러므로, g채널을 뒤집어주면 돌출된 부분을 아티스트가 쉽게 인지할 수 있다.</p>
<h2 id="opengly--directx-y-"><a class="header" href="#opengly--directx-y-">OpenGL<code>Y+</code> / DirectX <code>Y-</code></a></h2>
<ul>
<li><a href="https://blender.stackexchange.com/questions/100017/directx-vs-opengl-normal-maps">https://blender.stackexchange.com/questions/100017/directx-vs-opengl-normal-maps</a></li>
</ul>
<p><img src="Basic/../res/directx_opengl_normalmap.png" alt="../res/directx_opengl_normalmap.png" /></p>
<ul>
<li>유니티는 OpenGL(Y+) 를 써서 보기 비교적 편하다.</li>
<li>DirectX와 같은 엔진에서는 작업자를 위해 Y+텍스쳐 제작 쉐이더에서 y에 <code>-1</code>을 곱해 뒤집어 주는 코드를 넣어주면 작업자들이 편해진다.</li>
</ul>
<h2 id="mikktspace"><a class="header" href="#mikktspace">MikkTSpace</a></h2>
<ul>
<li>Mikkelsen tangent space normal
<ul>
<li><a href="https://github.com/mmikk/MikkTSpace">https://github.com/mmikk/MikkTSpace</a></li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>URP</th><th>셰이더 그래프</th><th>URP Lit</th></tr></thead><tbody>
<tr><td>8.1.0</td><td>픽셀당 MikkTSpace 노멀 맵</td><td>정점당</td></tr>
<tr><td>8.2.0</td><td>픽셀당</td><td>픽셀당</td></tr>
</tbody></table>
</div>
<ul>
<li>노말맵 베이크
<ul>
<li>방식1. 하이트맵이나 일반 이미지를 이용해서 노멀맵 변환</li>
<li>방식2. 로우폴리곤과 하이폴리곤을 가지고 베이크
<ul>
<li>3D프로그램 별 에버레지 버텍스 노말에 동일한 연산을 하지 않음.
<ul>
<li>동일한 연산을 하도록 MikkTSpace로 통일.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ref-3"><a class="header" href="#ref-3">Ref</a></h2>
<ul>
<li>youtube: 안콜3D - (전체공개) 노말맵의 모든것
<ul>
<li>PART <a href="https://www.youtube.com/watch?v=NSLT6CoUUK0">01</a>, <a href="https://www.youtube.com/watch?v=bGv3OJQCGeM">02</a></li>
</ul>
</li>
<li><a href="https://xnormal.net/">xNormal</a> 프로그램
<ul>
<li>사용법
<ul>
<li>youtube: 엑스 노말(x-Normal) 사용법
<ul>
<li><a href="https://www.youtube.com/watch?v=v9RnG4jJ16k">1</a>, <a href="https://www.youtube.com/watch?v=Nl1A-C3rvfE">2</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://bgolus.medium.com/generating-perfect-normal-maps-for-unity-f929e673fc57">https://bgolus.medium.com/generating-perfect-normal-maps-for-unity-f929e673fc57</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cubemap"><a class="header" href="#cubemap">Cubemap</a></h1>
<ul>
<li>텍스쳐를 받을 수 있는 Cubemap생성하기 : <code>Create &gt; Legacy &gt; Cubemap</code></li>
</ul>
<pre><code class="language-hlsl">TEXTURECUBE(_CubeMap);  SAMPLER(sampler_CubeMap);

half3 reflectVN = reflect(-V, N);
half4 cubeReflect = SAMPLE_TEXTURECUBE_LOD(_CubeMap, sampler_CubeMap, reflectVN, 0);

half3 refractVN = refract(-V, N, 1 / _RefractiveIndex);
half4 cubeRefract = SAMPLE_TEXTURECUBE_LOD(_CubeMap, sampler_CubeMap, refractVN, 0);
</code></pre>
<h2 id="cubemapgen"><a class="header" href="#cubemapgen">CubemapGen</a></h2>
<ul>
<li><a href="https://gpuopen.com/archived/cubemapgen/">https://gpuopen.com/archived/cubemapgen/</a></li>
<li><a href="https://seblagarde.wordpress.com/2012/06/10/amd-cubemapgen-for-physically-based-rendering/">https://seblagarde.wordpress.com/2012/06/10/amd-cubemapgen-for-physically-based-rendering/</a></li>
<li><a href="https://github.com/gscept/CubeMapGen">https://github.com/gscept/CubeMapGen</a></li>
</ul>
<pre><code class="language-cs">// | AMD CubeMapGen | Unity |
// | -------------- | ----- |
// | X+             | -X    |
// | X-             | +X    |
// | Y+             | +Y    |
// | Y-             | -Y    |
// | Z+             | +Z    |
// | Z-             | -Z    |

using System.IO;
using UnityEditor;
using UnityEngine;

public class BakeStaticCubemap : ScriptableWizard
{
    static string imageDirectory = "Assets/CubemapImages";
    static string[] cubemapImage = new string[6] {
        "top+Y", "bottom-Y",
        "left-X", "right+X",
        "front+Z","back-Z",
    };
    static Vector3[] eulerAngles = new Vector3[6] {
        new Vector3(-90.0f, 0.0f, 0.0f), new Vector3(90.0f, 0.0f, 0.0f),
        new Vector3(0.0f, 90.0f, 0.0f), new Vector3(0.0f, -90.0f, 0.0f), 
        new Vector3(0.0f, 0.0f, 0.0f), new Vector3(0.0f, 180.0f, 0.0f),
    };


    public Transform renderPosition;
    public Cubemap cubemap;
    // Camera settings.
    public int cameraDepth = 24;
    public LayerMask cameraLayerMask = -1;
    public Color cameraBackgroundColor;
    public float cameraNearPlane = 0.1f;
    public float cameraFarPlane = 2500.0f;
    public bool cameraUseOcclusion = true;
    // Cubemap settings.
    public FilterMode cubemapFilterMode = FilterMode.Trilinear;
    // Quality settings.
    public int antiAliasing = 4;

    public bool IsCreateIndividualImages = false;

    [MenuItem("GameObject/Bake Cubemap")]
    static void RenderCubemap()
    {
        DisplayWizard("Bake CubeMap", typeof(BakeStaticCubemap), "Bake!");
    }

    void OnWizardUpdate()
    {
        helpString = "Set the position to render from and the cubemap to bake.";
        if (renderPosition != null &amp;&amp; cubemap != null)
        {
            isValid = true;
        }
        else
        {
            isValid = false;
        }
    }

    void OnWizardCreate()
    {
        QualitySettings.antiAliasing = antiAliasing;
        cubemap.filterMode = cubemapFilterMode;

        GameObject go = new GameObject("CubemapCam", typeof(Camera));
        go.transform.position = renderPosition.position;
        go.transform.rotation = Quaternion.identity;

        Camera camera = go.GetComponent&lt;Camera&gt;();
        camera.depth = cameraDepth;
        camera.backgroundColor = cameraBackgroundColor;
        camera.cullingMask = cameraLayerMask;
        camera.nearClipPlane = cameraNearPlane;
        camera.farClipPlane = cameraFarPlane;
        camera.useOcclusionCulling = cameraUseOcclusion;

        camera.RenderToCubemap(cubemap);
        if (IsCreateIndividualImages)
        {
            if (!Directory.Exists(imageDirectory))
            {
                Directory.CreateDirectory(imageDirectory);
            }
            RenderIndividualCubemapImages(camera);
        }
        DestroyImmediate(go);
    }

    void RenderIndividualCubemapImages(Camera camera)
    {
        camera.backgroundColor = Color.black;
        camera.clearFlags = CameraClearFlags.Skybox;
        camera.fieldOfView = 90;
        camera.aspect = 1.0f;
        camera.transform.rotation = Quaternion.identity;

        for (int camOrientation = 0; camOrientation &lt; eulerAngles.Length; camOrientation++)
        {
            string imageName = Path.Combine(imageDirectory, cubemap.name + "_" + cubemapImage[camOrientation] + ".png");
            camera.transform.eulerAngles = eulerAngles[camOrientation];
            RenderTexture renderTex = new RenderTexture(cubemap.height, cubemap.height, cameraDepth);
            camera.targetTexture = renderTex;
            camera.Render();
            RenderTexture.active = renderTex;
            Texture2D img = new Texture2D(cubemap.height, cubemap.height, TextureFormat.RGB24, false);
            img.ReadPixels(new Rect(0, 0, cubemap.height, cubemap.height), 0, 0);
            RenderTexture.active = null;
            DestroyImmediate(renderTex);
            byte[] imgBytes = img.EncodeToPNG();
            File.WriteAllBytes(imageName, imgBytes);
            AssetDatabase.ImportAsset(imageName, ImportAssetOptions.ForceUpdate);
        }
        AssetDatabase.Refresh();
    }
}
</code></pre>
<h2 id="etc"><a class="header" href="#etc">Etc</a></h2>
<ul>
<li>좋은 큐브맵
<ul>
<li>https://youtu.be/mnuKwAV-MBA?si=g-NaYv2cyln2jQes&amp;t=239</li>
<li>밝고 어둠/ 중간명도 /반사광이 충분히 포함</li>
<li>GI가 표현될 수 있는 밝음</li>
<li>태양 반대편에 빛을 받는 물체가 있어야 함</li>
</ul>
</li>
<li>라이팅셋팅
<ul>
<li>https://youtu.be/mnuKwAV-MBA?si=HZsut7AbGQ0C-OPE&amp;t=576</li>
<li>albedo 명도 벨런스 필수
<ul>
<li>팔레트준비</li>
</ul>
</li>
<li>색온도 조절이 편함
<ul>
<li>하지만, 노을질때든지 라이트가 너무 진하면
<ul>
<li>directional light색온도 대신 postprocess 색온도 활용</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>대기
<ul>
<li>https://youtu.be/mnuKwAV-MBA?si=JGrQpz3kCFf7M3i1&amp;t=747</li>
<li>atmospheric fog - 하늘,대기</li>
<li>exponential</li>
</ul>
</li>
</ul>
<h2 id="ref-4"><a class="header" href="#ref-4">Ref</a></h2>
<ul>
<li><a href="https://developer.arm.com/documentation/102179/0100/Implement-reflections-with-a-local-cubemap">https://developer.arm.com/documentation/102179/0100/Implement-reflections-with-a-local-cubemap</a></li>
<li><a href="https://www.slideshare.net/honestee/choi-jihyun-ndc2011">NDC2011 - PRT(Precomputed Radiance Transfer) 및 SH(Spherical Harmonics) 개괄</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stencil"><a class="header" href="#stencil">Stencil</a></h1>
<ul>
<li>vert &gt; Depth Test  &gt; Stencil Test &gt; Render</li>
<li>frag &gt; AlphaTest &gt; Blending</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>ZTest</td><td>깊이 버퍼 비교 후 색상 입히기</td><td>기본값 LEqual이기에 카메라 가까운걸 나중에 그림</td></tr>
<tr><td>ZWrite</td><td>깊이 버퍼에 쓰기 시도</td><td>ZTest 성공해야 깊이 버퍼에 쓸 수 있음</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th>ZWrite On</th><th>ZWrite Off</th></tr></thead><tbody>
<tr><td>ZTest 성공</td><td>깊이 O / 색상 O</td><td>깊이 X / 색상 O</td></tr>
<tr><td>ZTest 실패</td><td>깊이 X / 색상 X</td><td>깊이 X / 색상 X</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>ZTest 예</th><th></th></tr></thead><tbody>
<tr><td>ZTest LEqual</td><td>물체가 앞에 있다</td></tr>
<tr><td>ZTest Greater</td><td>물체가 가려져 있다</td></tr>
</tbody></table>
</div>
<h2 id="템플릿"><a class="header" href="#템플릿">템플릿</a></h2>
<pre><code class="language-hlsl">// 기본값
Pass
{
    Stencil
    { 
        Ref         0      // [0 ... 255]
        ReadMask    255    // [0 ... 255]
        WriteMask   255    // [0 ... 255]
        Comp        Always
        Pass        Keep
        Fail        Keep
        ZFail       Keep
    }
    ZWrite On              // On | Off
    ZTest LEqual           // Less | Greater | LEqual | GEqual | Equal | NotEqual | Always
}
</code></pre>
<pre><code class="language-hlsl">Properties
{
    [IntRange]
    _StencilRef("Stencil ID [0-255]",      Range(0, 255)) = 0
    
    [IntRange]
    _StencilReadMask("ReadMask [0-255]",   Range(0, 255)) = 255
    
    [IntRange]
    _StencilWriteMask("WriteMask [0-255]", Range(0, 255)) = 255

    [Enum(UnityEngine.Rendering.CompareFunction)]
    _StencilComp("Stencil Comparison",     Float) = 8 // Always

    [Enum(UnityEngine.Rendering.StencilOp)]
    _StencilPass("Stencil Pass",           Float) = 0 // Keep

    [Enum(UnityEngine.Rendering.StencilOp)]
    _StencilFail("Stencil Fail",           Float) = 0 // Keep

    [Enum(UnityEngine.Rendering.StencilOp)]
    _StencilZFail("Stencil ZFail",         Float) = 0 // Keep
}

Pass
{
    Stencil
    { 
        Ref         [_StencilRef]
        ReadMask    [_StencilReadMask]
        WriteMask   [_StencilWriteMask]
        Comp        [_StencilComp]
        Pass        [_StencilPass]
        Fail        [_StencilFail]
        ZFail       [_StencilZFail]
    }
}
</code></pre>
<h2 id="table"><a class="header" href="#table">table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>구분</th><th>기본값</th><th></th></tr></thead><tbody>
<tr><td>Ref</td><td>-</td><td>버퍼에 기록</td></tr>
<tr><td>ReadMask</td><td>255</td><td></td></tr>
<tr><td>WriteMask</td><td>255</td><td></td></tr>
<tr><td>Comp</td><td>Always</td><td></td></tr>
<tr><td>Pass</td><td>Keep</td><td>스텐실 테스트 성공시</td></tr>
<tr><td>Fail</td><td>Keep</td><td>스텐실 테스트 실패시</td></tr>
<tr><td>ZFail</td><td>Keep</td><td>스텐실 테스트 성공시 &amp;&amp; ZTest 실패시</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Comp</th><th></th><th>값</th></tr></thead><tbody>
<tr><td>Never</td><td>false</td><td>1</td></tr>
<tr><td>Less</td><td>버퍼 &gt;  참조</td><td>2</td></tr>
<tr><td>Equal</td><td>버퍼 == 참조</td><td>3</td></tr>
<tr><td>LEqual</td><td>버퍼 &gt;= 참조</td><td>4</td></tr>
<tr><td>Greater</td><td>버퍼 &lt;  참조</td><td>5</td></tr>
<tr><td>NotEqual</td><td>버퍼 != 참조</td><td>6</td></tr>
<tr><td>GEqual</td><td>버퍼 &lt;= 참조</td><td>7</td></tr>
<tr><td>Always</td><td>true</td><td>8</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>스텐실</th><th></th><th>값</th></tr></thead><tbody>
<tr><td>Keep</td><td>변화 없음</td><td>0</td></tr>
<tr><td>Zero</td><td>0</td><td>1</td></tr>
<tr><td>Replace</td><td>참조 값</td><td>2</td></tr>
<tr><td>IncrSat</td><td>증가. 최대 255</td><td>3</td></tr>
<tr><td>DecrSat</td><td>감소. 최소 0</td><td>4</td></tr>
<tr><td>Invert</td><td>반전</td><td>5</td></tr>
<tr><td>IncrWarp</td><td>증가. 255면 0으로</td><td>6</td></tr>
<tr><td>DecrWarp</td><td>감소. 0이면 255로</td><td>7</td></tr>
</tbody></table>
</div>
<h2 id="ex"><a class="header" href="#ex">Ex</a></h2>
<h3 id="마스킹"><a class="header" href="#마스킹">마스킹</a></h3>
<ul>
<li>ZTest 실패: 깊이 X / 색상 X</li>
</ul>
<pre><code class="language-hlsl">// 마스크.
// 일부러 비교(Comp)하지 않아서 실패상태로 만들고(Fail) Ref값을 덮어씌운다(Replace).
// 마스킹 작업이 오브젝트 보다 먼저 렌더링 되어야 함으로, 렌더큐 확인.
Stencil
{
    Ref     1
    Comp    Never
    Fail    Replace
}
</code></pre>
<pre><code class="language-hlsl">// 오브젝트.
// 앞서 마스크가 1로 덮어씌운 부분과 같은지 비교(Equal).
// 마스킹 작업이 오브젝트 보다 먼저 렌더링 되어야 함으로, 렌더큐 확인.
Stencil
{ 
    Ref     1
    Comp    Equal
}
</code></pre>
<h3 id="실루엣"><a class="header" href="#실루엣">실루엣</a></h3>
<ul>
<li>가려져 있는 물체 그리기
<ul>
<li>
<ol>
<li>일반</li>
</ol>
<ul>
<li>스텐실 버퍼 Write</li>
</ul>
</li>
<li>
<ol start="2">
<li>가려지면</li>
</ol>
<ul>
<li>가려져있는가 : ZTest Greater</li>
<li>스텐실 버퍼 비교</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">Pass
{
    Tags
    {
        "LightMode" = "SRPDefaultUnlit"
    }
    
    ZTest Greater
    ZWrite Off

    Stencil
    {
        Ref 2
        Comp NotEqual
    }
}

Pass
{
    Tags
    {
        "LightMode" = "UniversalForward"
    }

    Stencil
    {
        Ref 2
        Pass Replace
    }
}
</code></pre>
<h2 id="ref-5"><a class="header" href="#ref-5">Ref</a></h2>
<ul>
<li><a href="https://docs.unity3d.com/Manual/SL-CullAndDepth.html">https://docs.unity3d.com/Manual/SL-CullAndDepth.html</a></li>
<li><a href="https://docs.unity3d.com/Manual/SL-Stencil.html">https://docs.unity3d.com/Manual/SL-Stencil.html</a></li>
<li><a href="https://www.ronja-tutorials.com/post/022-stencil-buffers/">https://www.ronja-tutorials.com/post/022-stencil-buffers/</a></li>
<li><a href="https://rito15.github.io/posts/unity-transparent-stencil/#%EC%8A%A4%ED%85%90%EC%8B%A4">https://rito15.github.io/posts/unity-transparent-stencil/#스텐실</a></li>
<li><a href="https://chulin28ho.tistory.com/567">유니티 URP 멀티 렌더 오브젝트 기법으로 겹쳐진면 투명화하기</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="depth"><a class="header" href="#depth">Depth</a></h1>
<ul>
<li>LinearEyeDepth : distance from the eye in world units</li>
<li>Linear01Depth : distance from the eye in [0;1]</li>
</ul>
<pre><code class="language-hlsl">#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"
half3 pd            = IN.positionNDC.xyz / IN.positionNDC.w; // perspectiveDivide
half2 uv_Screen     = pd.xy;

half  sceneRawDepth = SampleSceneDepth(uv_Screen);
half  sceneEyeDepth = LinearEyeDepth(sceneRawDepth, _ZBufferParams);
half  scene01Depth  = Linear01Depth (sceneRawDepth, _ZBufferParams);
</code></pre>
<ul>
<li><a href="https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl">SampleSceneDepth</a></li>
<li><a href="https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl">Linear01Depth / LinearEyeDepth</a></li>
</ul>
<pre><code class="language-hlsl">// mirror: com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl
float SampleSceneDepth(float2 uv)
{
    return SAMPLE_TEXTURE2D_X(_CameraDepthTexture, sampler_CameraDepthTexture, UnityStereoTransformScreenSpaceTex(uv)).r;
}

// mirror: com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl
// Z buffer to linear 0..1 depth (0 at camera position, 1 at far plane).
// Does NOT work with orthographic projections.
// Does NOT correctly handle oblique view frustums.
// zBufferParam = { (f-n)/n, 1, (f-n)/n*f, 1/f }
float Linear01Depth(float depth, float4 zBufferParam)
{
    return 1.0 / (zBufferParam.x * depth + zBufferParam.y);
}

// Z buffer to linear depth.
// Does NOT correctly handle oblique view frustums.
// Does NOT work with orthographic projection.
// zBufferParam = { (f-n)/n, 1, (f-n)/n*f, 1/f }
float LinearEyeDepth(float depth, float4 zBufferParam)
{
    return 1.0 / (zBufferParam.z * depth + zBufferParam.w);
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th><a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">_ZBufferParams</a></th><th>x</th><th>y</th><th>z</th><th>w</th></tr></thead><tbody>
<tr><td>DirectX</td><td>-1 + far/near</td><td>1</td><td>x/far</td><td>1/far</td></tr>
<tr><td>OpenGL</td><td>1 - far/near</td><td>far/near</td><td>x/far</td><td>y/far</td></tr>
</tbody></table>
</div>
<p><img src="Basic/../res/EyeDepth.png" alt="./res/EyeDepth.png" /></p>
<h2 id="depth-buffer-value-non-linear-in-view-space"><a class="header" href="#depth-buffer-value-non-linear-in-view-space">depth buffer value non-linear (in view space)</a></h2>
<p><img src="Basic/../res/DepthComparison.png" alt="./res/DepthComparison.png" /></p>
<h2 id="sample"><a class="header" href="#sample">Sample</a></h2>
<pre><code class="language-hlsl">// vert
float currEyeDepth = -positionVS.z;
float curr01Depth = -positionVS.z * _ProjectionParams.w;
float4 positionNDC = GetVertexPositionInputs(positionOS).positionNDC;

// frag
half2 uv_Screen = IN.positionNDC.xy / IN.positionNDC.w;
half sceneRawDepth = SampleSceneDepth(uv_Screen);

// --------------------------------------------
half scene01Depth = Linear01Depth(sceneRawDepth, _ZBufferParams);   //  [near/far, 1]

// -----------------------------------------------
// scene01Depth을 _ProjectionParams.z(far plane)으로 늘리면 sceneEyeDepth
half sceneEyeDepth = scene01Depth * _ProjectionParams.z;            //  [near, far]
half sceneEyeDepth = LinearEyeDepth(sceneRawDepth, _ZBufferParams); //  [near, far]

// -----------------------------------------------
// 물체와의 거리를 빼면, 얼마나 앞에 나와있는지 알 수 있다.
half diffEyeDepth = sceneEyeDepth - IN.currEyeDepth;
half intersectGradient = 1 - min(diffEyeDepth, 1.0f);
</code></pre>
<h2 id="reversed-z"><a class="header" href="#reversed-z">Reversed-z</a></h2>
<p>TODO</p>
<ul>
<li><a href="https://developer.nvidia.com/content/depth-precision-visualized">https://developer.nvidia.com/content/depth-precision-visualized</a></li>
</ul>
<h2 id="reconstructpositionws"><a class="header" href="#reconstructpositionws">ReconstructPositionWS</a></h2>
<p>TODO 둘 중 하나 문제있음</p>
<pre><code class="language-hlsl">// https://www.cyanilux.com/tutorials/depth

OUT.toViewVectorWS = _WorldSpaceCameraPos - vertexInputs.positionWS;

float2 screenUV = (IN.positionNDC.xy / IN.positionNDC.w);

float sceneRawDepth = SampleSceneDepth(screenUV);
float sceneEyeDepth = LinearEyeDepth(sceneRawDepth, _ZBufferParams);

float fragmentEyeDepth = -IN.positionVS.z;
float3 scenePositionWS = _WorldSpaceCameraPos + (-IN.toViewVectorWS / fragmentEyeDepth) * sceneEyeDepth;
</code></pre>
<pre><code class="language-hlsl">// https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/writing-shaders-urp-reconstruct-world-position.html
float2 screenUV = IN.positionCS.xy / _ScaledScreenParams.xy;

// Sample the depth from the Camera depth texture.
#if UNITY_REVERSED_Z
    real sceneRawDepth = SampleSceneDepth(screenUV);
#else
    // Adjust Z to match NDC for OpenGL ([-1, 1])
    real sceneRawDepth = lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(screenUV));
#endif

// Reconstruct the world space positions.
float3 scenePositionWS = ComputeWorldSpacePosition(screenUV, sceneRawDepth, UNITY_MATRIX_I_VP);


// https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl
float3 ComputeWorldSpacePosition(float2 positionNDC, float deviceDepth, float4x4 invViewProjMatrix)
{
    float4 positionCS  = ComputeClipSpacePosition(positionNDC, deviceDepth);
    float4 hpositionWS = mul(invViewProjMatrix, positionCS);
    return hpositionWS.xyz / hpositionWS.w;
}

float4 ComputeClipSpacePosition(float3 position, float4x4 clipSpaceTransform = k_identity4x4)
{
    return mul(clipSpaceTransform, float4(position, 1.0));
}
</code></pre>
<h2 id="reconstructnormalvs"><a class="header" href="#reconstructnormalvs">ReconstructNormalVS</a></h2>
<ul>
<li><a href="https://wickedengine.net/2019/09/22/improved-normal-reconstruction-from-depth/">https://wickedengine.net/2019/09/22/improved-normal-reconstruction-from-depth/</a></li>
<li><a href="https://gist.github.com/bgolus/a07ed65602c009d5e2f753826e8078a0">https://gist.github.com/bgolus/a07ed65602c009d5e2f753826e8078a0</a></li>
</ul>
<pre><code class="language-hlsl">// 3 tap
const float2 offset_u = float2(0, _CameraDepthTexture_TexelSize.y); // up
const float2 offset_r = float2(_CameraDepthTexture_TexelSize.x, 0); // right

float depth_c = LinearEyeDepth(SampleSceneDepth(IN.uv           ), _ZBufferParams);  // center
float depth_u = LinearEyeDepth(SampleSceneDepth(IN.uv + offset_u), _ZBufferParams);  // up
float depth_r = LinearEyeDepth(SampleSceneDepth(IN.uv + offset_r), _ZBufferParams);  // right

float3 diff_h = float3(offset_u, depth_u - depth_c);  // horizontal
float3 diff_v = float3(offset_r, depth_r - depth_c);  // vertical

float3 normalVS = normalize(cross(diff_h, diff_v));
</code></pre>
<h2 id="ref-6"><a class="header" href="#ref-6">Ref</a></h2>
<ul>
<li><a href="https://www.cyanilux.com/tutorials/depth/">https://www.cyanilux.com/tutorials/depth/</a></li>
<li><a href="https://beta.unity3d.com/talks/Siggraph2011_SpecialEffectsWithDepth_WithNotes.pdf">https://beta.unity3d.com/talks/Siggraph2011_SpecialEffectsWithDepth_WithNotes.pdf</a></li>
<li><a href="https://www.reedbeta.com/blog/depth-precision-visualized/">https://www.reedbeta.com/blog/depth-precision-visualized/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lighitng-model"><a class="header" href="#lighitng-model">Lighitng Model</a></h1>
<ul>
<li><a href="https://www.jordanstevenstechart.com/lighting-models">https://www.jordanstevenstechart.com/lighting-models</a></li>
<li>년도를 보면서 발전상황과 왜 쓰는지 왜 안쓰는지 확인필요.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lighitng-model---npr"><a class="header" href="#lighitng-model---npr">Lighitng Model - NPR</a></h1>
<p>비 물리기반</p>
<h3 id="lambert---람버트"><a class="header" href="#lambert---람버트">Lambert - 람버트</a></h3>
<ul>
<li>Johann Heinrich Lambert</li>
<li>1760 - Photometria</li>
</ul>
<pre><code class="language-hlsl">half NdotL = max(0.0, dot(N, L));
half diffuse = NdotL;
</code></pre>
<h3 id="minnaert---미네르트"><a class="header" href="#minnaert---미네르트">Minnaert - 미네르트</a></h3>
<ul>
<li>
<p>1954 - Marcel Minnaert</p>
</li>
<li>
<p>달표면 반사를 표현하기 위해 고안됨. moon shader라 불리기도 함</p>
</li>
<li>
<p><a href="https://blog.naver.com/canny708/221551395976">https://blog.naver.com/canny708/221551395976</a></p>
</li>
</ul>
<pre><code class="language-hlsl">half NdotL = max(0.0, dot(N, L));
half NdotV = max(0.0, dot(N, V));
half diffuse = NdotL * pow(NdotL * NdotV, _MinnaertDarkness);
</code></pre>
<h3 id="phong---퐁"><a class="header" href="#phong---퐁">Phong - 퐁</a></h3>
<ul>
<li>1973 - Bui Tuong Phong</li>
</ul>
<pre><code class="language-hlsl">half3 R = reflect(-L, N);
half RdotV = max(0.0f, dot(R, V));
half specular = pow(RdotV, _SpecularPower) * _SpecularNormFactor;
</code></pre>
<h3 id="blinn-phong---블린-퐁"><a class="header" href="#blinn-phong---블린-퐁">Blinn Phong - 블린 퐁</a></h3>
<ul>
<li>1977 - Jim Blinn</li>
</ul>
<pre><code class="language-hlsl">half3 H = normalize(V + L); 
half NdotH = max(0.0, dot(N, H));

half specular = pow(NdotH ,_SpecularPower) * _SpecularNormFactor;
</code></pre>
<h3 id="strauss---스트라우스"><a class="header" href="#strauss---스트라우스">Strauss - 스트라우스</a></h3>
<ul>
<li>1990 - Paul Strauss</li>
<li><a href="https://blog.naver.com/sorkelf/401550597481">https://blog.naver.com/sorkelf/401550597481</a></li>
</ul>
<h3 id="gooch---구치"><a class="header" href="#gooch---구치">Gooch - 구치</a></h3>
<ul>
<li>1998 - Gooch</li>
<li><a href="https://users.cs.northwestern.edu/~ago820/SIG98/abstract.html">SIGGRAPH1998 - A Non-Photorealistic Lighting Model For Automatic Technical Illustration</a></li>
<li><a href="https://www.gdcvault.com/play/279/Stylization-with-a-Purpose-The">GDC2008 - Stylization with a Purpose: The Illustrative World of TEAM FORTRESS 2</a></li>
<li>따뜻함과 차가움 영역을 나누어 표시</li>
</ul>
<h3 id="half-lambert--wrapped-lambert---하프-람버트--와프드-람버트"><a class="header" href="#half-lambert--wrapped-lambert---하프-람버트--와프드-람버트">Half Lambert &amp; Wrapped Lambert - 하프 람버트 &amp; 와프드 람버트</a></h3>
<ul>
<li>2004 Half-Life2 - Valve</li>
<li><a href="https://steamcdn-a.akamaihd.net/apps/valve/2006/SIGGRAPH06_Course_ShadingInValvesSourceEngine.pdf">SIGGRAPH2006 - Shading In Valve's Source Engine</a></li>
</ul>
<pre><code class="language-hlsl">// half lambert
half NdotL = max(0.0, dot(N, L));
half diffuse = pow(NdotL * 0.5 + 0.5, 2);

// wrapped lambert
half diffuse = pow(NdotL * wrapValue + (1.0 - wrapValue), 2);
half diffuse = max(0.0, (NdotL + _wrapped) / (1.0 - _wrapped));
</code></pre>
<pre><code class="language-hlsl">// ref: https://blog.naver.com/eryners/220144182154
// Harf Lambert사용시 명암 차이가 너무 없어져서 무게감이 없어보인다.
half diffuse = ​pow((dot(N, L) * 0.5) + 0.5, 4)  // Half Lambert + Pow
</code></pre>
<pre><code class="language-hlsl">half diffuse = max(0, ((dot(L, N) + warp) / (1 + wrap + wrap^2)) ^ (1 + wrap));
</code></pre>
<h2 id="lut"><a class="header" href="#lut">LUT</a></h2>
<ul>
<li>Look Up Texture : 룩업텍스쳐</li>
<li>Ramp Texture라고도 함
<ul>
<li>Ramp : 증감. 경사(gradient)</li>
</ul>
</li>
</ul>
<h3 id="lake"><a class="header" href="#lake">Lake</a></h3>
<ul>
<li>2000 - Lake</li>
<li><a href="http://www.markmark.net/npar/npar2000_lake_et_al.pdf">Stylized Rendering Techniques For Scalable Real-Time 3D Animation</a></li>
<li>룩업텍스쳐 사용
<ul>
<li>NdotL - LUT Texture(1D)</li>
</ul>
</li>
</ul>
<h3 id="barla"><a class="header" href="#barla">BARLA</a></h3>
<ul>
<li>2006 - BARLA</li>
<li><a href="https://maverick.inria.fr/Publications/2006/BTM06a/x-toon.pdf">X-Toon: An extended toon shader - Pascal Barla, Joëlle Thollot, Lee Markosian</a></li>
<li>룩업텍스쳐 사용
<ul>
<li>NdotL, Detail - LUT Texture(2D)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lighitng-model---pbr"><a class="header" href="#lighitng-model---pbr">Lighitng Model - PBR</a></h1>
<p>물리기반</p>
<h2 id="cook-torrance---쿡토렌스"><a class="header" href="#cook-torrance---쿡토렌스">Cook Torrance - 쿡토렌스</a></h2>
<ul>
<li>1982 - Robert L.Cook &amp; Kenneth E. Torrance - A Reflectance Model For Computer Graphics</li>
<li>미세면이론</li>
<li>거친표면 specular 초점</li>
</ul>
<h2 id="ward---알드"><a class="header" href="#ward---알드">Ward - 알드</a></h2>
<ul>
<li>1992 - Gregory J. Ward - Measuring and modeling anisotropic reflection</li>
<li>경험적 데이터 기반, 거의 사용되지 않음.</li>
</ul>
<h2 id="oren-nayar---오렌네이어"><a class="header" href="#oren-nayar---오렌네이어">Oren-Nayar - 오렌네이어</a></h2>
<ul>
<li>1994 - Michael Oren &amp; Shree K. Nayar - Generalization of Lambert’s Reflectance Model</li>
<li>거친포면 diffuse 초점</li>
</ul>
<pre><code class="language-hlsl">half NdotL = max(0.0, dot(N, L));
half NdotV = max(0.0, dot(N, V));
half VdotL = max(0.0, dot(V, L));

half s = VdotL - NdotL * NdotV;
half t = lerp(1.0, max(NdotL, NdotV), step(0.0, s));

half3 A = 1.0 + _OrenNayarAlbedo * (_OrenNayarAlbedo / (_OrenNayarSigma + 0.13) + 0.5 / (_OrenNayarSigma + 0.33));
half3 B = 0.45 * _OrenNayarSigma / (_OrenNayarSigma + 0.09);

half3 diffuse = _OrenNayarAlbedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159265;
</code></pre>
<h2 id="modified-phong---모디파이드-퐁"><a class="header" href="#modified-phong---모디파이드-퐁">Modified Phong - 모디파이드 퐁</a></h2>
<ul>
<li>Lafortune and Willems (1994)</li>
</ul>
<pre><code class="language-hlsl">half norm = (shininess + 2.0) / (2.0 * PI);

half3 R = reflect(-L, N);
half3 VdotR = max(0.0, dot(V, R));

half3 specular = norm * pow(VdotR, shininess);
</code></pre>
<h2 id="ashikhmin-shirley---어크먼-셜리"><a class="header" href="#ashikhmin-shirley---어크먼-셜리">Ashikhmin Shirley - 어크먼 셜리</a></h2>
<ul>
<li>2000 - Michael Ashikhmin &amp; Peter Shirley - An Anisotropic Phong BRDF Model</li>
<li>퐁 스펙큘러</li>
</ul>
<h2 id="fakey-oren-nayar----최적화-오렌네이어"><a class="header" href="#fakey-oren-nayar----최적화-오렌네이어">Fakey Oren-Nayar -  최적화 오렌네이어</a></h2>
<ul>
<li>2011 - <a href="https://www.slideshare.net/blindrenderer/rendering-tech-of-space-marinekgc-2011">pope - Rendering Tech of Space Marine</a>
<ul>
<li><a href="https://kblog.popekim.com/2011/11/blog-post_16.html">https://kblog.popekim.com/2011/11/blog-post_16.html</a></li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">half OrenNayar_Fakey(half3 N, half3 L, half3 V, half roughness)
{
    half LdotN = dot(L, N);
    half VdotN = dot(V, N);

    half result = saturate(LdotN);
    half soft_rim = saturate(1 - VdotN / 2);

    const half FAKEY_MAGIC = 0.62;
    half fakey = pow(1 - result * soft_rim, 2);
    fakey = FAKEY_MAGIC - fakey * FAKEY_MAGIC;
    return lerp(result, fakey, roughness);
}
</code></pre>
<h2 id="disney---디즈니"><a class="header" href="#disney---디즈니">Disney - 디즈니</a></h2>
<ul>
<li>SIGGRAPH 2012 - Brent Burley - Physically Based Shading at Disney</li>
<li>여러 파라미터</li>
</ul>
<h2 id="ref-7"><a class="header" href="#ref-7">Ref</a></h2>
<ul>
<li><a href="https://www.cnblogs.com/timlly/p/10631718.html">https://www.cnblogs.com/timlly/p/10631718.html</a></li>
<li><a href="https://www.jordanstevenstechart.com/physically-based-rendering">https://www.jordanstevenstechart.com/physically-based-rendering</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hemispherelight"><a class="header" href="#hemispherelight">HemisphereLight</a></h1>
<p><img src="Lighting/../res/HemisphereLighting.png" alt="HemisphereLighting.png" /></p>
<pre><code class="language-txt">if (degree &lt;= 90)
    x = 1 - (0.5 * sin(degree));
else
    x = 0.5 * sin(degree);

RealColor = x * TopColor + (1 - a) * BottomColor;
=================================================

// 비교적 편차가 적은 간소화 버전으로 변경가능.
x = 0.5 + (0.5 * cos(degree));
// - 분기가 없어졌다.
// - cos(degree)는 dot 연산으로 대처가능
// x = 0.5 + (0.5 * dot(N, L));

FakeColor = x * TopColor + (1 - a) * BottomColor;
</code></pre>
<p><img src="Lighting/../res/HemisphereFakery.png" alt="HemisphereFakery.png" /></p>
<pre><code class="language-hlsl">half hemiWeight = 0.5 + 0.5 * dot(N, L);
half3 diffuse = lerp(_GroundColor, _SkyColor, hemiWeight);

half3 camPositionWS = GetCurrentViewPosition();
half3 L_VS = GetWorldSpaceViewDir(L);
half skyWeight = 0.5f + 0.5 * max(0, dot(N, normalize(camPositionWS + L_VS)));
half groundWeight = 0.5f + 0.5 * max(0, dot(N, normalize(camPositionWS - L_VS)));
half3 specular = (max(0, pow(skyWeight, _SpecularPower)) + max(0, pow(skyWeight, _SpecularPower)))
    *_SpecularNormFactor
    * hemiWeight
    * diffuse;
half3 result = diffuse + specular;
</code></pre>
<h2 id="ref-8"><a class="header" href="#ref-8">Ref</a></h2>
<ul>
<li><a href="https://github.com/hughsk/glsl-hemisphere-light">https://github.com/hughsk/glsl-hemisphere-light</a></li>
<li><a href="https://emunix.emich.edu/~mevett/GraphicsCourse/Labs/MattsLab5Lighting/index.html#Hemisphere">https://emunix.emich.edu/~mevett/GraphicsCourse/Labs/MattsLab5Lighting/index.html#Hemisphere</a></li>
<li><a href="https://en.wikibooks.org/wiki/GLSL_Programming/Unity/Diffuse_Reflection_of_Skylight">https://en.wikibooks.org/wiki/GLSL_Programming/Unity/Diffuse_Reflection_of_Skylight</a></li>
<li><a href="https://www.youtube.com/watch?v=l7k32_BvkWA">Hemisphere Lights - Interactive 3D Graphics</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hair-anisotropic"><a class="header" href="#hair-anisotropic">Hair Anisotropic</a></h1>
<pre><code class="language-txt">비등방성(非等方性)(anisotropy)은 방향에 따라 물체의 물리적 성질이 다른 것을 말한다. 
예를 들어, 솔질이 된 알루미늄, 섬유, 옷감, 근육 등의 표면은
들어오는 빛의 방향에 따라 반사율이 다른 광학적 비등방성을 띈다. 
- https://ko.wikipedia.org/wiki/비등방성
</code></pre>
<ul>
<li>Kajya-Kay 모델                            - SIGGRAPH 1989
<ul>
<li>짧은머리는 괜춘. 빛의 산란효과는 별로</li>
</ul>
</li>
<li>Steve Marschner 모델                      - SIGGRAPH 2003
<ul>
<li>빛의 산란효과 개선(반사/내부산란/투과)</li>
</ul>
</li>
<li>Scheuermann - Hair Rendering and Shading  - GDC 2004</li>
</ul>
<p><img src="Lighting/../res/ephere-kajiya.jpg" alt="ephere-kajiya" /></p>
<p><img src="Lighting/../res/ephere-marschner.jpg" alt="ephere-marschner" /></p>
<ul>
<li><a href="https://youtu.be/ZpWsinhPFLM?t=1285">【Unite Tokyo 2018】『崩壊3rd』開発者が語るアニメ風レンダリングの極意</a></li>
<li><a href="https://graphics.pixar.com/library/DataDrivenHairScattering/">https://graphics.pixar.com/library/DataDrivenHairScattering/</a></li>
</ul>
<h2 id="kajiya-kay"><a class="header" href="#kajiya-kay">Kajiya-Kay</a></h2>
<ul>
<li>
<p>SIGGRAPH 1989</p>
</li>
<li>
<p><a href="https://blog.naver.com/sorkelf/40185948507">blog - Hair Rendering Lighting Model - (Kajiya-Kay)</a></p>
</li>
</ul>
<p><img src="Lighting/../res/NTBFromUVs.png" alt="../res/NTBFromUVs.png" /></p>
<pre><code class="language-hlsl">// Sphere
// T | r | 오른쪽
// B | g | 위쪽
// N | b | 직각

// 논문에서 T. 방향은 머리를향한 위쪽 방향.
// half3 T = normalize(IN.T);

// Sphere에서는 B가 위쪽이므로 B로해야 원하는 방향이 나온다.
half3 T = normalize(IN.B);

half sinTH    = sqrt(1 - dot(T, H) * dot(T, H));
half specular = pow(sinTH, specularPower);
</code></pre>
<h2 id="marschner"><a class="header" href="#marschner">Marschner</a></h2>
<ul>
<li>SIGGRAPH 2003</li>
<li><a href="https://blog.naver.com/sorkelf/40186644136">blog - Hair Rendering Lighting Model - (Marschner)</a></li>
<li><a href="Lighting/www.cs.cornell.edu/~srm/publications/SG03-hair.pdf">pdf - Light Scattering from Human Hair Fibers - Stephen R. Marschner, Henrik Wann Jensen, Mike Cammarano</a></li>
<li><a href="https://youtu.be/ufNYLgE2WGA?t=1952">2020 - Dev Weeks: A3 Still Alive - Technical Art Review</a></li>
</ul>
<p><img src="Lighting/../res/Marschner.png" alt="Marschner.png" /></p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>R</td><td>반사</td></tr>
<tr><td>TRT</td><td>산란</td></tr>
<tr><td>TT</td><td>투과</td></tr>
</tbody></table>
</div>
<ul>
<li>2개의 반사를 이용.
<ul>
<li>Tangent를 이동 (+ TangentShiftTex)</li>
<li>1번째 반사(RR)</li>
<li>두번째반사(TRT) (+ SpecularMaskTex)</li>
</ul>
</li>
</ul>
<h2 id="scheuermann"><a class="header" href="#scheuermann">Scheuermann</a></h2>
<ul>
<li>GDC 2004 Hair Rendering and Shading</li>
<li>Kajiya-Kay랑 Marschner를 믹스함</li>
</ul>
<h2 id="에니메이션"><a class="header" href="#에니메이션">에니메이션</a></h2>
<ul>
<li><a href="https://www.slideshare.net/jalnaga/ss-61522038">버텍스 셰이더로 하는 머리카락 애니메이션</a></li>
</ul>
<h2 id="ref-9"><a class="header" href="#ref-9">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/WolfgangEngel/hair-intombraider-final">Hair in Tomb Raider</a></li>
<li>ShaderX3 Advanced Rendering with DirectX and OpenGL
<ul>
<li>2.14 Hair Rendering and Shading</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brdf"><a class="header" href="#brdf">BRDF</a></h1>
<ul>
<li>Bidirectional reflectance distribution function</li>
</ul>
<h2 id="brdf-texture"><a class="header" href="#brdf-texture">BRDF Texture</a></h2>
<ul>
<li>BRDF Fake라고도 함.</li>
</ul>
<p><img src="Lighting/../res/BRDF_dir.jpg" alt="BRDF_dir.jpg" /></p>
<pre><code class="language-hlsl">half u = dot(L, N) * 0.5 + 0.5;
half v = dot(V, N);

half3 brdfTex = SAMPLE_TEXTURE2D(_BrdfTex, sampler_BrdfTex, half2(u, v)).rgb;
</code></pre>
<h2 id="todo---ambient-brdf"><a class="header" href="#todo---ambient-brdf">TODO - Ambient BRDF</a></h2>
<ul>
<li>Gotanda 2010</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>x</td><td>dot(V, N)</td></tr>
<tr><td>y</td><td>Shininess</td></tr>
</tbody></table>
</div>
<h2 id="todo---environment-ibl-map"><a class="header" href="#todo---environment-ibl-map">TODO - Environment IBL Map</a></h2>
<ul>
<li>Schlick's approximation // fresnel</li>
<li>Lazarov 2013</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>x</td><td>dot(V, N) // cosθv</td></tr>
<tr><td>y</td><td>Roughness</td></tr>
</tbody></table>
</div>
<h2 id="dfg-lut"><a class="header" href="#dfg-lut">DFG LUT</a></h2>
<div class="table-wrapper"><table><thead><tr><th>DFG</th><th></th></tr></thead><tbody>
<tr><td>D</td><td>Distrubution</td></tr>
<tr><td>F</td><td>Fresnel</td></tr>
<tr><td>G</td><td>Geometry</td></tr>
</tbody></table>
</div>
<h2 id="예"><a class="header" href="#예">예</a></h2>
<pre><code class="language-cs">Color c = diffuse * intensity + fresnelReflectionColor * fresnelTerm + translucentColor * t + Color(0, 0 ,0, specular);
c *= intensity;
</code></pre>
<pre><code class="language-hlsl">half u = dot(L, N) * 0.5 + 0.5;
half v = dot(H, N);

half3 brdfTex = SAMPLE_TEXTURE2D(_BrdfTex, sampler_BrdfTex, half2(u, v)).rgb;
half3 color = albedo * (brdfTex.rgb + gloss * brdfTex.a) * 2;
</code></pre>
<pre><code class="language-hlsl">//   +--- B ---+    A : 빛과 마주치는 면
//   |         |    B : 빛과 반대방향의 면
//   D         C    C : 카메라와 마주치는 면
//   |         |    D : 카메라와 90도 되는 면
//   +--- A ---+ 

OffsetU // [-1, 1]
OffsetV // [-1, 1]

half2 brdfUV = float2(saturate(NdotV + OffsetU), saturate((LdotN + 1) * 0.5) + OffsetV);
brdfUV.y = 1 - brdfUV.y;
half3 brdfTex = tex2D(BRDFSampler, brdfUV).rgb;

half3 color = ambient + brdfTex;

</code></pre>
<h2 id="ref-10"><a class="header" href="#ref-10">Ref</a></h2>
<ul>
<li>SIGGRAH 2013 Real Shading in Unreal Engine 4
<ul>
<li><a href="https://lifeisforu.tistory.com/348">https://lifeisforu.tistory.com/348</a></li>
</ul>
</li>
<li><a href="https://learnopengl.com/PBR/IBL/Specular-IBL">https://learnopengl.com/PBR/IBL/Specular-IBL</a></li>
<li><a href="https://advances.realtimerendering.com/s2019/A%20Journey%20Through%20Implementing%20Multiscattering%20BRDFs%20and%20Area%20Lights.pptx">SIGGRAH2019 - A Journey Through Implementing Multiscattering BRDFs and Area Lights</a></li>
<li><a href="https://teodutra.com/unity/shaders/cook-torrance/lookup-texture/2019/03/28/Lookup-The-Cook-Torrance/">https://teodutra.com/unity/shaders/cook-torrance/lookup-texture/2019/03/28/Lookup-The-Cook-Torrance/</a></li>
<li><a href="http://openproblems.realtimerendering.com/s2017/index.html">SIGGRAH2017 - Physically-Based Materials: Where Are We?</a></li>
<li><a href="https://developer.download.nvidia.com/assets/gamedev/docs/BRDFs.pdf">Multi-Textured BRDF-based Lighting - Chris Wynn</a></li>
<li><a href="http://www.mentalwarp.com/~brice/brdf.php">http://www.mentalwarp.com/~brice/brdf.php</a></li>
<li><a href="http://wiki.polycount.com/wiki/BDRF_map">http://wiki.polycount.com/wiki/BDRF_map</a></li>
<li><a href="https://youtu.be/WJHMV--CNdU?si=mzvIRGYGVlMVyQf7">Stoyan Dimitrov: How Space Ape uses Uber Shaders in Unity for Mobile Games</a>
<ul>
<li><a href="https://stoyan3d.wordpress.com/2018/11/21/uber-shaders-for-mobile-games/">https://stoyan3d.wordpress.com/2018/11/21/uber-shaders-for-mobile-games/</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pbr"><a class="header" href="#pbr">PBR</a></h1>
<ul>
<li>PBR(Physical based rendering) / PBS(Physical based shader)</li>
</ul>
<p>Energy = diffuse + specular + transmission</p>
<ul>
<li>https://renderwonk.com/publications/</li>
<li></li>
</ul>
<p><a href="https://www.slideshare.net/jalnaga/ndc13ndc-2013-udk-19999169">[Ndc13]Ndc 2013 김동석:UDK로 물리기반 셰이더 만들기</a></p>
<p>siggraph 2010
tri-Ace
Practical Implementation of Physically-Based Shading Models at tri-Ace (Yoshiharu Gotanda)
<a href="https://renderwonk.com/publications/s2010-shading-course/gotanda/slide_practical_implementation_at_triace.pdf">slide</a>
<a href="https://renderwonk.com/publications/s2010-shading-course/gotanda/course_note_practical_implementation_at_triace.pdf">cource notes</a></p>
<p>siggraph 2011
Lazarov
Physically Based Lighting in Call of Duty: Black Ops
Dimitar Lazarov, Lead Graphics Engineer, Treyarch</p>
<p>Sébastien Lagarde
Moving Frostbite to PBR (Sébastien Lagarde &amp; Charles de Rousiers)
https://blog.selfshadow.com/publications/s2014-shading-course/frostbite/s2014_pbs_frostbite_slides.pdf</p>
<ul>
<li>Etc
<ul>
<li>BSDF(Bidirectional Scattering Distribution Function)</li>
<li>BTDF(Bidirectional Transmission Distribution Function)</li>
<li>BSSRDF(Bidirectional Scattering Surface Reflectance Distribution Function)</li>
<li>SPDF(Scattering Probability Density Function)</li>
</ul>
</li>
</ul>
<h2 id="custom-pbr"><a class="header" href="#custom-pbr">Custom PBR</a></h2>
<p>TODO</p>
<ul>
<li>https://www.slideshare.net/dongminpark71/ndc19-pbr-143928930</li>
<li><a href="https://www.slideshare.net/DaeHyekKIM/4-4-special-case-materials-moss-wetness-glass">언차티드4 테크아트 파트4 Special Case Materials - Moss &amp; Wetness &amp; Glass</a></li>
<li><a href="https://www.slideshare.net/DaeHyekKIM/4-3-microshadowbrdf-term"> 언차티드4 테크아트 파트3 MicroShadowBRDF Term </a></li>
</ul>
<h2 id="ref-11"><a class="header" href="#ref-11">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/MRESC/pbr-vol2-131205432">https://www.slideshare.net/MRESC/pbr-vol2-131205432</a></li>
<li>Adobe The PBR Guide
<ul>
<li><a href="https://substance3d.adobe.com/tutorials/courses/the-pbr-guide-part-1">https://substance3d.adobe.com/tutorials/courses/the-pbr-guide-part-1</a></li>
<li><a href="https://substance3d.adobe.com/tutorials/courses/the-pbr-guide-part-2">https://substance3d.adobe.com/tutorials/courses/the-pbr-guide-part-2</a></li>
</ul>
</li>
</ul>
<p>https://leegoonz.blog/2020/01/05/energy-conserved-specular-blinn-phong/
https://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/</p>
<h2 id="재질"><a class="header" href="#재질">재질</a></h2>
<ul>
<li>https://dev.epicgames.com/documentation/en-us/unreal-engine/physically-based-materials-in-unreal-engine</li>
<li>https://creativecloud.adobe.com/learn/substance-3d-designer/web/the-pbr-guide-part-1</li>
<li>https://creativecloud.adobe.com/learn/substance-3d-designer/web/the-pbr-guide-part-2</li>
</ul>
<h2 id="custom"><a class="header" href="#custom">custom</a></h2>
<p>난반사(Diffuse Reflection)
정반사(Specluar Reflection)</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>정반사</th><th>난반사</th></tr></thead><tbody>
<tr><td>비금속</td><td>흰색</td><td>기본색</td></tr>
<tr><td>금속</td><td>기본색</td><td>흰색</td></tr>
</tbody></table>
</div>
<ul>
<li>방식
<ul>
<li>ref
<ul>
<li><a href="https://youtu.be/1biT79BtSkw">물리기반 머터리얼 상식</a>
<ul>
<li>직접광보다 간접광(Environment map)이 중요.
<ul>
<li>https://marmoset.co/shop/
<ul>
<li>Perpetual License $31900one-time fee (USD)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://youtu.be/T6-OnODMgdE">디퓨즈와 스페큘러</a>
<ul>
<li><a href="http://filmicworlds.com/blog/how-to-split-specular-and-diffuse-in-real-images/">How To Split Specular And Diffuse In Real Images</a></li>
<li>https://lifeisforu.tistory.com/382</li>
<li>https://www.virial.com/reflection-models.html</li>
</ul>
</li>
</ul>
</li>
<li>metal - roughness
<ul>
<li>base color : brdf color</li>
<li>metallic : reflectance ( specular level, Index of Refelection - 별명이 artistic metallic - 1.6)</li>
<li>roughness: glossiness를 선형화 시켜서 뒤짚은 값.
<ul>
<li>사람은 대략 0.5</li>
</ul>
</li>
</ul>
</li>
<li>specular / glossiness
<ul>
<li>diffuse(albedo (알비도)) / specular / glossiness</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>base color/metalic / roughness 방식</p>
<ul>
<li>단점
<ul>
<li>텍셀 밀도가 낮을시 metalic edge 현상 발생</li>
</ul>
</li>
<li>base color
<ul>
<li>PBR Safe Color
<ul>
<li>https://helpx.adobe.com/substance-3d-designer/substance-compositing-graphs/nodes-reference-for-substance-compositing-graphs/node  -library/material-filters/pbr-utilities/pbr-albedo-safe-color.html</li>
<li>https://helpx.adobe.com/substance-3d-designer/substance-compositing-graphs/nodes-reference-for-substance-compositing-graphs/node-library/material-filters/pbr-utilities/pbr-basecolor-metallic-validate.html</li>
</ul>
</li>
</ul>
</li>
<li>메탈릭
<ul>
<li>albedo : 밝아야함(생각보다 어둡게 나오는 경우가 많음)</li>
<li>금속/비금속을 나누는 기준임으로 어중간한 값들의 사용은 자제해야한다.</li>
</ul>
</li>
<li>거칠기 : 높을수록 정반사 비율이 낮아짐.
<ul>
<li>기울여 봐야 Fresnel의 차이를 확인 할 수 있음.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flatshader"><a class="header" href="#flatshader">FlatShader</a></h1>
<ul>
<li>노말의 앵글을 없에므로 메쉬간 평평한(Flat)효과를 얻을 수 있다.</li>
<li>속성을 변경하거나, 런타임에 변경할 수도 있다.</li>
</ul>
<h2 id="속성을-변경"><a class="header" href="#속성을-변경">속성을 변경</a></h2>
<ul>
<li>https://gamedevelopment.tutsplus.com/articles/go-beyond-retro-pixel-art-with-flat-shaded-3d-in-unity--gamedev-12259</li>
</ul>
<pre><code class="language-txt">fbx&gt; Normals &amp; Tangents &gt; Normals&gt; Calculate
fbx&gt; Normals &amp; Tangents &gt; Smoothing Angle&gt; 0
</code></pre>
<h2 id="런타임"><a class="header" href="#런타임">런타임</a></h2>
<pre><code class="language-cs">void FlatShading ()
{
    MeshFilter mf = GetComponent&lt;MeshFilter&gt;();
    Mesh mesh = Instantiate (mf.sharedMesh) as Mesh;
    mf.sharedMesh = mesh;

    Vector3[] oldVerts = mesh.vertices;
    int[] triangles = mesh.triangles;
    Vector3[] vertices = new Vector3[triangles.Length];

    for (int i = 0; i &lt; triangles.Length; i++) 
    {
        vertices[i] = oldVerts[triangles[i]];
        triangles[i] = i;
    }

    mesh.vertices = vertices;
    mesh.triangles = triangles;
    mesh.RecalculateNormals();
}
</code></pre>
<h2 id="shader"><a class="header" href="#shader">Shader</a></h2>
<ul>
<li>그게 아니면 shader를 이용해도...</li>
<li><a href="https://www.sysnet.pe.kr/2/0/11613">Unity로 실습하는 Shader (5) - Flat Shading</a></li>
<li><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading/">https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading/</a></li>
</ul>
<pre><code class="language-hlsl">half3 x = ddx(IN.positionWS);
half3 y = ddy(IN.positionWS);

half3 N = normalize(-cross(x, y));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lod"><a class="header" href="#lod">LOD</a></h1>
<ul>
<li>LOD : Level Of Detail</li>
<li><a href="https://gamedevforever.com/325">tex2Dlod와 tex2Dbias의 비교연구</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th>Level of detail (N은 0부터)</th></tr></thead><tbody>
<tr><td>tex2Dlod</td><td>SAMPLE_TEXTURE2D_LOD</td><td>N (밉맵 고정)</td></tr>
<tr><td>tex2Dbias</td><td>SAMPLE_TEXTURE2D_BIAS</td><td>현재 밉맵 + N</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>QualitySettings.lodBias</td><td>LOD가 바뀌는 거리의 비율 조절</td><td>작을 수록 LOD가 빨리 바뀐다</td></tr>
<tr><td>QualitySettings.maximumLODLevel</td><td>최대 LOD레벨 지정</td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-cs">// ref: https://www.unity3dtips.com/unity-fix-blurry-textures-on-mipmap/

UnityEditor.EditorPrefs.SetBool("DeveloperMode", true);

// 인스펙터에 Debug-Internal로 들어가서
// Texture Settings &gt; Mip Bias 부분 설정 가능
</code></pre>
<h2 id="밉맵-날카롭게-만들기"><a class="header" href="#밉맵-날카롭게-만들기">밉맵 날카롭게 만들기</a></h2>
<ul>
<li><a href="https://kblog.popekim.com/2013/06/blurrymipmap.html">밉맵 디테일 높이기</a></li>
<li>DDS로 밉맵을 따로 제작해서 만들거나</li>
<li>AssetPostprocessor를 이용해서 처리</li>
</ul>
<pre><code class="language-txt">1. 밉맵 0으로부터 밉맵 1 생성 (bilinear filter)
2. 밉맵 1에 sharpening filter 적용
3. 2번 결과물로부터 밉맵 2 생성(bilinear filter)
4. 밉맵 2에 sharpening filter 적용
5. 밉맵 끝까지 만들때까지 반복...
</code></pre>
<div class="juxtapose" data-animate="false">
  <img src="Advanced/../res/ShaderExample/MipmapsSharper_before.jpg" data-label="LOD 2" />
  <img src="Advanced/../res/ShaderExample/MipmapsSharper_after.jpg" data-label="LOD 2 - Sharppen" />
</div>
<h3 id="assetpostprocessor"><a class="header" href="#assetpostprocessor">AssetPostprocessor</a></h3>
<pre><code class="language-cs">public class MipmapsSharperImporter : AssetPostprocessor
{
    void OnPostprocessTexture(Texture2D texture)
    {
        if (!Path.GetFileNameWithoutExtension(assetPath).EndsWith("_sharppen"))
        {
            return;
        }

        if (texture.mipmapCount == 0)
        {
            return;
        }

        for (int mipmapLevel = 1; mipmapLevel &lt; texture.mipmapCount; ++mipmapLevel)
        {
            ApplyBilinearFilter(texture, mipmapLevel);
            ApplySharpeningFilter(texture, mipmapLevel);
        }
        texture.Apply(updateMipmaps: false, makeNoLongerReadable: true);
    }

    void ApplyBilinearFilter(Texture2D texture, int currMipmapLevel)
    {
        int currMipmapWidth = texture.width / (1 &lt;&lt; currMipmapLevel);
        int currMipmapHeight = texture.height / (1 &lt;&lt; currMipmapLevel);
        Color[] currPixels = new Color[currMipmapWidth * currMipmapHeight];

        int prevMipmapLevel = currMipmapLevel - 1;
        int prevMipmapWidth = texture.width / (1 &lt;&lt; prevMipmapLevel);
        Color[] prevPixels = texture.GetPixels(prevMipmapLevel);
        
        for (int y = 0; y &lt; currMipmapHeight; ++y)
        {
            for (int x = 0; x &lt; currMipmapWidth; ++x)
            {
                int px = 2 * x;
                int py = 2 * y;

                Color c00 = prevPixels[(py) * prevMipmapWidth + (px)];
                Color c10 = prevPixels[(py) * prevMipmapWidth + (px + 1)];
                Color c01 = prevPixels[(py + 1) * prevMipmapWidth + (px)];
                Color c11 = prevPixels[(py + 1) * prevMipmapWidth + (px + 1)];

                Color b0 = Color.Lerp(c00, c10, 0.5f);
                Color b1 = Color.Lerp(c01, c11, 0.5f);
                Color final = Color.Lerp(b0, b1, 0.5f);

                currPixels[y * currMipmapWidth + x] = final;
            }
        }
        texture.SetPixels(currPixels, currMipmapLevel);
    }

    private void ApplySharpeningFilter(Texture2D texture, int mipmapLevel)
    {
        float _Sharpness = 0.1f;
        Color[] pixels = texture.GetPixels(mipmapLevel);
        int mipmapWidth = texture.width / (1 &lt;&lt; mipmapLevel);
        int mipmapHeight = texture.height / (1 &lt;&lt; mipmapLevel);
        const int HALF_RANGE = 1;
        for (int y = 0; y &lt; mipmapHeight; ++y)
        {
            for (int x = 0; x &lt; mipmapWidth; ++x)
            {
                Color color = pixels[y * mipmapWidth + x];
                Color sum = Color.black;
                for (int i = -HALF_RANGE; i &lt;= HALF_RANGE; i++)
                {
                    for (int j = -HALF_RANGE; j &lt;= HALF_RANGE; j++)
                    {
                        sum += pixels[Mathf.Clamp(y + j, 0, mipmapHeight - 1) * mipmapWidth + Mathf.Clamp(x + i, 0, mipmapWidth - 1)];
                    }
                }
                Color sobel8 = color * Mathf.Pow(HALF_RANGE * 2 + 1, 2) - sum;
                Color addColor = sobel8 * _Sharpness;
                color += addColor;
                pixels[y * mipmapWidth + x] = color;
            }

        }
        texture.SetPixels(pixels, mipmapLevel);
    }
}
</code></pre>
<h2 id="hlod"><a class="header" href="#hlod">HLOD</a></h2>
<ul>
<li>HLOD : Hierarchical Level Of Detail</li>
<li><a href="https://www.slideshare.net/ssuser4635b2/unite2019-hlod">Unite2019 HLOD를 활용한 대규모 씬 제작 방법</a></li>
</ul>
<h2 id="ref-12"><a class="header" href="#ref-12">Ref</a></h2>
<ul>
<li><a href="https://docs.unity3d.com/ScriptReference/AssetPostprocessor.OnPostprocessTexture.html">https://docs.unity3d.com/ScriptReference/AssetPostprocessor.OnPostprocessTexture.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/413834301">https://zhuanlan.zhihu.com/p/413834301</a></li>
<li><a href="https://community.khronos.org/t/texture-lod-calculation-useful-for-atlasing/61475">https://community.khronos.org/t/texture-lod-calculation-useful-for-atlasing/61475</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadow"><a class="header" href="#shadow">Shadow</a></h1>
<ul>
<li>ShadowCaster패스로 그림자를 그려주고</li>
<li>메인 패스에서
<ul>
<li>shadowCoord를 얻어와
<ul>
<li>OUT.shadowCoord = TransformWorldToShadowCoord(OUT.positionWS);로</li>
</ul>
</li>
<li>라이트를 얻고
<ul>
<li>Light mainLight = GetMainLight(inputData.shadowCoord);</li>
</ul>
</li>
<li>그림자를 적용시킨다
<ul>
<li>half shadow = mainLight.shadowAttenuation;</li>
<li>finalColor.rgb *= shadow;</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">// Light &amp; Shadow
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
#pragma multi_compile _ _ADDITIONAL_LIGHTS
#pragma multi_compile _ _ADDITIONAL_LIGHTS_CASCADE
#pragma multi_compile _ _SHADOWS_SOFT

UnityEngine.Rendering.Universal.ShaderKeywordStrings
</code></pre>
<pre><code class="language-hlsl">// com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl
float4 TransformWorldToShadowCoord(float3 positionWS)
{
#ifdef _MAIN_LIGHT_SHADOWS_CASCADE
    half cascadeIndex = ComputeCascadeIndex(positionWS);
#else
    half cascadeIndex = half(0.0);
#endif
    float4 shadowCoord = mul(_MainLightWorldToShadow[cascadeIndex], float4(positionWS, 1.0));
    return float4(shadowCoord.xyz, 0);
}

OUT.shadowCoord = TransformWorldToShadowCoord(positionWS);// float4
</code></pre>
<pre><code class="language-hlsl">VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);
OUT.shadowCoord = GetShadowCoord(vertexInput);
</code></pre>
<pre><code class="language-hlsl">Light mainLight = GetMainLight(inputData.shadowCoord);
half shadow = mainLight.shadowAttenuation;
finalColor.rgb *= shadow;
</code></pre>
<p>아 유니티 병신같은 문서어딧</p>
<pre><code class="language-hlsl">// Toggle the alpha test
#define _ALPHATEST_ON

// Toggle fog on transparent
#define _ENABLE_FOG_ON_TRANSPARENT
</code></pre>
<pre><code class="language-hlsl">UsePass "Universal Render Pipeline/Lit/ShadowCaster"

com.unity.render-pipelines.universal/Shaders/ShadowCasterPass.hlsl

// You can also optionally disable shadow receiving for transparent to improve performance. To do so, disable Transparent Receive Shadows in the Forward Renderer asset
_MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN ?? =&gt; MAIN_LIGHT_CALCULATE_SHADOWS
_MAIN_LIGHT_SHADOWS_CASCADE =&gt; REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR
_ADDITIONAL_LIGHT_SHADOWS =&gt; ADDITIONAL_LIGHT_CALCULATE_SHADOWS

// cascade
// https://forum.unity.com/threads/what-does-shadows_screen-mean.568225/
// https://forum.unity.com/threads/water-shader-graph-transparency-and-shadows-universal-render-pipeline-order.748142/

PipelineAsset&gt; Shadows &gt; Cascades&gt; No Cascades
</code></pre>
<p><img src="Advanced/../res/URP/cascade.jpg" alt="../res/URP/cascade.jpg" /></p>
<pre><code class="language-hlsl">// com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl
#if !defined(_RECEIVE_SHADOWS_OFF)
    #if defined(_MAIN_LIGHT_SHADOWS) || defined(_MAIN_LIGHT_SHADOWS_CASCADE) || defined(_MAIN_LIGHT_SHADOWS_SCREEN)
        #define MAIN_LIGHT_CALCULATE_SHADOWS

        #if !defined(_MAIN_LIGHT_SHADOWS_CASCADE)
            #define REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR
        #endif
    #endif

    #if defined(_ADDITIONAL_LIGHT_SHADOWS)
        #define ADDITIONAL_LIGHT_CALCULATE_SHADOWS
    #endif
#endif

TEXTURE2D_SHADOW(_MainLightShadowmapTexture);
SAMPLER_CMP(sampler_MainLightShadowmapTexture);

half4       _MainLightShadowParams;   // (x: shadowStrength, y: 1.0 if soft shadows, 0.0 otherwise, z: main light fade scale, w: main light fade bias)
float4      _MainLightShadowmapSize;  // (xy: 1/width and 1/height, zw: width and height)

struct ShadowSamplingData
{
    half4 shadowOffset0;
    half4 shadowOffset1;
    half4 shadowOffset2;
    half4 shadowOffset3;
    float4 shadowmapSize;
};

// ShadowParams
// x: ShadowStrength
// y: 1.0 if shadow is soft, 0.0 otherwise
half4 GetMainLightShadowParams()
{
    return _MainLightShadowParams;
}

half MainLightRealtimeShadow(float4 shadowCoord)
    ShadowSamplingData shadowSamplingData = GetMainLightShadowSamplingData();
    half4 shadowParams = GetMainLightShadowParams();
    return SampleShadowmap(TEXTURE2D_ARGS(_MainLightShadowmapTexture, sampler_MainLightShadowmapTexture), shadowCoord, shadowSamplingData, shadowParams, false);

half AdditionalLightRealtimeShadow(int lightIndex, float3 positionWS, half3 lightDirection)
real SampleShadowmap(TEXTURE2D_SHADOW_PARAM(ShadowMap, sampler_ShadowMap), float4 shadowCoord, ShadowSamplingData samplingData, half4 shadowParams, bool isPerspectiveProjection = true) _SHADOWS_SOFT

PipelineAsset&gt; Shadows &gt; Cascades&gt; Soft Shadows

_SHADOWS_SOFT : real SampleShadowmapFiltered(TEXTURE2D_SHADOW_PARAM(ShadowMap, sampler_ShadowMap), float4 shadowCoord, ShadowSamplingData samplingData)
float4 TransformWorldToShadowCoord(float3 positionWS)  : _MAIN_LIGHT_SHADOWS_CASCADE
_MAIN_LIGHT_SHADOWS_CASCADE : half ComputeCascadeIndex(float3 positionWS)


float3 ApplyShadowBias(float3 positionWS, float3 normalWS, float3 lightDirection)

LerpWhiteTo
</code></pre>
<pre><code class="language-hlsl">#pragma multi_compile_fog
OUT.fogCoord = ComputeFogFactor(OUT.positonHCS.z);

half3 ambient = SampleSH(IN.N);
finalColor.rgb *= ambient;
finalColor.rgb = MixFog(finalColor.rgb, IN.fogCoord);
</code></pre>
<h2 id="shadowattenuation"><a class="header" href="#shadowattenuation">ShadowAttenuation</a></h2>
<pre><code class="language-hlsl">// URP
half4 shadowCoord = TransformWorldToShadowCoord(positionWS);
// or
// VertexPositionInputs vertexInput = GetVertexPositionInputs(IN.positionOS.xyz);
// half4 shadowCoord = GetShadowCoord(vertexInput);

half shadowAttenuation = MainLightRealtimeShadow(shadowCoord);
// or
// ShadowSamplingData shadowSamplingData = GetMainLightShadowSamplingData();
// half4 shadowParams = GetMainLightShadowParams();
// half shadowAttenuation = SampleShadowmap(TEXTURE2D_ARGS(_MainLightShadowmapTexture, sampler_MainLightShadowmapTexture), shadowCoord, shadowSamplingData, shadowParams, false);
// or
// Light mainLight = GetMainLight(i.shadowCoord);
// half shadowAttenuation = mainLight.shadowAttenuation;
</code></pre>
<h2 id="shadowcaster"><a class="header" href="#shadowcaster">ShadowCaster</a></h2>
<pre><code class="language-hlsl">// 그림자 그려주는놈
Pass
{
    Tags{"LightMode" = "ShadowCaster"}
}

vert()
{
    OUT.positionCS = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, lightDirectionWS));
}

frag()
{
    1 : lit
    0 : shadow

    return 1 or 0;
}
</code></pre>
<pre><code class="language-hlsl">Pass
{
    Name "ShadowCaster"
    Tags
    {
        "LightMode" = "ShadowCaster"
    }

    ZWrite On
    Cull Back

    HLSLPROGRAM
    #pragma target 3.5

    #pragma vertex shadowVert
    #pragma fragment shadowFrag

    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"  // real
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl" // LerpWhiteTo
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl" // ApplyShadowBias

    struct Attributes
    {
        float4 positionOS   : POSITION;
        float4 normal       : NORMAL;
    };

    struct Varyings
    {
        float4 positionHCS  : SV_POSITION;
    };

    Varyings shadowVert(Attributes IN)
    {
        Varyings OUT = (Varyings)0;

        float3 positionWS = TransformObjectToWorld(IN.positionOS.xyz);
        float3 normalWS = TransformObjectToWorldNormal(IN.normal.xyz);
        OUT.positionHCS = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _MainLightPosition.xyz));

        return OUT;
    }

    half4 shadowFrag(Varyings IN) : SV_Target
    {
        return 0;
    }
    ENDHLSL
}
</code></pre>
<pre><code class="language-hlsl">#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"  // real
#if defined(SHADER_API_MOBILE) || defined(SHADER_API_SWITCH)
#define HAS_HALF 1
#else
#define HAS_HALF 0
#endif

#if REAL_IS_HALF
#define real half
#define real2 half2
#define real3 half3
#define real4 half4

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl" // ApplyShadowBias
float3 ApplyShadowBias(float3 positionWS, float3 normalWS, float3 lightDirection)


real SampleShadowmap(TEXTURE2D_SHADOW_PARAM(ShadowMap, sampler_ShadowMap), float4 shadowCoord, ShadowSamplingData samplingData, half4 shadowParams, bool isPerspectiveProjection = true)
// 안쓰는 놈인데.. LerpWhiteTo를 들고있다..

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl" // LerpWhiteTo
real LerpWhiteTo(real b, real t)
</code></pre>
<h2 id="쉐도우맵"><a class="header" href="#쉐도우맵">쉐도우맵</a></h2>
<ol>
<li>
<p>Z-depth구하기</p>
<ol>
<li>
<p>씬 렌더링</p>
</li>
<li>
<p>Z-depth를 깊이버퍼에 저장한다(depth map)</p>
<pre><code class="language-txt">world &gt; View[Light] &gt; Proj[Light]
      Light's View Matrix &gt; Light's Projection Matrix
&gt; transform NDC
&gt; transform texture Space
</code></pre>
</li>
</ol>
</li>
<li>
<p>그림자그리기</p>
<ol>
<li>
<p>씬 렌더링</p>
</li>
<li>
<p>깊이버퍼랑 Z-depth 테스트</p>
<pre><code class="language-txt">if (fragment Z-depth &gt; sampled Z-depth)
{
    shadow : 0
}
else
{
    lit     : 1
}


</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id=""><a class="header" href="#"></a></h2>
<ul>
<li>
<p>SSSM(Screen Space Shadow Map)</p>
</li>
<li>
<p><a href="https://blog.csdn.net/linjf520/article/details/105456097">Unity Shader - Custom SSSM(Screen Space Shadow Map) 自定义屏幕空间阴影图</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/linjf520/article/details/105380551">OpenGL - 阴影映射 - Tutorial 16 : Shadow mapping</a></p>
</li>
</ul>
<h3 id="shadow-acne"><a class="header" href="#shadow-acne">Shadow Acne</a></h3>
<h2 id="depthonly"><a class="header" href="#depthonly">DepthOnly</a></h2>
<pre><code class="language-hlsl">Pass
{
    Tags
    {
        "LightMode" = "DepthOnly"
    }

    ZWrite On
    ColorMask 0

    HLSLPROGRAM
    
    ...

    half4 shadowFrag(Varyings IN) : SV_Target
    {
        return 0;
    }
    ENDHLSL
}
</code></pre>
<h2 id="meta"><a class="header" href="#meta">Meta</a></h2>
<ul>
<li>라이트맵 구울때 사용.</li>
<li>디버깅용 내부툴 만들때 유용.</li>
</ul>
<pre><code class="language-hlsl">Pass
{
    Tags
    {
        "LightMode" = "DepthOnly"
    }

    ...
}
</code></pre>
<h2 id="ref-13"><a class="header" href="#ref-13">Ref</a></h2>
<ul>
<li><a href="https://blog.naver.com/mnpshino/221844164319">URP 셰이더 코딩 튜토리얼 : 제 1편 - Unlit Soft Shadow</a></li>
<li><a href="https://illu.tistory.com/1407">URP Default Unlit Based to Custom Lighting</a></li>
<li><a href="https://www.bilibili.com/read/cv6436088/">urp管线的自学hlsl之路 第十篇 主光源阴影投射和接收</a></li>
<li><a href="https://catlikecoding.com/unity/tutorials/rendering/part-7/">builtin -  Rendering 7 Shadows</a></li>
<li><a href="https://tmdcks2368.medium.com/unity-urp-custom-shadow-shader-%EB%8F%84%EC%A0%84%ED%95%98%EA%B8%B0-%EB%AC%B8%EC%A0%9C%ED%8E%B8-1-3-e8e7f74c192a">[Unity] URP Custom Shadow Shader 도전하기 : Frame Debugger로 원인 찾기(1/3)</a>
<ul>
<li><a href="https://tmdcks2368.medium.com/unity-urp-custom-shadow-shader-%EB%8F%84%EC%A0%84%ED%95%98%EA%B8%B0-%EC%BD%94%EB%93%9C-%EB%94%B0%EB%9D%BC%EA%B0%80%EB%A9%B0-%EB%AC%B8%EC%A0%9C-%EC%9B%90%EC%9D%B8-%EC%B0%BE%EA%B8%B0-2-3-5831e340d8eb">[Unity] URP Custom Shadow Shader 도전하기 : Frame Debugger로 원인 찾기(2/3)</a></li>
<li><a href="https://tmdcks2368.medium.com/unity-urp-custom-shadow-shader-%EB%8F%84%EC%A0%84%ED%95%98%EA%B8%B0-frame-debugger%EB%A1%9C-%EC%9B%90%EC%9D%B8-%EC%B0%BE%EA%B8%B0-3-3-bae7825480d3">[Unity] URP Custom Shadow Shader 도전하기 : Frame Debugger로 원인 찾기(3/3)</a></li>
</ul>
</li>
<li><a href="https://forum.unity.com/threads/reading-a-depth-value-from-unitys-shadow-map.243092/">Reading a depth value from Unity's shadow map?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dithering"><a class="header" href="#dithering">Dithering</a></h1>
<ul>
<li>Dithering : 이미지에 Noise를 입히는 행위
<ul>
<li>이미지의 디테일을 향상 시킬 수 있음(ex 계단현상(Banding) 완화)</li>
</ul>
</li>
<li>jitter : 흐트러짐</li>
</ul>
<h2 id="ref-14"><a class="header" href="#ref-14">Ref</a></h2>
<ul>
<li><a href="https://www.ronja-tutorials.com/post/042-dithering/">https://www.ronja-tutorials.com/post/042-dithering/</a></li>
<li><a href="https://youtu.be/FMfC47xsImU?t=1190s">GDC2016 - Low Complexity, High Fidelity: The Rendering of INSIDE</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gemoetry"><a class="header" href="#gemoetry">Gemoetry</a></h1>
<ul>
<li>VS &gt; HS &gt; TS &gt; <code>GS</code> &gt; FS</li>
<li>shader model 4.0</li>
<li><a href="https://roystan.net/articles/grass-shader.html">https://roystan.net/articles/grass-shader.html</a></li>
<li><a href="https://halisavakis.com/my-take-on-shaders-geometry-shaders/">https://halisavakis.com/my-take-on-shaders-geometry-shaders/</a></li>
</ul>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-geometry-shader">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-geometry-shader</a></li>
</ul>
<pre><code class="language-hlsl">[maxvertexcount(NumVerts)]
void ShaderName ( PrimitiveType DataType Name [ NumElements ], inout StreamOutputObject )
{
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>PrimitiveType</th><th>Num</th><th></th></tr></thead><tbody>
<tr><td>point</td><td>1</td><td>Point list</td></tr>
<tr><td>line</td><td>2</td><td>Line list or line strip</td></tr>
<tr><td>triangle</td><td>3</td><td>Triangle list or triangle strip</td></tr>
<tr><td>lineadj</td><td>4</td><td>Line list with adjacency or line strip with adjacency</td></tr>
<tr><td>triangleadj</td><td>6</td><td>Triangle list with adjacency or triangle strip with adjacency</td></tr>
</tbody></table>
</div>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-so-type">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-so-type</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>StreamOutputObject</th><th></th></tr></thead><tbody>
<tr><td>PointStream&lt;T&gt;</td><td>A sequence of point primitives</td></tr>
<tr><td>LineStream&lt;T&gt;</td><td>A sequence of line primitives</td></tr>
<tr><td>TriangleStream&lt;T&gt;</td><td>A sequence of triangle primitives</td></tr>
</tbody></table>
</div>
<h2 id="barebone"><a class="header" href="#barebone">Barebone</a></h2>
<pre><code class="language-hlsl">#pragma vertex vert
#pragma fragment frag
#pragma geometry geom

struct FromVS
{
    float4 positionOS : POSITION
}

struct VStoGS
{
    float4 positionOS : SV_POSITION
}

struct GStoFS
{
    float4 positionCS : SV_POSITION
}

VStoGS vert(FromVS IN)
{
}


[maxvertexcount(3)] // 최대 얼마나 많이 vertex를 추가할 것인가.
void geom(triangle float4 IN[3] : SV_POSITION, uint pid : SV_PrimitiveID, inout TriangleStream&lt;GStoFS&gt; STREAM)
void geom(triangle VStoGS IN[3], uint pid : SV_PrimitiveID, inout TriangleStream&lt;GStoFS&gt; STREAM)
{
    GStoFS OUT1;
    GStoFS OUT2;
    GStoFS OUT3;

    STREAM.Append(OUT1);
    STREAM.Append(OUT2);
    STREAM.Append(OUT3);

    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-so-restartstrip
    // Ends the current primitive strip and starts a new strip
    STREAM.RestartStrip();
}

half4 frag(GStoFS IN) : SV_Target
{
}
</code></pre>
<h2 id="etc-1"><a class="header" href="#etc-1">Etc</a></h2>
<ul>
<li><a href="https://medium.com/@andresgomezjr89/rain-snow-with-geometry-shaders-in-unity-83a757b767c1">https://medium.com/@andresgomezjr89/rain-snow-with-geometry-shaders-in-unity-83a757b767c1</a>
<ul>
<li><a href="https://github.com/tiredamage42/RainSnowGeometryShader">https://github.com/tiredamage42/RainSnowGeometryShader</a></li>
</ul>
</li>
<li><a href="https://jayjingyuliu.wordpress.com/2018/01/24/unity3d-wireframe-shader/">https://jayjingyuliu.wordpress.com/2018/01/24/unity3d-wireframe-shader/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lightmap"><a class="header" href="#lightmap">Lightmap</a></h1>
<h2 id="ref-15"><a class="header" href="#ref-15">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/JaesikHwang/lightmap-ec8-b9cec8aa4ed859ceab5acecb695ed9598eab8b0">KGC2008 -Build Lightmap system</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lpv"><a class="header" href="#lpv">LPV</a></h1>
<ul>
<li>Light Propagation Volumes</li>
</ul>
<h2 id="ref-16"><a class="header" href="#ref-16">Ref</a></h2>
<ul>
<li>https://ericpolman.com/2016/06/28/light-propagation-volumes/
<ul>
<li>https://blog.naver.com/catllage/221830338176</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noise"><a class="header" href="#noise">Noise</a></h1>
<h2 id="ref-17"><a class="header" href="#ref-17">Ref</a></h2>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=u9lOaPVtSqg">Unity Shader Graph - Electricity Shader Effect Tutorial</a></p>
</li>
<li>
<p><a href="https://blog.naver.com/sorkelf/40156271551">sorkelf - 펄린 노이즈(Perln Noise)</a></p>
</li>
<li>
<p><a href="http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/yolon3000/article/details/78106203">https://blog.csdn.net/yolon3000/article/details/78106203</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/candycat1992/article/details/50346469">https://blog.csdn.net/candycat1992/article/details/50346469</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_38275140/article/details/84205711">https://blog.csdn.net/qq_38275140/article/details/84205711</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_38275140/article/details/84349192">https://blog.csdn.net/qq_38275140/article/details/84349192</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_38275140/article/details/96859384">https://blog.csdn.net/qq_38275140/article/details/96859384</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ray"><a class="header" href="#ray">Ray</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Ray Casting</td><td>ray를 쏘고 맞춘놈을 찾음</td></tr>
<tr><td>Ray Marching</td><td>ray를 쏘고 맞춘놈을 찾음. 찾기위해 기하학적 교차 테스트(ex SDF(Signed Distance Function))을 이용</td></tr>
<tr><td>Ray Tracing</td><td>ray를 쏘고 맞춘놈을 찾음. 거기서 편향되게(reflect/refract) 레이를 쏨.</td></tr>
<tr><td>Path Tracing</td><td>ray를 쏘고 맞춘놈을 찾음. 거기서 고르게(GI) 레이를 쏨.</td></tr>
</tbody></table>
</div>
<h2 id="ray-marching"><a class="header" href="#ray-marching">Ray Marching</a></h2>
<ul>
<li><a href="http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#signed-distance-functions">http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#signed-distance-functions</a></li>
<li><a href="https://iquilezles.org/www/index.htm">https://iquilezles.org/www/index.htm</a></li>
<li><a href="http://blog.three-eyed-games.com/2018/05/03/gpu-ray-tracing-in-unity-part-1/">http://blog.three-eyed-games.com/2018/05/03/gpu-ray-tracing-in-unity-part-1/</a></li>
<li><a href="http://blog.three-eyed-games.com/2018/05/12/gpu-path-tracing-in-unity-part-2/">http://blog.three-eyed-games.com/2018/05/12/gpu-path-tracing-in-unity-part-2/</a>
<ul>
<li><a href="https://blog.csdn.net/qq_38275140/article/details/90239218">https://blog.csdn.net/qq_38275140/article/details/90239218</a></li>
<li><a href="https://blog.csdn.net/qq_38275140/article/details/90269865">https://blog.csdn.net/qq_38275140/article/details/90269865</a></li>
<li><a href="https://blog.csdn.net/qq_38275140/article/details/90345582">https://blog.csdn.net/qq_38275140/article/details/90345582</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=Cp5WWtMoeKg">Coding Adventure: Ray Marching</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLGmrMu-IwbgtMxMiV3x4IrHPlPmg7FD-P">The Art of Code - Ray Marching playlist</a></li>
<li><a href="https://www.youtube.com/playlist?list=PL3POsQzaCw53iK_EhOYR39h1J9Lvg-m-g">Peer Play - Raymarching Shader Tutorial playlist</a></li>
<li><a href="https://rito15.github.io/posts/ray-marching/">https://rito15.github.io/posts/ray-marching/</a></li>
</ul>
<h2 id="ref-18"><a class="header" href="#ref-18">Ref</a></h2>
<ul>
<li><a href="Advanced/_SDF.html">SDF.md</a></li>
<li><a href="https://www.youtube.com/watch?v=frLwRLS_ZR0">Disney's Practical Guide to Path Tracing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdf"><a class="header" href="#sdf">SDF</a></h1>
<ul>
<li>SDf : Signed Distance Field</li>
</ul>
<h2 id="예-1"><a class="header" href="#예-1">예</a></h2>
<ul>
<li>폰트 렌더링</li>
<li>LOD를 위한 알파맵
<ul>
<li><a href="https://blog.naver.com/kite3h/222500918662">https://blog.naver.com/kite3h/222500918662</a></li>
</ul>
</li>
<li>Ray Marching</li>
</ul>
<h2 id="ref-19"><a class="header" href="#ref-19">Ref</a></h2>
<ul>
<li><a href="https://advances.realtimerendering.com/s2015/DynamicOcclusionWithSignedDistanceFields.pdf">SIGGRAPH2015 - Dynamic Occlusion with Signed Distance Fields</a></li>
<li><a href="https://www.youtube.com/watch?v=s8nFqwOho-s">NVScene 2015 Session: How to Create Content with Signed Distance Functions (Johann Korndörfer)</a></li>
<li><a href="https://iquilezles.org/www/index.htm">https://iquilezles.org/www/index.htm</a>
<ul>
<li><a href="https://iquilezles.org/www/articles/smin/smin.htm">https://iquilezles.org/www/articles/smin/smin.htm</a></li>
<li><a href="https://iquilezles.org/www/articles/distfunctions/distfunctions.htm">https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="srp-overview"><a class="header" href="#srp-overview">SRP Overview</a></h1>
<p>Sobel Filter</p>
<div class="juxtapose" data-animate="false">
  <img src="SRP/../res/SRP/Sobel_before.jpg" data-label="" />
  <img src="SRP/../res/SRP/Sobel_after.jpg" data-label="" />
</div>
<p>Bloom(with DualFilter)</p>
<div class="juxtapose" data-animate="false">
 <img src="SRP/../res/SRP/BloomDualFilter_before.jpg" data-label="" />
 <img src="SRP/../res/SRP/BloomDualFilter_after.jpg" data-label="" />
</div>
<p>Light Streak</p>
<div class="juxtapose" data-animate="false">
 <img src="SRP/../res/SRP/CrossFilter_before.jpg" data-label="" />
 <img src="SRP/../res/SRP/CrossFilter_after.jpg" data-label="" />
</div>
<p>Screen Space Ambient Occlusion</p>
<div class="juxtapose" data-animate="false">
 <img src="SRP/../res/SRP/SSAO_before.jpg" data-label="" />
 <img src="SRP/../res/SRP/SSAO_after.jpg" data-label="" />
</div>
<div class="juxtapose" data-animate="false">
 <img src="SRP/../res/SRP/SSAO_blur_before.jpg" data-label="Wihout Blur" />
 <img src="SRP/../res/SRP/SSAO_blur_after.jpg" data-label="With Blur" />
</div>
<p>Screen Space Global Illumination</p>
<div class="juxtapose" data-animate="false">
 <img src="SRP/../res/SRP/SSGI_before.jpg" data-label="" />
 <img src="SRP/../res/SRP/SSGI_after.jpg" data-label="" />
</div>
<div class="juxtapose" data-animate="false">
 <img src="SRP/../res/SRP/SSGI_only_before.jpg" data-label="Wihout Blur" />
 <img src="SRP/../res/SRP/SSGI_only_after.jpg" data-label="Raw RenderTexture" />
</div>
<p>Light Shaft</p>
<div class="juxtapose" data-animate="false">
 <img src="SRP/../res/SRP/LightShaft_before.jpg" data-label="Origin" />
 <img src="SRP/../res/SRP/LightShaft_after.jpg" data-label="LightShaft Without Blur" />
</div>
<p>FXAA</p>
<div class="juxtapose" data-animate="false">
  <img src="SRP/../res/SRP/FXAA_before.png" data-label="" />
  <img src="SRP/../res/SRP/FXAA_after.png" data-label="" />
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear--gamma"><a class="header" href="#linear--gamma">Linear / Gamma</a></h1>
<p>Unity에는 Gamma와 Linear를 선택할 수 있는 Color Space항목이 있다.</p>
<p><code>Edit&gt; Project Settings&gt; Player&gt; Other Settings&gt; Rendering&gt; Color Space</code></p>
<p><img src="SRP/../res/URP/LinearRendering-ColorSpaceSetting.png" alt="./LinearRendering-ColorSpaceSetting.png" /></p>
<h2 id="gamma--linear-color-space-결과물-차이"><a class="header" href="#gamma--linear-color-space-결과물-차이">Gamma / Linear Color Space 결과물 차이</a></h2>
<p>일단 차이부터 알아보자.</p>
<ul>
<li><a href="https://docs.unity3d.com/2021.1/Documentation/Manual/LinearRendering-LinearOrGammaWorkflow.html">unity: Linear or gamma workflow</a></li>
</ul>
<p><img src="SRP/../res/URP/lineargammahead.png" alt="./lineargammahead.png" />
<img src="SRP/../res/URP/LinearLighting-2.jpg" alt="./LinearLighting-2.jpg" /></p>
<ul>
<li>감마 색 공간에서의 블렌딩은 결과적으로 채도와 밝기가 과도하게 높습니다</li>
</ul>
<p>이러한 조명 강도, 블렌딩 차이는 <strong>왜</strong> 생기는 것일까?</p>
<h2 id="gamma와-linear의-관계"><a class="header" href="#gamma와-linear의-관계">Gamma와 Linear의 관계</a></h2>
<p>같은 RGB값이라도 Linear와 Gamma상태에서 보여지는 색이 다르다.</p>
<p><img src="SRP/../res/URP/linear-gamma-white-blackc.png" alt="./linear-gamma-white-blackc.png" /></p>
<ul>
<li>감마 보정(<a href="https://en.wikipedia.org/w/index.php?title=Gamma_correction">wiki: Gamma correction</a>)</li>
</ul>
<h2 id="gamma-encodedecode"><a class="header" href="#gamma-encodedecode">Gamma Encode/Decode</a></h2>
<p>Linear는 무엇이고 Gamma는 무엇인가?</p>
<p><img src="SRP/../res/URP/gammacurves.png" alt="../res/URP/gammacurves.png" /></p>
<div class="table-wrapper"><table><thead><tr><th>선</th><th>Gamma</th><th>Gamma Value</th><th>공간</th></tr></thead><tbody>
<tr><td>초록-위</td><td>encode</td><td>pow(x, 0.45) (0.45 == 1/2.2)</td><td></td></tr>
<tr><td>검정-가운데</td><td>-</td><td>pow(x, 1.0 )</td><td>Linear</td></tr>
<tr><td>빨강-아래</td><td>decode</td><td>pow(x, 2.2 )</td><td>Gamma / sRGB / CRT</td></tr>
</tbody></table>
</div>
<ul>
<li><a href="https://en.wikipedia.org/wiki/SRGB">wiki: sRGB</a> : standard RGB color space.</li>
</ul>
<h2 id="gamma--linear-color-space-작업-환경"><a class="header" href="#gamma--linear-color-space-작업-환경">Gamma / Linear Color Space 작업 환경</a></h2>
<p>Linear와 Gamma가 <strong>왜</strong> 작업 결과물에 영향을 주는가?</p>
<p><img src="SRP/../res/010_colorManagement_250_linear_workflow_FHD-scaled.jpg" alt="" />
<img src="SRP/../res/URP/An+image+comparing+gamma+and+linear+pipelines.png" alt="../res/URP/An+image+comparing+gamma+and+linear+pipelines.png" /></p>
<ul>
<li>Gamma Pipeline에서는 빛의 연산 결과가 Linear환경에서 연산되고 모니터에는 Gamam가 적용된 상태로 표시된다.</li>
<li>빛의 연산 결과도 Linear환경으로 표시하려면, 모니터에 Gamma가 적용되어 어두워지기전에, 미리 밝게해두면 Linear한 빛의 연산 결과를 모니터에서 확인할 수 있게 된다.</li>
</ul>
<h3 id="이미지-제작-환경감마-보정-환경"><a class="header" href="#이미지-제작-환경감마-보정-환경">이미지 제작 환경(감마 보정 환경)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>환경</th><th>Gamma correction</th><th>설명</th></tr></thead><tbody>
<tr><td>포토샵</td><td>편집시 decode(2.2) / 저장시 (1)</td><td>포토샵 기본셋팅시: 편집(모니터 Gamma환경) / 저장(모니터 Gamma환경이 아닌 원래 그대로)</td></tr>
<tr><td>셰이더</td><td>1</td><td>셰이더 계산은 Linear 환경이다</td></tr>
<tr><td>모니터</td><td>decode(2.2)</td><td></td></tr>
</tbody></table>
</div>
<h3 id="rendering---gamma-color-space"><a class="header" href="#rendering---gamma-color-space">Rendering - Gamma Color Space</a></h3>
<div class="table-wrapper"><table><thead><tr><th>연산</th><th>pow(0.5, x)</th><th>값</th></tr></thead><tbody>
<tr><td>encode</td><td>pow(0.5, 0.45)</td><td>0.7 (0.7320428479728127)</td></tr>
<tr><td>-</td><td>pow(0.5, 1)</td><td>0.5</td></tr>
<tr><td>decode</td><td>pow(0.5, 2.2)</td><td>0.2 (0.217637640824031)</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>환경</th><th>연산</th><th>텍스쳐</th><th>셰이딩</th><th></th></tr></thead><tbody>
<tr><td>모니터(포토샵)</td><td>decode</td><td>0.2</td><td></td><td></td></tr>
<tr><td>저장</td><td>encode</td><td>0.5</td><td></td><td>포토샵 컬러 이미지 파일</td></tr>
<tr><td>셰이더(모델)</td><td>-</td><td>0.5</td><td>0.5</td><td>이미지가 밝아진 상태에서 연산</td></tr>
<tr><td>모니터(게임)</td><td>decode</td><td>0.2</td><td>0.2</td><td></td></tr>
</tbody></table>
</div>
<ul>
<li>문제점
<ul>
<li>광원 감쇠
<ul>
<li>감마 파이프라인에서는 셰이더 연산이 어둡게 보임.(셰이딩 값 참조)</li>
</ul>
</li>
<li>광원 강도 반응
<ul>
<li>광원의 강도에 따라 선형적이 아닌 비 선형적으로 밝아지거나 어두워진다.</li>
</ul>
</li>
<li>블렌딩
<ul>
<li>채도와 밝기가 과도하게 높아질 수 있음.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="rendering---linear-color-space"><a class="header" href="#rendering---linear-color-space">Rendering - Linear Color Space</a></h3>
<ul>
<li><strong>Gamma Correction</strong>
<ul>
<li>Gamma를 1.0으로 하는게 Gamma Correction이라고 하는 인터넷 문서들이 있는데, 그렇게 이해하면 안됨.</li>
<li><a href="https://en.wikipedia.org/wiki/Gamma_correction">Wiki</a>에는 Gamma Correction 자체가 Gamma 연산을 하는 걸로 정의되어 있음.</li>
<li>게임에서는 출력장치로 출력하기 좋게 Gamma를 보정하는 작업을 Gamma Correction이라 칭하는게 좀 더 게임개발에 알맞음.
<ul>
<li>모니터로 출력시 어둡게 출력되는데, 출력 전에 밝게 후보정하는 작업.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="srgb-보정"><a class="header" href="#srgb-보정">sRGB 보정</a></h4>
<ul>
<li>sRGB 체크시 RGB채널에 대한 Gamma Decode을 수행시(단, A채널은 그대로).</li>
<li><strong>alpha에 대해선 체크 여부에 상관없이 decode적용 안함.</strong>
<ul>
<li>남는 alpha채널에 Mask맵 같은걸 찡겨 넣을 수 있음.</li>
<li>다만, 게임에서의 리니어 알파가 포토샵같이 비선형의 알파가 다름으로써 UI 알파블렌딩에서 문제가 됨.
<ul>
<li>UI의 알파처리는 따로 처리해줘야 함.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>환경</th><th>연산</th><th>텍스쳐</th><th>셰이딩</th><th></th></tr></thead><tbody>
<tr><td>모니터(포토샵)</td><td>decode</td><td>0.2</td><td></td><td></td></tr>
<tr><td>저장</td><td>encode</td><td>0.5</td><td></td><td>포토샵 컬러 이미지 파일</td></tr>
<tr><td><strong>sRGB옵션</strong></td><td>decode</td><td>0.2</td><td></td><td>sRGB Check시 (Gamma decode적용)</td></tr>
<tr><td>셰이더(모델)</td><td>-</td><td>0.2</td><td>0.5</td><td>이미지가 작업 환경과 동일한 환경에서 연산</td></tr>
<tr><td>셰이더(포스트프로세스)</td><td>encode</td><td>0.5</td><td>0.7</td><td>디스플레이에 보여주기 전에 최종 후처리</td></tr>
<tr><td>모니터(게임)</td><td>decode</td><td>0.2</td><td>0.5</td><td></td></tr>
</tbody></table>
</div>
<h4 id="srgb-미보정"><a class="header" href="#srgb-미보정">sRGB 미보정</a></h4>
<ul>
<li>컬러 텍스쳐를 sRGB 체크를 하지 않으면, 색이 떠보이게됨.</li>
<li>ORM
<ul>
<li>Normal 텍스쳐는 수치 그 자체이므로 sRGB옵션 자체가 없음.</li>
<li>Roughness/Occlusion는 sRGB 체크를 해지해야함.</li>
</ul>
</li>
<li>기타 수치 텍스쳐
<ul>
<li>flowmap 등등...</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>환경</th><th>연산</th><th>텍스쳐</th><th>셰이딩</th><th></th></tr></thead><tbody>
<tr><td>저장</td><td>encode</td><td>0.5</td><td></td><td>이미지 파일</td></tr>
<tr><td>셰이더(모델)</td><td>-</td><td>0.5</td><td>0.5</td><td></td></tr>
<tr><td>셰이더(포스트프로세스)</td><td>encode</td><td>0.7</td><td>0.7</td><td>디스플레이에 보여주기 전에 최종 후처리</td></tr>
<tr><td>모니터(게임)</td><td>decode</td><td>0.5</td><td>0.5</td><td></td></tr>
</tbody></table>
</div>
<h2 id="종합"><a class="header" href="#종합">종합</a></h2>
<p><img src="SRP/../res/URP/lighting-shading-by-john-hable-31-2048.webp" alt="../res/URP/lighting-shading-by-john-hable-31-2048.webp" /></p>
<div class="table-wrapper"><table><thead><tr><th>step</th><th>환경</th><th>텍스쳐</th><th>셰이딩</th></tr></thead><tbody>
<tr><td></td><td>모니터(포토샵)</td><td>0.2</td><td></td></tr>
<tr><td>Hard Drive</td><td>저장</td><td>0.5</td><td></td></tr>
<tr><td>Lighting</td><td>셰이더(모델)</td><td>0.5</td><td>0.5</td></tr>
<tr><td>Screen</td><td>모니터(게임)</td><td>0.2</td><td>0.2</td></tr>
</tbody></table>
</div>
<p><img src="SRP/../res/URP/lighting-shading-by-john-hable-33-2048.webp" alt="../res/URP/lighting-shading-by-john-hable-33-2048.webp" /></p>
<div class="table-wrapper"><table><thead><tr><th>Step</th><th>환경</th><th>텍스쳐</th><th>셰이딩</th></tr></thead><tbody>
<tr><td></td><td>모니터(포토샵)</td><td>0.2</td><td></td></tr>
<tr><td>Hard Drive</td><td>저장</td><td>0.5</td><td></td></tr>
<tr><td>Gamma</td><td><strong>sRGB옵션</strong></td><td>0.2</td><td></td></tr>
<tr><td>Lighting</td><td>셰이더(모델)</td><td>0.2</td><td>0.5</td></tr>
<tr><td>Shader Correct</td><td>셰이더(포스트프로세스)</td><td>0.5</td><td>0.7</td></tr>
<tr><td>Monitor Adjust</td><td>모니터(게임)</td><td>0.2</td><td>0.5</td></tr>
</tbody></table>
</div>
<p><img src="SRP/../res/URP/lighting-shading-by-john-hable-34-2048.webp" alt="../res/URP/lighting-shading-by-john-hable-34-2048.webp" /></p>
<p>좌 감마 // 우 리니어</p>
<h2 id="linear-color-space에서-작업시-주의할-점"><a class="header" href="#linear-color-space에서-작업시-주의할-점">Linear Color Space에서 작업시 주의할 점</a></h2>
<ul>
<li>플렛폼 지원</li>
<li>sRGB로 보정이 필요한 텍스쳐 구분</li>
<li>UI 텍스쳐의 Alpha값</li>
</ul>
<h3 id="플렛폼-지원"><a class="header" href="#플렛폼-지원">플렛폼 지원</a></h3>
<ul>
<li>
<p>OpenGL ES 2.0 이하는 Gamma만 지원.</p>
<ul>
<li><a href="https://blogs.unity3d.com/kr/2016/12/07/linear-rendering-support-on-android-and-ios/">https://blogs.unity3d.com/kr/2016/12/07/linear-rendering-support-on-android-and-ios/</a></li>
<li><a href="https://developer.android.com/about/dashboards/index.html#OpenGL">https://developer.android.com/about/dashboards/index.html#OpenGL</a></li>
</ul>
</li>
<li>
<p>Linear를 위한 모바일 최소 사양</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>platform</th><th>version</th><th>API</th></tr></thead><tbody>
<tr><td>Android</td><td>Android 4.3 / API level 18 / Jelly Bean</td><td>OpenGL ES 3.0 / Vulkan</td></tr>
<tr><td>iOS</td><td>8.0</td><td>Metal</td></tr>
</tbody></table>
</div>
<h3 id="srgb로-보정이-필요한-텍스쳐-구분"><a class="header" href="#srgb로-보정이-필요한-텍스쳐-구분">sRGB로 보정이 필요한 텍스쳐 구분</a></h3>
<p><img src="SRP/../res/URP/sRGB_ColorTexture.JPG" alt="../res/URP/sRGB_ColorTexture.JPG" /></p>
<ol>
<li>데이터를 그대로 다루는것은 Linear로</li>
<li>나머지 Albedo / Emmission는 sRGB 체크로 Gamma Decode 하도록</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th>Image</th><th>sRGB 체크</th><th></th></tr></thead><tbody>
<tr><td>Albedo</td><td>O</td><td>Gamma Decode 적용</td></tr>
<tr><td>Albedo + Smoothness(alpha)</td><td>O</td><td>sRGB는 RGB값에만 적용. Alpha는 미적용.</td></tr>
<tr><td>DataTexture</td><td>X</td><td>데이터 그대로 사용</td></tr>
<tr><td>NormalMap</td><td>옵션없음</td><td>데이터 그대로 사용</td></tr>
</tbody></table>
</div>
<h3 id="ui-텍스쳐의-alpha값"><a class="header" href="#ui-텍스쳐의-alpha값">UI 텍스쳐의 Alpha값</a></h3>
<ul>
<li>Linear환경으로 보다 풍부한 표현력을 얻었지만, UI색상의 알파블랜딩이 제대로 되지 않는 현상이 있다.
<ul>
<li>Linear개념으로 보면 정확한 계산이지만, 포토샵 작업자 관점에서는 아니다.</li>
</ul>
</li>
<li>sRGB옵션은 RGB에만 영향을 줌으로, Alpha를 처리함에 있어 추가 작업을 해 주어야 한다.</li>
</ul>
<p><img src="SRP/../res/URP/ui_alpha_blend_problem.jpg" alt="../res/URP/ui_alpha_blend_problem.jpg" /></p>
<p>몇가지 방법이 있다</p>
<ul>
<li>포토샵 강제 설정하거나...</li>
<li>UI카메라와 SRP의 활용하거나..</li>
</ul>
<h4 id="photoshop-설정"><a class="header" href="#photoshop-설정">Photoshop 설정</a></h4>
<ul>
<li>처음부터 Linear로 저장시켜버리자</li>
<li>포토샵 Color Settings &gt; Advanced &gt; Blend RPG Colors Using Gamma: 1.00</li>
<li>작업비용
<ul>
<li>디자이너들은 작업하기 불편...</li>
<li>프로그래머의 추가 작업 불필요.</li>
</ul>
</li>
</ul>
<h4 id="ui카메라--srp"><a class="header" href="#ui카메라--srp">UI카메라 + SRP</a></h4>
<ul>
<li>UI카메라를 따로 두어서 UI Alpha에 미리 감마를 적용시켜주자.</li>
<li>그리고 Game카메라와 잘 섞어주자.</li>
</ul>
<ol>
<li>UITexture sRPG해제
<ul>
<li>sRGB상태 데이터 그대로 쓰고 Alpha만 어떻게 잘 처리할 것이다.</li>
</ul>
</li>
<li>Main Camera
<ol>
<li>Camera&gt; Rendering&gt; Culling Mask&gt; Uncheck UI</li>
</ol>
</li>
<li>UI Camera
<ol>
<li>Camera&gt; Render Type&gt; OverLay</li>
<li>Camera&gt; Rendering&gt; Renderer&gt; GameUIFix</li>
<li>Camera&gt; Rendering&gt; Culling Mask&gt; UI</li>
</ol>
</li>
<li>UI Canvas
<ol>
<li>Canvas&gt; Render Camera&gt; UI Camera</li>
</ol>
</li>
<li>PipelineAsset 설정
<ol>
<li>_CameraColorTexture를 활용: Quality&gt; Anti Aliasing (MSAA)&gt; 2x 이상</li>
</ol>
</li>
<li>RenderFeature 작성
<ol>
<li>Game 카메라(Linear공간)를 Gamma 공간으로 변환</li>
<li>변환된 Game카메라의 출력결과 + UI카메라 출력결과</li>
<li>합친 결과(Gamma Space)를 Linear Space로 변경시켜주기</li>
</ol>
</li>
<li>새로운 Renderer 추가와 작성한 Feature추가
<ol>
<li>General&gt; Renderer List&gt; Add Last GammaUIFix</li>
</ol>
</li>
</ol>
<p><img src="SRP/../res/URP/LinearGammaURPFix.jpg" alt="../res/URP/LinearGammaURPFix.jpg" /></p>
<pre><code class="language-hlsl">// _CameraColorTexture 활성화는 PipelineAsset&gt; Quality&gt; Anti Aliasing (MSAA)&gt; 2x 이상으로 하면 됨.

// 1. DrawUIIntoRTPass
//    cmd.SetRenderTarget(UIRenderTargetID);
//    cmd.ClearRenderTarget(clearDepth: true, clearColor: true, Color.clear);
// 2. BlitPass
//    cmd.Blit(DrawUIIntoRTPass.UIRenderTargetID, _colorHandle, _material);

float4 uiColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);
uiColor.a = LinearToGamma22(uiColor.a);

float4 mainColor = SAMPLE_TEXTURE2D(_CameraColorTexture, sampler_CameraColorTexture, i.uv);
mainColor.rgb = LinearToGamma22(mainColor.rgb);

float4 finalColor;
finalColor.rgb = lerp(mainColor.rgb, uiColor.rgb, uiColor.a);
finalColor.rgb = Gamma22ToLinear(finalColor.rgb);
finalColor.a = 1;
</code></pre>
<h2 id="ref-20"><a class="header" href="#ref-20">Ref</a></h2>
<ul>
<li><a href="https://www.gdcvault.com/play/1012351/Uncharted-2-HDR">[GDC2010] GDCValue: Uncharted-2-HDR</a>
<ul>
<li>slideshare: <a href="https://www.slideshare.net/naughty_dog/lighting-shading-by-john-hable">Lighting Shading by John Hable</a></li>
</ul>
</li>
<li>정종필 linear/gamma 설명
<ul>
<li>정종필님의 설명 볼때 주의점
<ul>
<li>텍스쳐와 빛의 연산을 뚜렸히 분리하여 설명하지 않고, 리니어라는 것을 강조하기 위해 그래프를 옆에두고 설명함</li>
<li>처음에는 이미지가 다른 걸 보고 아 그렇구나 해서 이해한것으로 착각하기 쉬운데, 텍스쳐와 빛의 연산을 분리하지 않고 설명해서 나중에 더 햇갈릴 수 있음.</li>
<li>Uncharted-2-HDR를 확인 할것.</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=Xwlm5V-bnBc">정종필 - Gamma Color space와 Linear Color space란?</a>
<ul>
<li><a href="https://youtu.be/Xwlm5V-bnBc?si=JFxHE64X-08uOG3W&amp;t=629">텍스쳐 저장 공간 설명 View/HDD/Display</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=oVyqLhVrjhY">정종필 - 라이팅과 셰이더에서 연산을 위한 선형 파이프라인</a></li>
<li><a href="https://www.youtube.com/watch?v=lUvsEfqOkUo">정종필 - 유니티 셰이더에서 sRGB/Linear 사용 및 응용</a></li>
</ul>
</li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear">GPU Gems 3 - Chapter 24. The Importance of Being Linear</a></li>
<li><a href="http://www.codinglabs.net/article_gamma_vs_linear.aspx">Article - Gamma and Linear Spaces</a></li>
<li><a href="https://www.slideshare.net/agebreak/color-space-gamma-correction">[데브루키] Color space gamma correction</a></li>
<li><a href="https://chulin28ho.tistory.com/476">선형(Linear) 렌더링에서의 UI 작업할때 요령</a></li>
<li><a href="https://illu.tistory.com/1430">201205 Unity Linear color space에서 UI의 alpha 값이 바뀌는 문제에 대하여..</a></li>
<li><a href="https://cmwdexint.com/2019/05/30/3d-scene-need-linear-but-ui-need-gamma/">3D scene need Linear but UI need Gamma</a></li>
<li><a href="https://nbertoa.wordpress.com/2016/06/20/gamma-correction/">https://nbertoa.wordpress.com/2016/06/20/gamma-correction/</a></li>
<li><a href="https://chrisbrejon.com/cg-cinematography/chapter-1-color-management/">https://chrisbrejon.com/cg-cinematography/chapter-1-color-management/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="셰이더-모델과-플렛폼-관계"><a class="header" href="#셰이더-모델과-플렛폼-관계">셰이더 모델과 플렛폼 관계</a></h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/OpenGL_ES">wiki: OpenGL ES</a></li>
<li><a href="https://en.wikipedia.org/wiki/Metal_(API)">wiki: Metal</a></li>
<li><a href="https://en.wikipedia.org/wiki/Vulkan_(API)">wiki: Vulkan</a></li>
</ul>
<h2 id="shader-model"><a class="header" href="#shader-model">Shader Model</a></h2>
<ul>
<li><a href="https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html">https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html</a></li>
<li>Metal
<ul>
<li>geometry 지원 여부(일단 5.0까지 지원 안함)</li>
<li>compute에서 GetDimensions 지원 안함</li>
</ul>
</li>
<li>es3.1
<ul>
<li>4 compute buffer만 보장함.</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>model</th><th>desc</th></tr></thead><tbody>
<tr><td>2.5</td><td>derivatives</td></tr>
<tr><td>3.0</td><td>2.5 + interpolators10 + samplelod + fragcoord</td></tr>
<tr><td>3.5</td><td>3.0 + interpolators15 + mrt4 + integers + 2darray + instancing</td></tr>
<tr><td>4.0</td><td>3.5 + geometry</td></tr>
<tr><td>4.5</td><td>3.5 + compute + randomwrite</td></tr>
<tr><td>4.6</td><td>4.0 + cubearray + tesshw + tessellation</td></tr>
<tr><td>5.0</td><td>4.0 + compute + randomwrite + tesshw + tessellation</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>#pragma target</th><th>설명</th><th></th></tr></thead><tbody>
<tr><td>2.5</td><td>기본값 / WebGL1</td><td></td></tr>
<tr><td>3.0</td><td>WebGL2</td><td></td></tr>
<tr><td>3.5</td><td>es3.0  / Vulkan</td><td></td></tr>
<tr><td>4.0</td><td></td><td>Geometry</td></tr>
<tr><td>4.5</td><td>es3.1</td><td>Compute</td></tr>
<tr><td>4.6</td><td>es3.1+AEP</td><td>Tessellation(* Metal은 지원안함)</td></tr>
<tr><td>5.0</td><td></td><td>RenderTexture.enableRandomWrite</td></tr>
</tbody></table>
</div>
<h2 id="deferred-support"><a class="header" href="#deferred-support">Deferred support</a></h2>
<ul>
<li>최소 셰이더 모델 4.5이상</li>
<li>OpenGL기반 API에서는 지원하지 않음.</li>
</ul>
<h2 id="안드로이드와-그래픽-라이브러리"><a class="header" href="#안드로이드와-그래픽-라이브러리">안드로이드와 그래픽 라이브러리</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Graphic Library</th><th>Android API</th><th>version</th><th>코드명</th><th>Linear지원</th><th>GPU Instancing</th><th>SRP Batcher</th></tr></thead><tbody>
<tr><td>es2.0</td><td>8</td><td>2.2.x</td><td>Froyo</td><td>x</td><td>X</td><td>X</td></tr>
<tr><td>es3.0</td><td>18</td><td>4.3.x</td><td>Jelly Bean</td><td>O</td><td>O</td><td>X</td></tr>
<tr><td>es3.1</td><td>21</td><td>5.0</td><td>Lollipop</td><td>O</td><td>O</td><td>O</td></tr>
<tr><td>Vulkan</td><td>24</td><td>7.0</td><td>Nougat</td><td>O</td><td>O</td><td>O</td></tr>
</tbody></table>
</div>
<h2 id="linear지원-사양"><a class="header" href="#linear지원-사양">Linear지원 사양</a></h2>
<div class="table-wrapper"><table><thead><tr><th>platform</th><th>Graphic Library</th><th>version</th></tr></thead><tbody>
<tr><td>Android</td><td>OpenGL ES 3.0 / Vulkan</td><td>Android 4.3 / API level 18 / Jelly Bean</td></tr>
<tr><td>iOS</td><td>Metal</td><td>8.0</td></tr>
</tbody></table>
</div>
<h2 id="레퍼런스-디바이스"><a class="header" href="#레퍼런스-디바이스">레퍼런스 디바이스</a></h2>
<h3 id="android"><a class="header" href="#android">Android</a></h3>
<ul>
<li>모바일 디바이스는 PC와는 다르게 GPU전용 VRAM없이 그냥 shared memory임.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>RTX 4090</td><td>24GB</td><td>GDDR6X</td><td>Graphics DDR</td><td>SGRAM</td><td>Synchronous Graphics (Dynamic) Random Access Memory</td></tr>
<tr><td>S24</td><td>8 GB</td><td>LPDDR5X</td><td>LP(LOW Power) DDR</td><td>SDRAM</td><td>Synchronous Dynamic Random Access Memory</td></tr>
<tr><td>A17 Pro</td><td>8 GB</td><td>LPDDR5</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>AI때문에 HBM(High Bandwidth Memory)이 모바일에 들어올 정도가 된다면....</p>
<div class="table-wrapper"><table><thead><tr><th>년도</th><th>디바이스</th><th>안드로이드 버전</th><th>지원</th><th>android api</th></tr></thead><tbody>
<tr><td>2024</td><td>S24</td><td>14</td><td></td><td>34</td></tr>
<tr><td>2023</td><td>S23</td><td>13 → 14</td><td></td><td>33</td></tr>
<tr><td>2022</td><td>S22</td><td>12 → 13 → 14</td><td></td><td>31</td></tr>
<tr><td>2021</td><td>S21</td><td>11 → 12 → 13 → 14</td><td></td><td>30</td></tr>
<tr><td>2020</td><td>S20</td><td>10 → 11 → 12 → 13</td><td></td><td>29</td></tr>
<tr><td>2020</td><td>노트 20</td><td>10 → 11</td><td>es3.1 / Vlukan</td><td>29</td></tr>
<tr><td>2019</td><td>노트 10</td><td>9  → 10 → 11</td><td>es3.1 / Vlukan</td><td>28</td></tr>
<tr><td>2018</td><td>노트 9</td><td>8.1  → 9  → 10</td><td>es3.1 / Vlukan</td><td>27</td></tr>
<tr><td>2018</td><td>노트 8</td><td>7.1 → 8.0 → 9</td><td>es3.1 / Vlukan</td><td>25</td></tr>
<tr><td>2016</td><td>노트 7</td><td>6.0  // 베터리폭탄</td><td>es3.1</td><td>23</td></tr>
<tr><td>2015</td><td>노트 5</td><td>5.1 → 6.0  → 7.0</td><td>es3.1</td><td>22</td></tr>
<tr><td>2014</td><td>노트 4</td><td>4.4 → 5.0 → 5.1  → 6.0</td><td>es3.0</td><td>19</td></tr>
</tbody></table>
</div>
<h3 id="ios"><a class="header" href="#ios">ios</a></h3>
<ul>
<li><a href="https://iosref.com/ios">https://iosref.com/ios</a></li>
<li><a href="https://en.wikipedia.org/wiki/IOS_version_history">https://en.wikipedia.org/wiki/IOS_version_history</a></li>
</ul>
<h2 id="ref-21"><a class="header" href="#ref-21">Ref</a></h2>
<ul>
<li><a href="https://developer.android.com/guide/topics/graphics/opengl?hl=ko">https://developer.android.com/guide/topics/graphics/opengl?hl=ko</a></li>
<li><a href="https://source.android.com/setup/start/build-numbers?hl=ko">https://source.android.com/setup/start/build-numbers?hl=ko</a></li>
<li><a href="https://developer.android.com/ndk/guides/graphics/getting-started?hl=ko">https://developer.android.com/ndk/guides/graphics/getting-started?hl=ko</a></li>
<li><a href="https://forum.unity.com/threads/severe-banding-with-webgl-on-chrome.310326/#post-2035482">https://forum.unity.com/threads/severe-banding-with-webgl-on-chrome.310326/#post-2035482</a></li>
<li><a href="https://blog.mozilla.org/futurereleases/2015/03/03/an-early-look-at-webgl-2/">https://blog.mozilla.org/futurereleases/2015/03/03/an-early-look-at-webgl-2/</a></li>
<li>SRP Batcher : <a href="https://blog.unity.com/kr/technology/srp-batcher-speed-up-your-rendering">https://blog.unity.com/kr/technology/srp-batcher-speed-up-your-rendering</a></li>
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/rendering/deferred-rendering-path.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.0/manual/rendering/deferred-rendering-path.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="srp-scriptable-render-pipeline"><a class="header" href="#srp-scriptable-render-pipeline">SRP (Scriptable Render Pipeline)</a></h1>
<p>https://docs.unity3d.com/Manual/render-pipelines-feature-comparison.html</p>
<h2 id="renderpipelineassetasset"><a class="header" href="#renderpipelineassetasset">RenderPipelineAsset.asset</a></h2>
<ul>
<li>유니티에서 그래픽스 파이프 라인을 관리한다. 여러 <code>Renderer</code>를 가질 수 있다.</li>
</ul>
<pre><code class="language-cs">// 런타임 렌더파이프라인에셋 교체

// Edit&gt; Project Settings&gt; Scriptable Render Pipeline Settings

// 혹은, 이하 스크립트
public RenderPipelineAsset _renderPipelineAsset;

GraphicsSettings.renderPipelineAsset = _renderPipelineAsset;
</code></pre>
<pre><code class="language-cs">// 클래스를 만들어서 사용자 렌더파이프라인에셋 만들기
[CreateAssetMenu(menuName = "Rendering/CustomRenderPipelineAsset")]
public class CustomRenderPipelineAsset : RenderPipelineAsset
{
    protected override RenderPipeline CreatePipeline()
    {
        return new CustomRenderPipeline();
    }
}

public class CustomRenderPipeline : RenderPipeline
{
    protected override void Render(ScriptableRenderContext context, Camera[] cameras);
}
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<h3 id="renderpipeline"><a class="header" href="#renderpipeline">RenderPipeline</a></h3>
<pre><code class="language-hlsl">Pass
{
    Tags
    {
        // LightMode 태그는 라이팅 파이프 라인에서 패스의 역할을 정의.
        "LightMode" = "CustomLightMode"
    }
}

</code></pre>
<pre><code class="language-cs">[CreateAssetMenu(menuName = "Rendering/CustomRenderPipelineAsset")]
public class CustomRenderPipelineAsset : RenderPipelineAsset
{
    protected override RenderPipeline CreatePipeline()
    {
        return new CustomRenderPipeline();
    }
}

// ==========================================================================
public class CustomRenderPipeline : RenderPipeline
{
    CustomRenderer _renderer = new CustomRenderer();

    protected override void Render(ScriptableRenderContext context, Camera[] cameras)
    {
        foreach (Camera cam in cameras)
        {
            _renderer.Render(ref context, cam);
        }
    }
}

// ==========================================================================
public class CustomRenderer
{
    readonly static ShaderTagId unlitShaderTagId = new ShaderTagId("CustomLightMode");

    public void Render(ref ScriptableRenderContext context, Camera cam)
    {
        // ...
        context.Submit();                 // 실행
    }
}
</code></pre>
<pre><code class="language-cs">context.SetupCameraProperties(camera); // cmd전에 설정해주자(빠른 지우기)
var cmd = new CommandBuffer();
cmd.ClearRenderTarget
context.ExecuteCommandBuffer(cmd); // enqueue cmd
cmd.Release();
context.Submit();                 // 실행
</code></pre>
<pre><code class="language-cs">var cmd = new CommandBuffer();
cmd.BeginSample(string sampleName); // profiler begin
cmd.EndSample(string sampleName);   // profiler end
</code></pre>
<pre><code class="language-cs">// 컬링
if (!CulllResults.GetCullingParameters(camera, out ScriptableCullingParameters cullingParams))
{
    continue;
}
CullResults cullingResults = context.Cull(ref cullingParams);

SortingSettings sortingSettings = new SortingSettings(cam);
DrawingSettings drawingSettings = new DrawingSettings(unlitShaderTagId, sortingSettings);
FilteringSettings filteringSettings = new FilteringSettings(RenderQueueRange.opaque);

context.DrawRenderers(cullingResults, ref drawingSettings, ref filteringSettings);
context.DrawRenderers             // 렌더링
context.DrawSkybox(camera)        // Skybox
</code></pre>
<pre><code class="language-cs">// cs
var cmd = new CommandBuffer();
cmd.SetGlobalVector("_LightDir", new Vector4(0, 1, 0, 0));
context.ExecuteCommandBuffer(cmd);
cmd.Release();

// shader
CBUFFER_START(_Light) // CommandBuffer에서 전송됨
float4 _LightDir;
CBUFFER_END
</code></pre>
<ul>
<li>CBUFFER_START(UnityPerMaterial) // 메터리얼별</li>
<li>CBUFFER_START(UnityPerDraw)     // draw별</li>
<li><a href="https://blogs.unity3d.com/kr/2019/02/28/srp-batcher-speed-up-your-rendering/">https://blogs.unity3d.com/kr/2019/02/28/srp-batcher-speed-up-your-rendering/</a></li>
</ul>
<pre><code class="language-cs">/// Render Texture 사용.

// RenderTarget Id가 필요
int _TmpShaderProperty = Shader.PropertyToID("_TmpShaderProperty");

{
    var cmd = new CommandBuffer();
    // https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.GetTemporaryRT.html
    // GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite);
    // GetTemporaryRT(int nameID, RenderTextureDescriptor desc, FilterMode filter);
    cmd.GetTemporaryRT(_TmpShaderProperty, )
    cmd.SetRenderTarget(RTID);
    cmd.ClearRenderTarget;
    context.ExecuteCommandBuffer(cmd);
    cmd.Release();
}

{
    var cmd = new CommandBuffer();
    cmd.Blit(RTID, BuiltinRenderTextureType.CameraTarget);
    cmd.ReleaseTemporaryRT(TemporaryRTID);
    context.ExecuteCommandBuffer(cmd);
    cmd.Release();
}
</code></pre>
<h3 id="scriptablerenderpass"><a class="header" href="#scriptablerenderpass">ScriptableRenderPass</a></h3>
<pre><code class="language-cs">
...

CullResults cr = CullResults.Cull(ref cullingParams, context);
InitializeRenderingData(settings, ref cameraData, ref cullResults, out var renderingData);
renderer.Setup(context, ref renderingData); // RenderPass 쌓기.
renderer.Execute(context, ref renderingData);
</code></pre>
<pre><code class="language-cs">public struct RenderingData
{
    public CullingResults cullResults;
    public CameraData cameraData;
    public LightData lightData;
    public ShadowData shadowData;
    public PostProcessingData postProcessingData;
    public bool supportsDynamicBatching;
    public PerObjectData perObjectData;
    public bool postProcessingEnabled;
}
</code></pre>
<pre><code class="language-cs">- ScriptableRenderContext
- ScriptableRenderer (abstract class)
  - public abstract void Setup(ScriptableRenderContext context, ref RenderingData renderingData);

- ScriptableRendererFeature
RenderingData
RenderPassEvent
RenderTargetHandle
</code></pre>
<h2 id="submitrenderrequest"><a class="header" href="#submitrenderrequest">SubmitRenderRequest</a></h2>
<ul>
<li>https://docs.unity3d.com/ScriptReference/Camera.SubmitRenderRequest.html</li>
<li>https://docs.unity3d.com/ScriptReference/Rendering.RenderPipeline.SubmitRenderRequest.html
<ul>
<li>UniversalRenderPipeline은 다음을 지원합니다.
<ul>
<li>ScriptableRenderer.StandardRequest: 이 요청 유형은 전체 URP 카메라 스택을 렌더링하고 결과를 지정된 대상에 출력합니다. Base Camera에서만 호출할 수 있습니다.</li>
<li>UniversalRenderPipeline.SingleCameraRequest: 이 요청 유형은 단일 URP 카메라를 렌더링하고 그 결과를 지정된 대상에 출력합니다.</li>
</ul>
</li>
</ul>
</li>
<li>https://docs.unity3d.com/ScriptReference/Rendering.RenderPipeline.ProcessRenderRequests.html</li>
</ul>
<p>SubmitRenderRequest하면 파이프라인의 Rendering.RenderPipeline.ProcessRenderRequests 이 실행됨.</p>
<h2 id="ref-22"><a class="header" href="#ref-22">Ref</a></h2>
<ul>
<li>
<p><a href="https://github.com/cinight/CustomSRP/tree/master/Assets">https://github.com/cinight/CustomSRP/tree/master/Assets</a></p>
</li>
<li>
<p><a href="https://blogs.unity3d.com/2018/01/31/srp-overview/">https://blogs.unity3d.com/2018/01/31/srp-overview/</a></p>
</li>
<li>
<p><a href="https://blogs.unity3d.com/kr/2019/02/28/srp-batcher-speed-up-your-rendering/">https://blogs.unity3d.com/kr/2019/02/28/srp-batcher-speed-up-your-rendering/</a></p>
</li>
<li>
<p><a href="https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html">https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html</a></p>
</li>
<li>
<p><a href="https://docs.unity3d.com/Manual/srp-creating-render-pipeline-asset-and-render-pipeline-instance.html">https://docs.unity3d.com/Manual/srp-creating-render-pipeline-asset-and-render-pipeline-instance.html</a></p>
</li>
<li>
<p><a href="https://github.com/cinight/CustomSRP">https://github.com/cinight/CustomSRP</a></p>
</li>
<li>
<p><a href="https://catlikecoding.com/unity/tutorials/custom-srp/">catlikecoding - Custom SRP</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=MuzLdCXoJ9I">2019 - Unity SRP와 LWRP에 대한 모든 것!</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=vtfe3UgDs0w">2020 - Universal RenderPipeline의 Custom RenderPass를 활용하여 렌더링 기능을 구현해보자 Track1-2</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=QRlz4-pAtpY">2020 - Dev Weeks: URP 기본 구성과 흐름</a></p>
<ul>
<li><a href="http://www.unitysquare.co.kr/growwith/resource/form?id=83">Dev Weeks 2020.5. 세션자료</a></li>
</ul>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=9K1uOihvNyg">2020 - Dev Weeks: URP 셰이더 뜯어보기</a></p>
<ul>
<li><a href="http://www.unitysquare.co.kr/growwith/resource/form?id=87">Dev Weeks 2020.6. 세션자료</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shaderlab"><a class="header" href="#shaderlab">ShaderLab</a></h1>
<pre><code class="language-hlsl">// http://docs.unity3d.com/Manual/SL-Shader.html
Shader &lt;shader-name&gt;
{

    HLSLINCLUDE
    // ...
    ENDHLSL

    // http://docs.unity3d.com/Manual/SL-Properties.html
    Properties
    {
        _PropertyName ("displayed name", &lt;property-type&gt;) = &lt;property-default-value&gt;
    }

    // http://docs.unity3d.com/Manual/SL-SubShader.html
    SubShader
    {
        // http://docs.unity3d.com/Manual/SL-SubshaderTags.html
        Tags
        {
            // 주의. Pass의 Tag랑 다름
            &lt;tag-name&gt; = &lt;tag-value&gt;
        }
        
        // http://docs.unity3d.com/Manual/SL-ShaderLOD.html
        LOD &lt;lod-number&gt;
            
        // http://docs.unity3d.com/Manual/SL-UsePass.html
        UsePass "Shader/Name"
        
        
        // http://docs.unity3d.com/Manual/SL-Pass.html
        Pass
        {
            Name "PassName"
            
            // https://docs.unity3d.com/Manual/SL-PassTags.html
            Tags
            {
                // 주의. Subshader의 Tag랑 다름
                &lt;tag-name&gt; = &lt;tag-value&gt;
            }

            // https://docs.unity3d.com/Manual/SL-Stencil.html
            Stencil
            {
            }
            
            // http://docs.unity3d.com/Manual/SL-CullAndDepth.html
            Cull &lt;Back | Front | Off&gt; // default: Back 
            ZTest &lt;(Less | Greater | LEqual | GEqual | Equal | NotEqual | Always)&gt; // default: LEqual 
            ZWrite &lt;On | Off&gt; // default: On 
            Offset &lt;OffsetFactor&gt;, &lt;OffsetUnits&gt;

            // http://docs.unity3d.com/Manual/SL-Blend.html
            Blend &lt;SourceBlendMode&gt; &lt;DestBlendMode&gt;
            BlendOp &lt;colorOp&gt; // Instead of adding blended colors together, carry out a different operation on them
            BlendOp &lt;colorOp, alphaOp&gt; // Same as above, but use different blend operation for color (RGB) and alpha (A) channels.
            AlphaToMask &lt;On | Off&gt;

            ColorMask &lt;RGB | A | 0 | any combination of R, G, B, A&gt;
         
            HLSLPROGRAM
            ENDHLSL
        }
    }

    // http://docs.unity3d.com/Manual/SL-Fallback.html
    Fallback Off
    Fallback &lt;other-shader-name&gt;

    // http://docs.unity3d.com/Manual/SL-CustomEditor.html
    // http://docs.unity3d.com/Manual/SL-CustomMaterialEditors.html
    CustomEditor &lt;custom-editor-class-name&gt;
}
</code></pre>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<pre><code class="language-hlsl">Float           | float  |
Range(min, max) | float  |

Vector          | float4 | (x, y, z, w)
Color           | float4 | (r, g, b, a)

2D              | float4 | "", "white", "black", "gray", "bump" // for     power of 2 size
Rect            | float4 | "", "white", "black", "gray", "bump" // for non-power of 2 size

Cube            | float4 | "", "white", "black", "gray", "bump"

// 주의해야할게 2D/Rect/Cube는 linear설정 관계없이 sRGB로 된다.
// ex) pow(gray, 2.2);
</code></pre>
<pre><code class="language-hlsl">// color string
red
black
white
gray
grey
linearGray
linearGrey
grayscaleRamp
greyscaleRamp
bump
blackCube
lightmap
unity_Lightmap
unity_LightmapInd
unity_ShadowMask
unity_DynamicLightmap
unity_DynamicDirectionality
unity_DynamicNormal
unity_DitherMask
_DitherMaskLOD
_DitherMaskLOD2D
unity_RandomRotation16
unity_NHxRoughness
unity_SpecCube0
unity_SpecCube1
</code></pre>
<h2 id="properties-attributes"><a class="header" href="#properties-attributes">Properties attributes</a></h2>
<pre><code class="language-hlsl">[HideInInspector]
[NoScaleOffset]   - name##_ST 사용안할때
[Normal]          - 텍스쳐 설정 normal아니면 경고
[HDR]

[Gamma]           - indicates that a float/vector property is specified as sRGB value in the UI
(just like colors are), and possibly needs conversion according to color space used. See Properties in Shader Programs.
[PerRendererData]  - indicates that a texture property will be coming from per-renderer data in the form of a MaterialPropertyBlock. Material inspector changes the texture slot UI for these properties.

[MainTexture]
[MainColor]
</code></pre>
<h2 id="subshaders-tags"><a class="header" href="#subshaders-tags">SubShader's Tags</a></h2>
<pre><code class="language-hlsl">SubShader
{
    // http://docs.unity3d.com/Manual/SL-SubshaderTags.html
    Tags
    {
        // 주의. Pass의 Tag랑 다름
        "RenderPipeline" = "UniversalRenderPipeline"
        "RenderType" = "Opaque"
        "Queue" = "Geometry"
    }
}
</code></pre>
<pre><code class="language-hlsl">// ex) cutout() 셰이더
Tags
{
    "RenderPipeline" = "UniversalRenderPipeline"
    "Queue" = "AlphaTest"
    "RenderType" = "TransparentCutout"
    "IgnoreProjector" = "True"
}
</code></pre>
<h3 id="renderpipeline-1"><a class="header" href="#renderpipeline-1">RenderPipeline</a></h3>
<ul>
<li><a href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Shader-globalRenderPipeline.html">https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Shader-globalRenderPipeline.html</a></li>
</ul>
<h3 id="queue"><a class="header" href="#queue">Queue</a></h3>
<ul>
<li>렌더링 순서 지정. <code>Geometry+1</code>, <code>Geometry-1</code> 과 같이 가중치 적용가능</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Queue</th><th>[min,  max]</th><th>default</th><th>order</th><th>etc</th></tr></thead><tbody>
<tr><td>Background</td><td>[0    , 1499]</td><td>100</td><td>render first -&gt; back</td><td></td></tr>
<tr><td>Geometry</td><td>[1500 , 2399]</td><td>2000</td><td></td><td>&lt;기본값&gt; Opaque는 이쪽에</td></tr>
<tr><td>AlphaTest</td><td>[2400 , 2699]</td><td>2450</td><td></td><td>AlphaTest는 이쪽에</td></tr>
<tr><td>Transparent</td><td>[2700 , 3599]</td><td>3000</td><td>render back -&gt; front</td><td>AlphaBlend는 이쪽에</td></tr>
<tr><td>Overlay</td><td>[3600 , 5000]</td><td>4000</td><td>render last -&gt; front</td><td></td></tr>
</tbody></table>
</div>
<h3 id="rendertype"><a class="header" href="#rendertype">RenderType</a></h3>
<ul>
<li>그룹을 짓는것. 해당 그룹의 셰이더를 바꿔 랜더링 할 수 있음.
<ul>
<li>예를들어 Opaque의 노말버퍼를 만들고 싶을때 <code>RenderWithShader(Shader shader, "Opaque")</code> 이런 식으로..</li>
</ul>
</li>
<li><a href="https://docs.unity3d.com/2021.1/Documentation/Manual/SL-ShaderReplacement.html">https://docs.unity3d.com/2021.1/Documentation/Manual/SL-ShaderReplacement.html</a></li>
<li><a href="https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.shadergraph/Editor/Generation/Enumerations/RenderType.cs">https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.shadergraph/Editor/Generation/Enumerations/RenderType.cs</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>RenderType</th><th></th></tr></thead><tbody>
<tr><td>Opaque</td><td>대부분의 쉐이더</td></tr>
<tr><td>Transparent</td><td>투명한 쉐이더</td></tr>
<tr><td>TransparentCutout</td><td>마스킹 된 투명 쉐이더(2pass 식물쉐이더 등)</td></tr>
<tr><td>Background</td><td>Skybox 쉐이더</td></tr>
<tr><td>Overlay</td><td>후광(Halo), 플레어(Flare)</td></tr>
</tbody></table>
</div>
<h3 id="ignoreprojector"><a class="header" href="#ignoreprojector">IgnoreProjector</a></h3>
<ul>
<li><a href="https://docs.unity3d.com/Manual/class-Projector.html">https://docs.unity3d.com/Manual/class-Projector.html</a>
<ul>
<li>URP is not compatible with the Projector component. URP does not currently include an alternative solution.</li>
</ul>
</li>
<li><a href="https://github.com/Anatta336/driven-decals">https://github.com/Anatta336/driven-decals</a></li>
<li><a href="https://github.com/nyahoon-games/ProjectorForLWRP">https://github.com/nyahoon-games/ProjectorForLWRP</a></li>
</ul>
<h3 id="passs-tags"><a class="header" href="#passs-tags">Pass's Tags</a></h3>
<pre><code class="language-hlsl">Pass
{
    // http://docs.unity3d.com/Manual/SL-SubshaderTags.html
    Tags
    {
        // 주의. SubShader의 Tag랑 다름
        "LightMode" = "UniversalForward"
    }
}
</code></pre>
<h3 id="lihgtmode"><a class="header" href="#lihgtmode">LihgtMode</a></h3>
<ul>
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.3/manual/urp-shaders/urp-shaderlab-pass-tags.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.3/manual/urp-shaders/urp-shaderlab-pass-tags.html</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>LightMode</th><th>URP / Built-in</th><th></th></tr></thead><tbody>
<tr><td>UniversalForward</td><td>URP</td><td>Forward Rendering</td></tr>
<tr><td>UniversalGBuffer</td><td>URP</td><td>Deferred Rendering</td></tr>
<tr><td>UniversalForwardOnly</td><td>URP</td><td>Forward &amp; Deferred Rendering</td></tr>
<tr><td>Universal2D</td><td>URP</td><td>for 2D light</td></tr>
<tr><td>ShadowCaster</td><td>URP</td><td>depth from the perspective of lights</td></tr>
<tr><td>DepthOnly</td><td>URP</td><td>depth from the perspective of a Camera</td></tr>
<tr><td>Meta</td><td>URP</td><td>executes this Pass only when baking lightmaps</td></tr>
<tr><td>SRPDefaultUnlit</td><td>URP (기본값)</td><td>draw an extra Pass  (ex. Outline)</td></tr>
<tr><td>Always</td><td>Built-in</td><td></td></tr>
<tr><td>ForwardAdd</td><td>Built-in</td><td></td></tr>
<tr><td>PrepassBase</td><td>Built-in</td><td></td></tr>
<tr><td>PrepassFinal</td><td>Built-in</td><td></td></tr>
<tr><td>Vertex</td><td>Built-in</td><td></td></tr>
<tr><td>VertexLMRGBM</td><td>Built-in</td><td></td></tr>
<tr><td>VertexLM</td><td>Built-in</td><td></td></tr>
</tbody></table>
</div>
<h2 id="blend"><a class="header" href="#blend">Blend</a></h2>
<ul>
<li>대표적인 Blend 옵션 조합</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>효과</th></tr></thead><tbody>
<tr><td>SrcAlpha</td><td>OneMinusSrcAlpha</td><td>Alpha Blend</td></tr>
<tr><td>One</td><td>One</td><td>Additive(Without alpha, black is Transparent)</td></tr>
<tr><td>SrcAlpha</td><td>One</td><td>Additive(With Alpha)</td></tr>
<tr><td>One</td><td>OneMinusDstColor</td><td>Soft Additive</td></tr>
<tr><td>DstColor</td><td>Zero</td><td>Multiplicative</td></tr>
<tr><td>DstColor</td><td>SrcColor</td><td>2x Multiplicative</td></tr>
</tbody></table>
</div>
<h2 id="offset"><a class="header" href="#offset">Offset</a></h2>
<pre><code class="language-hlsl">Offset Factor, Units
</code></pre>
<p>Factor 및 units 파라미터 2개를 사용하여 뎁스 오프셋을 지정. Factor 는 폴리곤의 X 또는 Y를 기준으로 최대 Z 기울기를 스케일하고 units 는 최소 분석 가능 뎁스 버퍼 값을 스케일 하게된다.이를 통해 두개의 오브젝트가 겹칠경우 특정 오브젝트를 앞에 그리게 조절할 수 있다.</p>
<h2 id="alphatomask"><a class="header" href="#alphatomask">AlphaToMask</a></h2>
<pre><code class="language-hlsl">AlphaToMask On
</code></pre>
<p>포워드 렌더링을 사용하는 멀티샘플 안티앨리어싱(MSAA, QualitySettings 참조)을 사용하는 경우 알파 투 커버리지 기능을 사용해 알파채널 텍스쳐의 AA를 적용할 수 있다. MSAA 가 메시 외곽에만 AA를 적용하고 알파처럼 텍스쳐 안의 이미지에 대한 AA를 적용할수 없기 때문에 이와 같은 방식으로 AA를 적용한다</p>
<h2 id="hlslprogram"><a class="header" href="#hlslprogram">HLSLPROGRAM</a></h2>
<pre><code class="language-hlsl">HLSLPROGRAM
// https://docs.unity3d.com/Manual/SL-ShaderPrograms.html
#pragma target 3.5

#pragma vertex   &lt;func&gt;
#pragma fragment &lt;func&gt;
#pragma geometry &lt;func&gt; // target 4.0
#pragma hull     &lt;func&gt; // target 5.0
#pragma domain   &lt;func&gt; // target 5.0


#pragma only_renderers      &lt;renderers&gt;
#pragma exclude_renderers   &lt;renderers&gt;
// renderers
// d3d11    |Direct3D 11/12
// glcore   |OpenGL 3.x/4.x
// gles     |OpenGL ES 2.0
// gles3    |OpenGL ES 3.x
// metal    |iOS
// /Mac     |Metal
// vulkan   |Vulkan
// d3d11_9x |Direct3D 11 9.x , as commonly used on WSA platforms
// xboxone  |Xbox One
// ps4      |PlayStation 4
// n3ds     |Nintendo 3DS
// wiiu     |Nintendo Wii U

#pragma multi_compile           ...
#pragma multi_compile_local     ...
#pragma shader_feature          ...
#pragma shader_feature_local    ...
#include 

ENDHLSL
</code></pre>
<h2 id="built-inlegacy"><a class="header" href="#built-inlegacy">Built-in(Legacy)</a></h2>
<pre><code class="language-hlsl">// Built-in(Legacy) 볼필요없는것.

CGINCLUDE
ENDCG

Pass
{
    Lighting On | Off
    Material { Material Block }
    SeparateSpecular On | Off
    Color Color-value
    ColorMaterial AmbientAndDiffuse | Emission

    Fog { Fog Block }

    AlphaTest (Less | Greater | LEqual | GEqual | Equal | NotEqual | Always) CutoffValue

    SetTexture textureProperty { combine options }

    GrabPass { } // _GrabTexture 
    GrabPass { "TextureName" } 

    CGPROGRAM
    #pragma surface surfaceFunction lightModel [optionalparams]


    // https://docs.unity3d.com/Manual/SL-ShaderPrograms.html
    // The following compilation directives don’t do anything and can be safely removed:
    #pragma glsl
    #pragma glsl_no_auto_normalization
    #pragma profileoption
    #pragma fragmentoption

    ENDCG
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="urp-universal-render-pipeline"><a class="header" href="#urp-universal-render-pipeline">URP (Universal Render Pipeline)</a></h1>
<ul>
<li>기존 Built-in(Legacy) 쉐이더의 include 경로 및 함수명등 바뀜</li>
<li>SBR Batcher 사용가능하게 바뀜.</li>
<li>1패스 1라이트방식 =&gt; 1패스 16개 라이트 지원</li>
</ul>
<p>https://unity.com/kr/resources/introduction-universal-render-pipeline-for-advanced-unity-creators-2022lts</p>
<h2 id="sample-1"><a class="header" href="#sample-1">sample</a></h2>
<pre><code class="language-hlsl">Varyings OUT;
ZERO_INITIALIZE(Varyings, OUT);

OUT.positionCS    = TransformObjectToHClip(IN.positionOS.xyz);
OUT.positionWS    = TransformObjectToWorld(IN.positionOS.xyz);
OUT.N             = TransformObjectToWorldNormal(IN.normal);
OUT.uv            = TRANSFORM_TEX(IN.uv, _MainTex);
OUT.fogCoord      = ComputeFogFactor(IN.positionOS.z);          // float
OUT.shadowCoord   = TransformWorldToShadowCoord(OUT.positionWS);// float4
</code></pre>
<pre><code class="language-hlsl">VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);
OUT.shadowCoord = GetShadowCoord(vertexInput);
</code></pre>
<pre><code class="language-hlsl">Light mainLight = GetMainLight();
Light mainLight = GetMainLight(shadowCoord);

half3 ambient = SampleSH(IN.normal);

half3 cameraWS = GetCameraPositionWS();
</code></pre>
<pre><code class="language-hlsl">// GPU instancing
#pragma multi_compile_instancing

// Fog
#pragma multi_compile_fog

// Light &amp; Shadow
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
#pragma multi_compile _ _ADDITIONAL_LIGHTS
#pragma multi_compile _ _ADDITIONAL_LIGHTS_CASCADE
#pragma multi_compile _ _SHADOWS_SOFT

// LightMap
#pragma multi_compile _ DIRLIGHTMAP_COMBINED
#pragma multi_compile _ LIGHTMAP_ON
</code></pre>
<h2 id="sbr-batcher--gpu인스턴싱"><a class="header" href="#sbr-batcher--gpu인스턴싱">SBR Batcher / GPU인스턴싱</a></h2>
<p>SRP Batcher가 추가됨으로써, 동적오브젝트가 많아져도 좋은 퍼포먼스 유지하는게</p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/GPUInstancing.html">https://docs.unity3d.com/Manual/GPUInstancing.html</a></li>
</ul>
<pre><code class="language-hlsl">// For SRP Batcher

CBUFFER_START(UnityPerMaterial)
...
CBUFFER_END
</code></pre>
<pre><code class="language-hlsl">// for GPU instancing

struct Attributes
{
    UNITY_VERTEX_INPUT_INSTANCE_ID
};

struct Varyings
{
    UNITY_VERTEX_INPUT_INSTANCE_ID
    UNITY_VERTEX_OUTPUT_STEREO // for VR
};

Varyings vert(Attributes IN)
{
    Varyings OUT;
    UNITY_SETUP_INSTANCE_ID(IN);
    UNITY_TRANSFER_INSTANCE_ID(IN, OUT); 
};

half4 frag(Varyings IN) : SV_Target
{
    UNITY_SETUP_INSTANCE_ID(IN); 
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>SBR Batcher</th><th>GPU Instancing</th></tr></thead><tbody>
<tr><td>동일한 메쉬 아니여도 가능</td><td>동일한 메쉬 상태</td></tr>
<tr><td>CBUFFER_START // CBUFFER_END</td><td>UNITY_INSTANCING_BUFFER_START // UNITY_INSTANCING_BUFFER_END</td></tr>
</tbody></table>
</div>
<h2 id="hlsl"><a class="header" href="#hlsl">hlsl</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Core.hlsl</td><td>VertexPositionInputs, 스크린 UV, 포그</td></tr>
<tr><td>Common.hlsl</td><td>각종 수학관련 구현, Texture유틸, 뎁스계산 등</td></tr>
<tr><td>Lighting.hlsl</td><td>라이트구조체, Diffuse, Specular, GI(SH, lightmap)</td></tr>
<tr><td>Shadows.hlsl</td><td>쉐도우맵 샘플링, 케스케이드 계산, ShadowCoord, Shadow Bias</td></tr>
<tr><td>SpaceTransform.hlsl</td><td>각종 공간변환 행렬 정의</td></tr>
<tr><td>EntityLighting.hlsl</td><td>SH, ProveVolume, Lightmap</td></tr>
<tr><td>ImageBasedLighting.hlsl</td><td>PBRjcnt IBL관련된 부분(GGX, Anisotropy, ImportanceSample 등)</td></tr>
</tbody></table>
</div>
<h2 id="comunityrender-pipelinescoreshaderlibrary"><a class="header" href="#comunityrender-pipelinescoreshaderlibrary">com.unity.render-pipelines.core/ShaderLibrary</a></h2>
<h3 id="commonhlsl"><a class="header" href="#commonhlsl">Common.hlsl</a></h3>
<pre><code class="language-hlsl">// com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl

#elif defined(SHADER_API_D3D11)
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/API/D3D11.hlsl"
</code></pre>
<h2 id="macroshlsl"><a class="header" href="#macroshlsl">Macros.hlsl</a></h2>
<pre><code class="language-hlsl">// com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl

#define PI          3.14159265358979323846 // PI
#define TWO_PI      6.28318530717958647693 // 2 * PI
#define FOUR_PI     12.5663706143591729538 // 4 * PI
#define INV_PI      0.31830988618379067154 // 1 / PI
#define INV_TWO_PI  0.15915494309189533577 // 1 / (2 * PI)
#define INV_FOUR_PI 0.07957747154594766788 // 1 / (4 * PI)
#define HALF_PI     1.57079632679489661923 // PI / 2
#define INV_HALF_PI 0.63661977236758134308 // 2 / PI
#define LOG2_E      1.44269504088896340736 // log2e
#define INV_SQRT2   0.70710678118654752440 // 1 / sqrt(2)
#define PI_DIV_FOUR 0.78539816339744830961 // PI / 4

#define TRANSFORM_TEX(tex, name) ((tex.xy) * name##_ST.xy + name##_ST.zw)
#define GET_TEXELSIZE_NAME(name) (name##_TexelSize)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name##_ST</th><th>texture space 정보</th></tr></thead><tbody>
<tr><td>x</td><td>Tiling X</td></tr>
<tr><td>y</td><td>Tiling Y</td></tr>
<tr><td>z</td><td>Offset X</td></tr>
<tr><td>w</td><td>Offset Y</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>name##_TexelSize</th><th>텍스처의 크기 정보</th></tr></thead><tbody>
<tr><td>x</td><td>1.0/width</td></tr>
<tr><td>y</td><td>1.0/height</td></tr>
<tr><td>z</td><td>width</td></tr>
<tr><td>w</td><td>height</td></tr>
</tbody></table>
</div>
<pre><code class="language-txt">(U ,V)

V
(0,1)       (1,1)
   +----+----+
   |    |    |
   +----+----+
   |    |    |
   +----+----+
(0,0)       (1,0) U
</code></pre>
<h2 id="apirendererhlsl"><a class="header" href="#apirendererhlsl">API/(renderer).hlsl</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>tex2D</td><td>SAMPLE_TEXTURE2D</td></tr>
<tr><td>tex2Dlod</td><td>SAMPLE_TEXTURE2D_LOD</td></tr>
<tr><td>texCUBE</td><td>SAMPLE_TEXCUBE</td></tr>
<tr><td>texCUBElod</td><td>SAMPLE_TEXCUBE_LOD</td></tr>
</tbody></table>
</div>
<pre><code class="language-hlsl">// com.unity.render-pipelines.core/ShaderLibrary/API/D3D11.hlsl

#define CBUFFER_START(name) cbuffer name {
#define CBUFFER_END };

#define ZERO_INITIALIZE(type, name) name = (type)0;


#define TEXTURE2D(textureName)                Texture2D textureName
#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName
#define TEXTURECUBE(textureName)              TextureCube textureName
#define SAMPLER(samplerName)                  SamplerState samplerName

#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)
#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)

#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))
#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)

#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)
#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)

#define SAMPLE_DEPTH_TEXTURE(textureName, samplerName, coord2)          SAMPLE_TEXTURE2D(textureName, samplerName, coord2).r
#define SAMPLE_DEPTH_TEXTURE_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod).r
</code></pre>
<h3 id="packinghlsl"><a class="header" href="#packinghlsl">Packing.hlsl</a></h3>
<pre><code class="language-hlsl">// com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl
real3 UnpackNormal(real4 packedNormal)
</code></pre>
<h2 id="comunityrender-pipelinesuniversalshaderlibrary"><a class="header" href="#comunityrender-pipelinesuniversalshaderlibrary">com.unity.render-pipelines.universal/ShaderLibrary/</a></h2>
<h3 id="universalshaderlibrarycorehlsl"><a class="header" href="#universalshaderlibrarycorehlsl">universal/ShaderLibrary/Core.hlsl</a></h3>
<pre><code class="language-hlsl">#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"

struct VertexPositionInputs
{
    float3 positionWS; // World space position
    float3 positionVS; // View space position
    float4 positionCS; // Homogeneous clip space position
    float4 positionNDC;// Homogeneous normalized device coordinates
};


struct VertexNormalInputs
{
    real3 tangentWS;
    real3 bitangentWS;
    float3 normalWS;
};

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl"
</code></pre>
<h3 id="shadervariablesfunctionshlsl"><a class="header" href="#shadervariablesfunctionshlsl">ShaderVariablesFunctions.hlsl</a></h3>
<pre><code class="language-hlsl">// com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl

VertexPositionInputs GetVertexPositionInputs(float3 positionOS)
{
    VertexPositionInputs input;
    input.positionWS = TransformObjectToWorld(positionOS);
    input.positionVS = TransformWorldToView(input.positionWS);
    input.positionCS = TransformWorldToHClip(input.positionWS);

    float4 ndc = input.positionCS * 0.5f;
    input.positionNDC.xy = float2(ndc.x, ndc.y * _ProjectionParams.x) + ndc.w;
    input.positionNDC.zw = input.positionCS.zw;

    return input;
}

VertexNormalInputs GetVertexNormalInputs(float3 normalOS)
VertexNormalInputs GetVertexNormalInputs(float3 normalOS, float4 tangentOS)

float3 GetCameraPositionWS()

float3 GetWorldSpaceViewDir(float3 positionWS)

real ComputeFogFactor(float z)

half3 MixFog(half3 fragColor, half fogFactor)

half LinearDepthToEyeDepth(half rawDepth)
</code></pre>
<h3 id="spacetransformshlsl"><a class="header" href="#spacetransformshlsl">SpaceTransforms.hlsl</a></h3>
<pre><code class="language-hlsl">// com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl

float3 TransformObjectToWorld(float3 positionOS) // OS &gt; WS
float4 TransformObjectToHClip(float3 positionOS) // OS &gt; HCS

float3 TransformWorldToView(float3 positionWS)   // WS &gt; VS
float4 TransformWViewToHClip(float3 positionVS)  // VS &gt; HCS

float3 TransformWorldToObject(float3 positionWS) // WS &gt; OS

float3 TransformObjectToWorldDir(float3 dirOS, bool doNormalize = true) // normalOS &gt; normalWS

</code></pre>
<h2 id="varaiable"><a class="header" href="#varaiable">Varaiable</a></h2>
<div class="table-wrapper"><table><thead><tr><th><a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">_ProjectionParams</a></th><th></th></tr></thead><tbody>
<tr><td>x</td><td>1.0 (or –1.0 flipped projection matrix)</td></tr>
<tr><td>y</td><td>near plane</td></tr>
<tr><td>z</td><td>far plane</td></tr>
<tr><td>w</td><td>1/FarPlane</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">_ZBufferParams</a></th><th></th></tr></thead><tbody>
<tr><td>x</td><td>1 - far/near</td></tr>
<tr><td>y</td><td>far / near</td></tr>
<tr><td>z</td><td>x / far</td></tr>
<tr><td>w</td><td>y / far</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>_Time</th><th>Time since level load</th></tr></thead><tbody>
<tr><td>x</td><td>t / 20</td></tr>
<tr><td>y</td><td>t</td></tr>
<tr><td>z</td><td>t * 2</td></tr>
<tr><td>w</td><td>t * 3</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>_SinTime</th><th>Sine of time</th></tr></thead><tbody>
<tr><td>x</td><td>t / 8</td></tr>
<tr><td>y</td><td>t / 4</td></tr>
<tr><td>z</td><td>t / 2</td></tr>
<tr><td>w</td><td>t</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>_CosTime</th><th>Cosine of time</th></tr></thead><tbody>
<tr><td>x</td><td>t / 8</td></tr>
<tr><td>y</td><td>t / 4</td></tr>
<tr><td>z</td><td>t / 2</td></tr>
<tr><td>w</td><td>t</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>unity_DeltaTime</th><th>Delta time</th></tr></thead><tbody>
<tr><td>x</td><td>dt</td></tr>
<tr><td>y</td><td>1 / dt</td></tr>
<tr><td>z</td><td>smoothDt</td></tr>
<tr><td>w</td><td>1 / smoothDt</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="cheatsheet"><a class="header" href="#cheatsheet">CheatSheet</a></h1>
<ul>
<li>based on <a href="https://gist.github.com/Split82/d1651403ffb05e912d9c3786f11d6a44">[built-in] UnityShadersCheatSheet.shader</a></li>
</ul>
<pre><code class="language-hlsl">// Cheetsheet for URP

// ref: https://docs.unity3d.com/Manual/SL-Shader.html
Shader "Name"
{
    HLSLINCLUDE
    // ...
    ENDHLSL

    // ref: https://docs.unity3d.com/Manual/SL-Properties.html
    Properties
    {
        _Name ("display name", Float)               = number
        _Name ("display name", Int)                 = number
        _Name ("display name", Range (min, max))    = number
        _Name ("display name", Color)               = (number,number,number,number)
        _Name ("display name", Vector)              = (number,number,number,number)

        _Name ("display name", 2D)      = "default-ColorString" {} // power of 2
        _Name ("display name", Rect)    = "default-ColorString" {} // non-power of 2
        _Name ("display name", Cube)    = "default-ColorString" {}
        _Name ("display name", 3D)      = "default-ColorString" {}

        // ## Property Attribute
        // ref: https://docs.unity3d.com/ScriptReference/MaterialPropertyDrawer.html
        // |                                                                          |                                                                                                                                                                                                     |
        // | ------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
        // | [HideInInspector]                                                        | 머테리얼 인스펙터에서 표시안함                                                                                                                                                                      |
        // | [NoScaleOffset]                                                          | 텍스쳐의 tiling/offset 필드를 표시안함                                                                                                                                                              |
        // | [Normal]                                                                 | 텍스쳐 설정 normal아니면 경고                                                                                                                                                                       |
        // | [HDR]                                                                    | 텍스쳐 설정 HDR 아니면 경고                                                                                                                                                                         |
        // | [Gamma]                                                                  | indicates that a float/vector property is specified as sRGB value in the UI (just like colors are), and possibly needs conversion according to color space used. See Properties in Shader Programs. |
        // | [PerRendererData]                                                        | indicates that a texture property will be coming from per-renderer data in the form of a MaterialPropertyBlock. Material inspector changes the texture slot UI for these properties.                |
        // | [Toggle]                                                                 |                                                                                                                                                                                                     |
        // | [Toggle(ENABLE_FANCY)] _Fancy ("Fancy?", Float) = 0                      | Will set "ENABLE_FANCY" shader keyword when set.                                                                                                                                                    |
        // | [ToggleOff]                                                              |                                                                                                                                                                                                     |
        // | [ToggleOff(DISABLE_EXAMPLE_FEATURE)]                                     |                                                                                                                                                                                                     |
        // | [Enum(UnityEngine.Rendering.BlendMode)] _Blend ("Blend mode", Float) = 1 | blend modes selection.                                                                                                                                                                              |
        // | [Enum(UnityEngine.Rendering.CompareFunction)] _ZTest("ZTest", Float) = 0 |                                                                                                                                                                                                     |
        // | [Enum(UnityEngine.Rendering.CullMode)] _CullMode("Cull Mode", Int) = 0   |                                                                                                                                                                                                     |
        // | [KeywordEnum(None, Add, Multiply)] _Overlay ("Overlay mode", Float) = 0  | Display a popup with None,Add,Multiply choices. Each option will set _OVERLAY_NONE, _OVERLAY_ADD, _OVERLAY_MULTIPLY shader keywords.                                                                |
        // | [MainTexture]                                                            |                                                                                                                                                                                                     |
        // | [MainColor]                                                              |                                                                                                                                                                                                     |
        // | [Header(A group of things)]                                              |                                                                                                                                                                                                     |
        // | [PowerSlider(3.0)]                                                       |                                                                                                                                                                                                     |
        // | [IntRange]                                                               |                                                                                                                                                                                                     |
        
        // Later on in the shader’s fixed function parts, property values can be accessed using property name in square brackets: [name] e.g. Blend [_SrcBlend] [_DstBlend].

        // ## ColorString
        // "red"
        // "black"         ""
        // "white"
        // "gray"          "grey"
        // "linearGray"    "linearGrey"
        // "grayscaleRamp" "greyscaleRamp"
        // "bump"
        // "blackCube"
        // "lightmap"
        // "unity_Lightmap"
        // "unity_LightmapInd"
        // "unity_ShadowMask"
        // "unity_DynamicLightmap"
        // "unity_DynamicDirectionality"
        // "unity_DynamicNormal"
        // "unity_DitherMask"
        // "_DitherMaskLOD"
        // "_DitherMaskLOD2D"
        // "unity_RandomRotation16"
        // "unity_NHxRoughness"
        // "unity_SpecCube0"
        // "unity_SpecCube1"
    }

    // ref: https://docs.unity3d.com/Manual/SL-SubShader.html
    SubShader
    {
        // ref: https://docs.unity3d.com/Manual/SL-SubShaderTags.html
        Tags
        {
            "TagName1" = "Value1"
            "TagName2" = "Value2"
        }

        // Queue tag: 렌더링 순서 지정. `Geometry+1`, `Geometry-1` 과 같이 가중치 적용가능
        // | Queue       | [min,  max]   | default | order                | etc                      |
        // | ----------- | ------------- | ------- | -------------------- | ------------------------ |
        // | Background  | [0    , 1499] | 100     | render first -&gt; back |                          |
        // | &lt;Geometry&gt;  | [1500 , 2399] | 2000    |                      | Opaque는 이쪽에          |
        // | AlphaTest   | [2400 , 2699] | 2450    |                      | AlphaTest는 이쪽에       |
        // | Transparent | [2700 , 3599] | 3000    | render back -&gt; front | AlphaBlend는 이쪽에      |
        // | Overlay     | [3600 , 5000] | 4000    | render last -&gt; front |                          |

        // RenderType tag : 그룹을 짓는것. 해당 그룹의 셰이더를 바꿔 랜더링 할 수 있음.
        
        // | RenderType        |                                            |
        // | ----------------- | ------------------------------------------ |
        // | Background        | Skybox 쉐이더                              |
        // | Opaque            | 대부분의 쉐이더                            |
        // | TransparentCutout | 마스킹 된 투명 쉐이더(2pass 식물쉐이더 등) |
        // | Transparent       | 투명한 쉐이더                              |
        // | Overlay           | 후광(Halo), 플레어(Flare)                  |

        // 기타 SubShader의 Tags
        // "DisableBatching"      = "(True | &lt;False&gt; | LODFading)"
        // "ForceNoShadowCasting" = "(True | &lt;False&gt;)"
        // "CanUseSpriteAtlas"    = "(&lt;True&gt; | False)"
        // "PreviewType"          = "(&lt;Sphere&gt; | Plane | Skybox)"

        // ref: https://docs.unity3d.com/Manual/SL-ShaderLOD.html
        LOD &lt;lod-number&gt;

        // ref: https://docs.unity3d.com/Manual/SL-UsePass.html
        // 주어진 이름의 셰이더의 (첫번째 SubShader의) 모든 패스들이 삽입됨.
        UsePass "Shader/Name"

        // ref: https://docs.unity3d.com/Manual/SL-Pass.html
        Pass
        {
            Name "Pass Name"

            // ref: https://docs.unity3d.com/Manual/SL-PassTags.html
            // 주의. `Pass의 Tag`는 `SubShader의 Tag`랑 다름
            Tags
            {
                "TagName1" = "Value1"
                "TagName2" = "Value2"
            }

            // LightMode tag : 
            // | LightMode            |                                               |
            // | -------------------- | --------------------------------------------- |
            // | &lt;SRPDefaultUnlit&gt;    | draw an extra Pass  (ex. Outline)    |
            // | UniversalForward     | Forward Rendering                             |
            // | UniversalGBuffer     | Deferred Rendering                            |
            // | UniversalForwardOnly | Forward &amp; Deferred Rendering                  |
            // | Universal2D          | for 2D light                                  |
            // | ShadowCaster         | depth from the perspective of lights          |
            // | DepthOnly            | depth from the perspective of a Camera        |
            // | Meta                 | executes this Pass only when baking lightmaps |

            // ref: https://docs.unity3d.com/Manual/SL-Stencil.html
            Stencil
            {
            }

            // ## Render 설정 (기본값 &lt;&gt;)
            // ref: https://docs.unity3d.com/Manual/SL-CullAndDepth.html
            // ref: https://docs.unity3d.com/Manual/SL-Blend.html
            Cull      (&lt;Back&gt; | Front | Off)
            ZTest     (Less | Greater | &lt;LEqual&gt; | GEqual | Equal | NotEqual | Always)
            ZWrite    (&lt;On&gt; | Off)
            Blend     SourceBlendMode DestBlendMode
            Blend     SourceBlendMode DestBlendMode, AlphaSourceBlendMode AlphaDestBlendMode
            ColorMask (RGB | A | 0 | any combination of R, G, B, A)
            Offset    OffsetFactor, OffsetUnits

            HLSLPROGRAM
            #pragma vertex   name // compile function name as the vertex shader.
            #pragma fragment name // compile function name as the fragment shader.
            #pragma geometry name // compile function name as DX10 geometry shader. Having this option automatically turns on #pragma target 4.0, described below.
            #pragma hull     name // compile function name as DX11 hull shader. Having this option automatically turns on #pragma target 5.0, described below.
            #pragma domain   name // compile function name as DX11 domain shader. Having this option automatically turns on #pragma target 5.0, described below.

            // Other compilation directives:
            // #pragma target            name                  - which shader target to compile to. See Shader Compilation Targets page for details.
            // #pragma only_renderers    space separated names - compile shader only for given renderers. By default shaders are compiled for all renderers. See Renderers below for details.
            // #pragma exclude_renderers space separated names - do not compile shader for given renderers. By default shaders are compiled for all renderers. See Renderers below for details.
            // #pragma enable_d3d11_debug_symbols              - generate debug information for shaders compiled for DirectX 11, this will allow you to debug shaders via Visual Studio 2012 (or higher) Graphics debugger.
            // #pragma multi_compile_instancing
            // #pragma multi_compile_fog
            // #pragma multi_compile                           - for working with multiple shader variants.
            //         multi_compile_local
            //         multi_compile_vertex
            //         multi_compile_vertex_local
            //         multi_compile_fragment
            //         multi_compile_fragment_local
            // #pragma shader_feature                          - for working with multiple shader variants. (unused variants of shader_feature shaders will not be included into game build)
            //         shader_feature_local
            //         shader_feature_vertex
            //         shader_feature_vertex_local
            //         shader_feature_fragment
            //         shader_feature_fragment_local
            
          
            // | Property | Variable                                    |
            // | -------- | ------------------------------------------- |
            // | Float    | float _Name;                                |
            // | Int      | float _Name;                                |
            // | Range    | float _Name;                                |
            // | Color    | float _Name;                                |
            // | Vector   | float _Name;                                |
            // | 2D       | TEXTURE2D(_Name);    SAMPLER(sampler_Name); |
            // | Rect     | TEXTURE2D(_Name);    SAMPLER(sampler_Name); |
            // | Cube     | TEXTURECUBE(_Name);  SAMPLER(sampler_Name); |
            // | 3D       | TEXTURE3D(_Name);    SAMPLER(sampler_Name); |

            // 간단한 Vertex/Fragment Shader 예제.
            TEXTURE2D(_MainTex);    SAMPLER(sampler_MainTex);

            struct APPtoVS
            {
                float4 positionOS   : POSITION;
                float3 normalOS     : NORMAL;
                float4 colorVertex  : COLOR;
                float2 uv           : TEXCOORD0;
            };

            struct VStoFS
            {
                float4 positionCS   : SV_POSITION;
                float2 uv           : TEXCOORD0;
            };

            VStoFS vert(APPtoVS IN)
            {
                VStoFS OUT;
                ZERO_INITIALIZE(VStoFS, OUT);

                OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.uv = TRANSFORM_TEX(IN.uv, _MainTex);

                return OUT;
            }

            half4 frag(VStoFS IN) : SV_Target
            {
                half4 mainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
                return mainTex;
            }

            // 멀티타겟용 (Deferred)
            void frag(    VStoFS IN,
                      out half4  outDiffuse        : SV_Target0,
                      out half4  outSpecSmoothness : SV_Target1,
                      out half4  outNormal         : SV_Target2,
                      out half4  outEmission       : SV_Target3)
            {
                // ...
            }
            ENDHLSL
        }
    }

    // ref : https://docs.unity3d.com/Manual/SL-Fallback.html
    Fallback "Diffuse"

    // ref: https://docs.unity3d.com/Manual/SL-CustomEditor.html
    // ref: https://docs.unity3d.com/Manual/SL-CustomMaterialEditors.html
    CustomEditor &lt;custom-editor-class-name&gt;
}
</code></pre>
<h2 id="etc-2"><a class="header" href="#etc-2">Etc</a></h2>
<pre><code>#define UNITY_BRANCH        [branch]
#define UNITY_FLATTEN       [flatten]
#define UNITY_UNROLL        [unroll]
#define UNITY_UNROLLX(_x)   [unroll(_x)]
#define UNITY_LOOP          [loop]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="urp-and-builtin"><a class="header" href="#urp-and-builtin">URP and Builtin</a></h1>
<ul>
<li><a href="https://teodutra.com/unity/shaders/urp/graphics/2020/05/18/From-Built-in-to-URP/">Teo Dutra's From Built-in To URP</a></li>
</ul>
<p>URP</p>
<ul>
<li><a href="https://github.com/Unity-Technologies/UniversalRenderingExamples">https://github.com/Unity-Technologies/UniversalRenderingExamples</a></li>
<li><a href="https://github.com/phi-lira/UniversalShaderExamples">https://github.com/phi-lira/UniversalShaderExamples</a></li>
</ul>
<h2 id="include"><a class="header" href="#include">include</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Content</th><th>Built-in</th><th>URP</th></tr></thead><tbody>
<tr><td>Core</td><td>Unity.cginc</td><td>com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl</td></tr>
<tr><td>Light</td><td>AutoLight.cginc</td><td>com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl</td></tr>
<tr><td>Shadows</td><td>AutoLight.cginc</td><td>com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl</td></tr>
<tr><td>Surface shaders</td><td>Lighting.cginc</td><td>None, but you can find a side project for this here</td></tr>
</tbody></table>
</div>
<h2 id="variant-keyword"><a class="header" href="#variant-keyword">Variant Keyword</a></h2>
<ul>
<li><a href="https://blogs.unity3d.com/2018/05/14/stripping-scriptable-shader-variants/">https://blogs.unity3d.com/2018/05/14/stripping-scriptable-shader-variants/</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>_MAIN_LIGHT_SHADOWS</td><td></td></tr>
<tr><td>_MAIN_LIGHT_SHADOWS_CASCADE</td><td></td></tr>
<tr><td>_ADDITIONAL_LIGHTS_VERTEX</td><td></td></tr>
<tr><td>_ADDITIONAL_LIGHTS</td><td></td></tr>
<tr><td>_ADDITIONAL_LIGHT_SHADOWS</td><td></td></tr>
<tr><td>_SHADOWS_SOFT</td><td></td></tr>
<tr><td>_MIXED_LIGHTING_SUBTRACTIVE</td><td></td></tr>
</tbody></table>
</div>
<h2 id="macro"><a class="header" href="#macro">Macro</a></h2>
<div class="table-wrapper"><table><thead><tr><th>built-in</th><th>URP</th></tr></thead><tbody>
<tr><td>UNITY_PROJ_COORD (a)</td><td>없음, 대신 a.xy / a.w 사용</td></tr>
<tr><td>UNITY_INITIALIZE_OUTPUT(type, name)</td><td>ZERO_INITIALIZE (type, name)</td></tr>
</tbody></table>
</div>
<h2 id="shadow-1"><a class="header" href="#shadow-1">Shadow</a></h2>
<p>Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl</p>
<div class="table-wrapper"><table><thead><tr><th>Built-in</th><th>URP</th></tr></thead><tbody>
<tr><td>UNITY_DECLARE_SHADOWMAP(tex)</td><td>TEXTURE2D_SHADOW_PARAM(textureName, samplerName)</td></tr>
<tr><td>UNITY_SAMPLE_SHADOW(tex, uv)</td><td>SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)</td></tr>
<tr><td>UNITY_SAMPLE_SHADOW_PROJ(tex, uv)</td><td>SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord4.xyz/coord4.w)</td></tr>
<tr><td>TRANSFER_SHADOW</td><td>TransformWorldToShadowCoord</td></tr>
<tr><td>UNITY_SHADOW_COORDS(x)</td><td>x</td></tr>
<tr><td>SHADOWS_SCREEN</td><td>x</td></tr>
<tr><td></td><td>GetShadowCoords</td></tr>
</tbody></table>
</div>
<h2 id="fog"><a class="header" href="#fog">Fog</a></h2>
<p>com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl</p>
<div class="table-wrapper"><table><thead><tr><th>Built-in</th><th>URP</th></tr></thead><tbody>
<tr><td>UNITY_TRANSFER_FOG(o, outpos)</td><td>o.fogCoord = ComputeFogFactor(clipSpacePosition.z);</td></tr>
<tr><td>UNITY_APPLY_FOG(coord, col)</td><td>color = MixFog(color, i.fogCoord);</td></tr>
<tr><td>UNITY_FOG_COORDS(x)</td><td>x</td></tr>
</tbody></table>
</div>
<h2 id="texturesampler-declaration-macros"><a class="header" href="#texturesampler-declaration-macros">Texture/Sampler Declaration Macros</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Built-in</th><th>URP</th></tr></thead><tbody>
<tr><td>UNITY_DECLARE_TEX2D(name)</td><td>TEXTURE2D(textureName); SAMPLER(samplerName);</td></tr>
<tr><td>UNITY_DECLARE_TEX2D_NOSAMPLER(name)</td><td>TEXTURE2D(textureName);</td></tr>
<tr><td>UNITY_DECLARE_TEX2DARRAY(name)</td><td>TEXTURE2D_ARRAY(textureName); SAMPLER(samplerName);</td></tr>
<tr><td>UNITY_SAMPLE_TEX2D(name, uv)</td><td>SAMPLE_TEXTURE2D(textureName, samplerName, coord2)</td></tr>
<tr><td>UNITY_SAMPLE_TEX2D_SAMPLER(name, samplername, uv)</td><td>SAMPLE_TEXTURE2D(textureName, samplerName, coord2)</td></tr>
<tr><td>UNITY_SAMPLE_TEX2DARRAY(name, uv)</td><td>SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)</td></tr>
<tr><td>UNITY_SAMPLE_TEX2DARRAY_LOD(name, uv, lod)</td><td>SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)</td></tr>
</tbody></table>
</div>
<p>Important to note that SCREENSPACE_TEXTURE has become TEXTURE2D_X. If you are working on some screen space effect for VR in Single Pass Instanced or Multi-view modes, you must declare the textures used with TEXTURE2D_X. This macro will handle for you the correct texture (array or not) declaration. You also have to sample the textures using SAMPLE_TEXTURE2D_X and use UnityStereoTransformScreenSpaceTex for the uv.</p>
<h2 id="helper"><a class="header" href="#helper">Helper</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Built-in</th><th>URP</th><th></th></tr></thead><tbody>
<tr><td>fixed Luminance (fixed3 c)</td><td>Luminance</td><td>com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl</td></tr>
<tr><td>fixed3 DecodeLightmap (fixed4 color)</td><td>DecodeLightmap</td><td>com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl</td></tr>
<tr><td>float4 EncodeFloatRGBA (float v)</td><td>X</td><td></td></tr>
<tr><td>float DecodeFloatRGBA (float4 enc)</td><td>X</td><td></td></tr>
<tr><td>float2 EncodeFloatRG (float v)</td><td>X</td><td></td></tr>
<tr><td>float DecodeFloatRG (float2 enc)</td><td>X</td><td></td></tr>
<tr><td>float2 EncodeViewNormalStereo (float3 n)</td><td>X</td><td></td></tr>
<tr><td>float3 DecodeViewNormalStereo (float4 enc4)</td><td>X</td><td></td></tr>
</tbody></table>
</div>
<p>decodeInstructions is used as half4(LIGHTMAP_HDR_MULTIPLIER, LIGHTMAP_HDR_EXPONENT, 0.0h, 0.0h) by URP</p>
<h2 id="lighting"><a class="header" href="#lighting">Lighting</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Built-in</th><th>URP</th><th></th></tr></thead><tbody>
<tr><td>WorldSpaceLightDir</td><td>TransformObjectToWorld(objectSpacePosition)</td><td>com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl</td></tr>
<tr><td>ObjSpaceLightDir</td><td>TransformWorldToObject(_MainLightPosition.xyz)</td><td>com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl</td></tr>
<tr><td>float3 Shade4PointLights</td><td>x</td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-txt">URP -_MainLightPosition.xyz 
URP - half3 VertexLighting(float3 positionWS, half3 normalWS) - com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl
If you want to loop over all additional lights using GetAdditionalLight(...), you can query the additional lights count by using GetAdditionalLightsCount().

Built-in	URP	 
_LightColor0	_MainLightColor	Include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl”
_WorldSpaceLightPos0	_MainLightPosition	Include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl”
_LightMatrix0	Gone ? Cookies are not supported yet	 
unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0	In URP, additional lights are stored in an array/buffer (depending on platform). Retrieve light information using Light GetAdditionalLight(uint i, float3 positionWS)	Include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl”
unity_4LightAtten0	In URP, additional lights are stored in an array/buffer (depending on platform). Retrieve light information using Light GetAdditionalLight(uint i, float3 positionWS)	Include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl”
unity_LightColor	In URP, additional lights are stored in an array/buffer (depending on platform). Retrieve light information using Light GetAdditionalLight(uint i, float3 positionWS)	Include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl”
unity_WorldToShadow	float4x4 _MainLightWorldToShadow[MAX_SHADOW_CASCADES + 1] or _AdditionalLightsWorldToShadow[MAX_VISIBLE_LIGHTS]	Include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl

</code></pre>
<p>| LIGHTING_COORDS| x| |</p>
<h2 id="vertex-lit-helper-functions"><a class="header" href="#vertex-lit-helper-functions">Vertex-lit Helper Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Built-in</th><th>URP</th></tr></thead><tbody>
<tr><td>float3 ShadeVertexLights (float4 vertex, float3 normal)</td><td>Gone. You can try to use UNITY_LIGHTMODEL_AMBIENT.xyz + VertexLighting(...)	For VertexLighting(...) include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl”</td></tr>
</tbody></table>
</div>
<p>A bunch of utilities can be found in “Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl”.</p>
<h2 id="screen-space-helper-functions"><a class="header" href="#screen-space-helper-functions">Screen-space Helper Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Built-in</th><th>URP</th></tr></thead><tbody>
<tr><td>float4 ComputeScreenPos (float4 clipPos)</td><td>float4 ComputeScreenPos(float4 positionCS) Include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl”</td></tr>
<tr><td>float4 ComputeGrabScreenPos (float4 clipPos)</td><td>Gone.</td></tr>
</tbody></table>
</div>
<ul>
<li>ComputeScreenPos deprecated - <a href="https://github.com/Unity-Technologies/Graphics/pull/2529">https://github.com/Unity-Technologies/Graphics/pull/2529</a></li>
<li>GetVertexPositionInputs().positionNDC</li>
</ul>
<h2 id="camera-texture"><a class="header" href="#camera-texture">Camera Texture</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>_CameraDepthTexture</td><td>Camera.depthTextureMode</td></tr>
<tr><td>_CameraOpaqueTexture</td><td>GrabPass</td></tr>
</tbody></table>
</div>
<p>fixed depth = SAMPLE_DEPTH_TEXTURE(texture, sampler, uv);</p>
<pre><code class="language-shader">GrabPass
{
    "_GrabPass"
}
sampler2D _GrabPass
fixed4 fGrapPass = tex2Dproj(_GrabPass, i.screenPosition + 0.5f);
</code></pre>
<h2 id="depth-1"><a class="header" href="#depth-1">Depth</a></h2>
<ul>
<li>Built-in	URP</li>
<li>LinearEyeDepth(sceneZ)	LinearEyeDepth(sceneZ, _ZBufferParams)	Include “Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl”</li>
<li>Linear01Depth(sceneZ)	Linear01Depth(sceneZ, _ZBufferParams)	Include “Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl”</li>
</ul>
<p>To use the camera depth texture, include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl” and the _CameraDepthTexture will be declared for you as well as helper the functions SampleSceneDepth(...) and LoadSceneDepth(...).</p>
<h2 id="etc-3"><a class="header" href="#etc-3">etc</a></h2>
<ul>
<li>ShadeSH9(normal)	SampleSH(normal)	Include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl”</li>
<li>unity_ColorSpaceLuminance	Gone. Use Luminance()	Include “Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl”</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Built-in</th><th></th><th></th></tr></thead><tbody>
<tr><td>PerceptualRoughnessToSpecPower</td><td>x</td><td></td></tr>
<tr><td>FresnelTerm</td><td>x</td><td></td></tr>
<tr><td>_SpecColor</td><td>x</td><td></td></tr>
<tr><td>BlendNormals</td><td>x</td><td>CommonMaterial.hlsl</td></tr>
<tr><td>DotClamped</td><td>x</td><td></td></tr>
<tr><td>unity_LightGammaCorrectionConsts_PIDiv4</td><td>x</td><td></td></tr>
<tr><td>UnityGlobalIllumiation</td><td>x</td><td></td></tr>
</tbody></table>
</div>
<hr />
<p>여깃는건 쓰지말것
https://leegoonz.blog/
https://www.alanzucconi.com/tutorials/</p>
<ul>
<li>https://alexanderameye.github.io/outlineshader
https://roystan.net/articles/toon-water.html - 물웅덩이
https://darkcatgame.tistory.com/84
https://www.cyanilux.com/recent/2/</li>
</ul>
<p>https://github.com/hebory?before=Y3Vyc29yOnYyOpK5MjAyMC0xMS0wOVQyMjo0MToyOCswOTowMM4Oqhfn&amp;tab=stars - https://blog.naver.com/cra2yboy/222236607952</p>
<ul>
<li>
<p>툰쉐이더</p>
<ul>
<li>https://musoucrow.github.io/2020/07/05/urp_outline/</li>
<li>https://kink3d.github.io/blog/2017/10/04/Physically-Based-Toon-Shading-In-Unity
<ul>
<li>https://github.com/Kink3d/kShading/blob/master/Shaders/ToonLit.shader</li>
</ul>
</li>
</ul>
</li>
<li>
<p>반사</p>
<ul>
<li>https://github.com/Kink3d/kMirrors</li>
</ul>
</li>
<li>
<p>모션블러</p>
<ul>
<li>https://github.com/Kink3d/kMotion</li>
</ul>
</li>
<li>
<p>월드 스페이스노말</p>
<ul>
<li>https://github.com/Kink3d/kNormals</li>
</ul>
</li>
<li>
<p>Fast Subsurface Scattering in unity</p>
<ul>
<li>https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-2/</li>
</ul>
</li>
<li>
<p>헤어 그림자</p>
<ul>
<li>https://zhuanlan.zhihu.com/p/232450616</li>
</ul>
</li>
</ul>
<p>Bulit-in URP</p>
<p>GammaToLinearSpace Gamma22ToLinear com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postprocess"><a class="header" href="#postprocess">PostProcess</a></h1>
<ul>
<li>Compute 셰이더가 좀 더 빠르지만, 여기선 일단 픽셀 셰이더로 구현하는 걸로.</li>
</ul>
<h2 id="목록"><a class="header" href="#목록">목록</a></h2>
<ul>
<li><a href="Postprocess/Bloom.html">Bloom</a></li>
<li><a href="Postprocess/LightStreak.html">LightStreak</a></li>
<li><a href="Postprocess/EyeAdaptation.html">EyeAdaptation</a></li>
<li><a href="Postprocess/SSAO.html">SSAO</a></li>
<li><a href="Postprocess/_SSGI.html">SSGI</a></li>
<li><a href="Postprocess/_LightShaft_postprocess.html">_LightShaft_postprocess</a></li>
<li><a href="Postprocess/_SSR.html">_SSR</a></li>
</ul>
<h2 id="영역-총합-테이블-summed-area-table"><a class="header" href="#영역-총합-테이블-summed-area-table">영역 총합 테이블 (summed area table)</a></h2>
<ul>
<li>1984 - Frank</li>
<li>GDC2003 - Simon</li>
</ul>
<h2 id="ref-23"><a class="header" href="#ref-23">Ref</a></h2>
<ul>
<li><a href="https://github.com/QianMo/X-PostProcessing-Library">https://github.com/QianMo/X-PostProcessing-Library</a></li>
<li><a href="https://github.com/UWA-MakeItSimple/Course-PostProcessingEffect">https://github.com/UWA-MakeItSimple/Course-PostProcessingEffect</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filter--blur"><a class="header" href="#filter--blur">Filter / Blur</a></h1>
<ul>
<li>포스트프로세스니 ComputeShader와, 어차피 흐려지는 것이니 RenderPipeline을 이용하여 다운샘플링 된걸가지고 하는걸 추천.</li>
</ul>
<pre><code class="language-hlsl">// 조심
// ref: https://docs.unity3d.com/Manual/SL-PlatformDifferences.html
// Flip sampling of the Texture: 
// The main Texture
// texel size will have negative Y).

#if UNITY_UV_STARTS_AT_TOP
if (_MainTex_TexelSize.y &lt; 0)
{
    uv.y = 1-uv.y;
}
#endif
</code></pre>
<h2 id="average--평균값"><a class="header" href="#average--평균값">Average / 평균값</a></h2>
<ul>
<li>Mean Filter라 불리기도함
<ul>
<li>Median Filter도 있는데, 이는 평균값에 너무 벗어난 값은 포함하지 않음.</li>
</ul>
</li>
<li>N * N 블럭</li>
<li>주변 픽셀들을 더하고 평균값으로 칠함.</li>
</ul>
<pre><code class="language-hlsl">// -1, -1 | 0, -1 | +1, -1
// -1,  0 | 0,  0 | +1,  0
// -1, +1 | 0, +1 | +1, +1

// weight
// 1 | 1 | 1
// 1 | 1 | 1
// 1 | 1 | 1
</code></pre>
<h2 id="16-박스"><a class="header" href="#16-박스">16 박스</a></h2>
<ul>
<li>바이너리필터를 이용 4개의 샘플링으로 16개의 텍셀의 평균값을 구함</li>
</ul>
<pre><code class="language-txt">/// 16박스
//   .   | 0,-1 |   .  
// -1, 0 |  .   |  1, 0  
//   .   | 0, 1 |   .  

// weight
// 0 | 1 | 0
// 1 | 0 | 1
// 0 | 1 | 0


/// 64박스
// -2,-2 | -1,-2 | 0,-2 | 1,-2
// -2,-1 | -1,-1 | 0,-1 | 1,-1
// -2, 0 | -1, 0 | 0, 0 | 1, 0
// -2, 1 | -1, 1 | 0, 1 | 1, 1

// weight
// 1 | 1 | 1 | 1
// 1 | 1 | 1 | 1
// 1 | 1 | 1 | 1
</code></pre>
<h2 id="9콘---tent-blur"><a class="header" href="#9콘---tent-blur">9콘 - tent blur</a></h2>
<ul>
<li>바이너리필터를 이용 4개의 샘플링으로 각기다른 가중치를 지닌 9개 텍셀을 얻어옴</li>
</ul>
<pre><code class="language-txt">// 0,  0 | +1,  0
// 0, +1 | +1, +1

// weight
// 1 | 1
// 1 | 1


// 샘플링하면 다음과 같은 9개의 텍셀 가중치를 지니게 된다
// 1 | 2 | 1
// 2 | 4 | 2
// 1 | 2 | 1
</code></pre>
<h2 id="gaussian--가우스"><a class="header" href="#gaussian--가우스">Gaussian / 가우스</a></h2>
<ul>
<li>N * N 블럭</li>
<li>보다 원본 이미지가 잘 살도록, 중심부에 가중치를 더 준다.</li>
</ul>
<pre><code class="language-hlsl">// -1, -1 | 0, -1 | +1, -1
// -1,  0 | 0,  0 | +1,  0
// -1, +1 | 0, +1 | +1, +1

// weight
// Sigma: 1.0 | Kernel Size : 3
// 0.077847 |  0.123317 | 0.077847
// 0.123317 |  0.195346 | 0.123317
// 0.077847 |  0.123317 | 0.077847
</code></pre>
<ul>
<li><a href="http://dev.theomader.com/gaussian-kernel-calculator/">Gaussian Kernel Calculator</a></li>
<li><a href="https://www.sysnet.pe.kr/2/0/11623">https://www.sysnet.pe.kr/2/0/11623</a></li>
<li><a href="https://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">https://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</a></li>
</ul>
<h2 id="two-pass-gaussian-blur"><a class="header" href="#two-pass-gaussian-blur">two-pass Gaussian blur</a></h2>
<p><img src="Postprocess/../res/bloom_gaussian_two_pass.png" alt="bloom_gaussian_two_pass.png" /></p>
<ul>
<li><a href="https://learnopengl.com/Advanced-Lighting/Bloom">https://learnopengl.com/Advanced-Lighting/Bloom</a></li>
<li>가로로 한번 블러먹이고</li>
<li>세로로 한번 블러먹인다</li>
</ul>
<pre><code class="language-txt">ex)

5x5 = 0.38774 , 0.24477  , 0.06136
9x9 = 0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216
</code></pre>
<h2 id="bilateral--쌍방"><a class="header" href="#bilateral--쌍방">Bilateral / 쌍방</a></h2>
<ul>
<li>엣지를 보존하면서 노이즈를 제거</li>
</ul>
<h2 id="kawase--카와세"><a class="header" href="#kawase--카와세">Kawase / 카와세</a></h2>
<ul>
<li>대각선을 샘플.</li>
</ul>
<pre><code class="language-hlsl">// -1, -1 |   -   | +1, -1
//    -   | 0,  0 |    -   
// -1, +1 |   -   | +1, +1

// weight
// 1/8 |  -  | 1/8
//  -  | 1/2 |  - 
// 1/8 |  -  | 1/8
</code></pre>
<ul>
<li><a href="https://github.com/JujuAdams/Kawase">https://github.com/JujuAdams/Kawase</a></li>
<li><a href="https://cedil.cesa.or.jp/cedil_sessions/view/264">CDEDC2009 -  IMAGIRE DAY : 続・レンダリスト養成講座</a></li>
<li><a href="http://genderi.org/frame-buffer-postprocessing-effects-in-double-s-t-e-a-l-wreckl.html">GDC2003 - Frame Buffer Postprocessing Effects in DOUBLE-S.T.E.A.L (Wreckless)</a></li>
<li><a href="https://developer.amd.com/wordpress/media/2012/10/Oat-ScenePostprocessing.pdf">GDC2003 - Real-Time 3D Scene Post-processing</a></li>
<li>https://github.com/nobnak/KawaseLightStreakUnity</li>
</ul>
<h2 id="dual-filter"><a class="header" href="#dual-filter">Dual Filter</a></h2>
<pre><code class="language-hlsl">// DownSampler pos
// -0.5, -0.5 |   -   | +0.5, -0.5
//    -       | 0,  0 |    -   
// -0.5, +0.5 |   -   | +0.5, +0.5

// DownSampler weight
//   1/8  |   -   |   1/8
//    -   |  1/2  |    - 
//   1/8  |   -   |   1/8

// UpSampler pos
//     -   |     -      |   0, -1   |    -       |    -
//     -   | -0.5, -0.5 |     -     | +0.5, -0.5 |    -
//   -1, 0 |     -      |     -     |    -       |  +1, 0
//     -   | -0.5, -0.5 |     -     | +0.5, -0.5 |    -
//     -   |     -      |   0, +1   |    -       |    -

// UpSampler weight
//     -   |     -      |   1/12    |    -       |    -
//     -   |    1/6     |     -     |    1/6     |    -
//   1/12  |     -      |     -     |    -       |   1/12
//     -   |    1/6     |     -     |    1/6     |    -
//     -   |     -      |   1/12    |    -       |    -
</code></pre>
<ul>
<li><a href="https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_notes.pdf">SIGGRAPH2015 - Bandwidth-Efficient Rendering</a></li>
<li><a href="https://github.com/MarcusXie3D/FastBloomForMobiles">https://github.com/MarcusXie3D/FastBloomForMobiles</a>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/126351976">https://zhuanlan.zhihu.com/p/126351976</a></li>
</ul>
</li>
<li><a href="https://developer.arm.com/documentation/102259/0100/Bloom">https://developer.arm.com/documentation/102259/0100/Bloom</a></li>
<li><a href="https://www.youtube.com/watch?v=7mmWPtAoflI">Unite Berlin 2018 - Attaining Post Processing Effects on Mid Range Smartphones</a>
<ul>
<li><a href="https://developer.arm.com/-/media/Files/pdf/graphics-and-multimedia/Unite18_Nordeus_Arm.pdf?revision=3bf9cd9d-08cd-488b-adbd-512899718cba">slide</a></li>
</ul>
</li>
</ul>
<h2 id="radial--방사형"><a class="header" href="#radial--방사형">Radial / 방사형</a></h2>
<ul>
<li>중심에서 원형으로 뻗혀나가는 방사형 블러.</li>
<li>줌(Zoom)되는 효과</li>
<li><a href="https://forum.unity.com/threads/radial-blur.31970/#post-209514">https://forum.unity.com/threads/radial-blur.31970/#post-209514</a></li>
<li><a href="https://blog.naver.com/mnpshino/221478999495">https://blog.naver.com/mnpshino/221478999495</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bloom"><a class="header" href="#bloom">Bloom</a></h1>
<pre><code class="language-txt">- 원본
- 축소 (w/4, h/4)
  - 밝은부분
    - 블러적용
- 원본과 블러적용 더하기
</code></pre>
<ul>
<li>참조 : <a href="Postprocess/./Filter.html">Filter.md</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-21-real-time-glow">[GPU Gems 1] Chapter 21. Real-Time Glow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="color-grading-lut"><a class="header" href="#color-grading-lut">Color Grading LUT</a></h1>
<p>색 보정(Color Grading)에는 여러 수치 보정 수식들이 들어가게 되는데, 이걸 실시간 계산이 아닌 텍스쳐에 구어 연산 부하를 낮출 수 있다.</p>
<ul>
<li>unity: 32x32 가 옆으로 32개 =&gt; 1024 × 32
<ul>
<li><a href="https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.postprocessing/PostProcessing/Textures/LUTs/NeutralLdrLut.png">NeutralLdrLut.png</a></li>
<li>ldr(Low Dynamic Range)</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">// (r,g,b)
// (0,1,0) +----+ (1,1,0)          (0,1,n) +----+ (1,1,n)
//         |    |           ......         |    |        
// (0,0,0) +----+ (1,0,0)          (0,0,n) +----+ (1,0,n)
</code></pre>
<ul>
<li><a href="https://web.archive.org/web/20120213004214/http://ttmayrin.tistory.com/34">http://ttmayrin.tistory.com/34</a></li>
</ul>
<pre><code class="language-hlsl">// 16 기준

float3 CalcLUT2D( sampler InLUT, float3 InColor )
{
    // requires a volume texture 16x16x16 unwrapped in a 2d texture 256x16
    // can be optimized by using a volume texture
    float2 Offset = float2(0.5f / 256.0f, 0.5f / 16.0f);
    float Scale = 15.0f / 16.0f; 

    // Also consider blur value in the blur buffer written by translucency
    float IntB = floor(InColor.b * 14.9999f) / 16.0f;
    float FracB = InColor.b * 15.0f - IntB * 16.0f;

    float U = IntB + InColor.r * Scale / 16.0f;
    float V = InColor.g * Scale;

    float3 RG0 = tex2D( InLUT, Offset + float2(U               , V) ).rgb;
    float3 RG1 = tex2D( InLUT, Offset + float2(U + 1.0f / 16.0f, V) ).rgb;

    return lerp( RG0, RG1, FracB );
}

float3 CalcLUT3D( sampler InLUT, float3 InColor )
{
    return tex3D( InLUT, InColor * 15.f / 16.f + 0.5f / 16.f ).rgb;
}
</code></pre>
<h2 id="색보정-방법"><a class="header" href="#색보정-방법">색보정 방법</a></h2>
<p>채도/대비/샤픈
마젠타/사이언/그린</p>
<ul>
<li><a href="https://youtu.be/ll3HrF4y27w?si=addpL3anqHu0FGep">영화같은 색보정을 위한 가장 중요한 이것</a></li>
<li>하이비드 HYVID STUDIO
<ul>
<li><a href="https://youtu.be/8V_FoVPR9lg?si=iOobuvMnPO3m1YcP">눈대중으로 색보정 그만! 기준을 갖고 하는 색보정 (feat 피부톤)</a></li>
<li><a href="https://youtu.be/H84KGpryPU0?si=4NC9Pudu1jOti1lE">매드맥스 DI 작업자 에릭의 헐리웃 색보정 팁</a></li>
<li><a href="https://youtu.be/H_RhJocZWzE?si=SnCBe8kzJHeUjQhF">존윅 4 개봉!! 시선을 사로잡는 존윅의 색보정 비밀! / DI 작업자 질 보그다노비치 색보정 작업방식</a></li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Zone_System">https://en.wikipedia.org/wiki/Zone_System</a></li>
</ul>
<h2 id="ref-24"><a class="header" href="#ref-24">Ref</a></h2>
<ul>
<li><a href="https://nellfamily.tistory.com/51">DirectX Shader LUT 필터 코드 구현</a></li>
<li><a href="https://youtu.be/0LwlNVS3FJo?t=1087">[Unite Seoul 2019] 최재영 류재성 - 일곱개의 대죄 : "애니메이션의 감성을 그대로＂와 “개발 최적화"</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-24-using-lookup-tables-accelerate-color">[GPU Gems 2] Chapter 24. Using Lookup Tables to Accelerate Color Transformations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="color-space"><a class="header" href="#color-space">Color Space</a></h1>
<ul>
<li>RGB</li>
<li>HSL (for hue, saturation, lightness) and HSV (for hue, saturation, value; also known as HSB, for hue, saturation, brightness)</li>
<li>HCL (Hue-Chroma-Luminance)</li>
<li>YUV</li>
<li>..</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>RGB</th><th></th></tr></thead><tbody>
<tr><td>R</td><td>Red</td></tr>
<tr><td>G</td><td>Green</td></tr>
<tr><td>B</td><td>Blue</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>CMYK</th><th></th></tr></thead><tbody>
<tr><td>C</td><td>Cyan</td></tr>
<tr><td>M</td><td>Magenta</td></tr>
<tr><td>Y</td><td>Yellow</td></tr>
<tr><td>K</td><td>Key(black)</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>HSV</th><th></th></tr></thead><tbody>
<tr><td>H</td><td>색상(Hue)</td></tr>
<tr><td>S</td><td>채도(Saturation)</td></tr>
<tr><td>V</td><td>명도(Value / Lightness / Brightness)</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>YUV</th><th></th></tr></thead><tbody>
<tr><td>Y</td><td>밝기</td></tr>
<tr><td>U</td><td>파랑 - 밝기</td></tr>
<tr><td>V</td><td>빨강 - 밝기</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>YUV 종류</th><th></th></tr></thead><tbody>
<tr><td>YCbCr</td><td>digital</td></tr>
<tr><td>YPbPr</td><td>analog</td></tr>
<tr><td>YIQ</td><td>YUV 33도 회전, NTSC(National Television System Committee)방식 -한국, 미국 컬러텔레비전</td></tr>
</tbody></table>
</div>
<p>ICtCp : ICtCp has near constant luminance, which improves chroma subsampling versus YCBCR
YCgCo : 색평면 사이에 상관성이 매우 낮음</p>
<p>CIE RGB
CIE XYZ
CIE Lab</p>
<div class="table-wrapper"><table><thead><tr><th>XYZ</th><th></th></tr></thead><tbody>
<tr><td>X</td><td>??</td></tr>
<tr><td>Y</td><td>휘도</td></tr>
<tr><td>Z</td><td>청색 자극</td></tr>
</tbody></table>
</div>
<ul>
<li>ITU1990</li>
</ul>
<h2 id="simple"><a class="header" href="#simple">Simple</a></h2>
<pre><code class="language-hlsl">const static half3x3 MAT_RGB_TO_XYZ = {
    0.4124, 0.3576, 0.1805,
    0.2126, 0.7152, 0.0722,
    0.0193, 0.1192, 0.9505
};

const static half3x3 MAT_XYZ_TO_RGB = {
    +3.2405, -1.5371, -0.4985,
    -0.9693, +1.8760, +0.0416,
    +0.0556, -0.2040, +1.0572
};
</code></pre>
<pre><code class="language-hlsl">// ======================================
/// XYZ =&gt; Yxy
float SUM_XYZ = dot(float3(1.0, 1.0, 1.0), XYZ);
Yxy.r  = XYZ.g;
Yxy.gb = XYZ.rg / SUM_XYZ;

// ======================================
/// Yxy =&gt; XYZ
XYZ.r = Yxy.r * Yxy.g / Yxy. b;
XYZ.g = Yxy.r;
XYZ.b = Yxy.r * (1 - Yxy.g - Yxy.b) / Yxy.b;
</code></pre>
<p>CIE Yxy
CIE Lab</p>
<pre><code class="language-hlsl">// https://www.ronja-tutorials.com/post/041-hsv-colorspace/

float3 hue2rgb(float hue)
{
    hue = frac(hue); //only use fractional part
    float r = abs(hue * 6 - 3) - 1; //red
    float g = 2 - abs(hue * 6 - 2); //green
    float b = 2 - abs(hue * 6 - 4); //blue
    float3 rgb = float3(r,g,b); //combine components
    rgb = saturate(rgb); //clamp between 0 and 1
    return rgb;
}

float3 hsv2rgb(float3 hsv)
{
    float3 rgb = hue2rgb(hsv.x); //apply hue
    rgb = lerp(1, rgb, hsv.y); //apply saturation
    rgb = rgb * hsv.z; //apply value
    return rgb;
}

float3 rgb2hsv(float3 rgb)
{
    float maxComponent = max(rgb.r, max(rgb.g, rgb.b));
    float minComponent = min(rgb.r, min(rgb.g, rgb.b));
    float diff = maxComponent - minComponent;
    float hue = 0;
    if(maxComponent == rgb.r)
    {
        hue = 0+(rgb.g-rgb.b)/diff;
    }
    else if(maxComponent == rgb.g)
    {
        hue = 2+(rgb.b-rgb.r)/diff;
    }
    else if(maxComponent == rgb.b)
    {
        hue = 4+(rgb.r-rgb.g)/diff;
    }
    hue = frac(hue / 6);
    float saturation = diff / maxComponent;
    float value = maxComponent;
    return float3(hue, saturation, value);
}
</code></pre>
<h3 id="grayscale--monochrome"><a class="header" href="#grayscale--monochrome">GrayScale / Monochrome</a></h3>
<pre><code class="language-hlsl">// YUV로 변환후, 밝기만 취하기.
const static half3x3 MAT_RGB_TO_YUV = {
  +0.299, +0.587, +0.114, // 밝기
  -0.147, -0.289, +0.436,
  +0.615, -0.515, -0.100
};

const static half3x3 MAT_YUV_TO_RGB = {
  +1.0, +0.000, +1.140,
  +1.0, -0.396, -0.581,
  +1.0, +2.029, +0.000
};

half YUV_y = mul(MAT_RGB_TO_YUV[0], color.rgb);
</code></pre>
<h3 id="sepia"><a class="header" href="#sepia">Sepia</a></h3>
<ul>
<li>MS문서에 나온 SepiaMatrix 이용.</li>
<li>YIQ나 YUV 이용.</li>
</ul>
<pre><code class="language-hlsl">half3x3 MAT_TO_SEPIA = {
    0.393, 0.769, 0.189,   // tRed
    0.349, 0.686, 0.168,   // tGreen
    0.272, 0.534, 0.131    // tBlue
};

half3 sepiaResult = mul(MAT_TO_SEPIA, color.rgb);
</code></pre>
<pre><code class="language-hlsl">// ref: http://www.aforgenet.com/framework/docs/html/10a0f824-445b-dcae-02ef-349d4057da45.htm
// I = 51
// Q = 0

half3x3 MAT_RGB_TO_YIQ = {
    +0.299, +0.587, +0.114,
    +0.596, -0.274, -0.322,
    +0.212, -0.523, +0.311
};

half3x3 MAT_YIQ_TO_RGB = {
    +1.0, +0.956, +0.621,
    +1.0, -0.272, -0.647,
    +1.0, -1.105, +1.702
};
</code></pre>
<pre><code class="language-hlsl">// Cb : -0.2
// Cr : 0.1

const static half3x3 MAT_RGB_TO_YUV = {
  +0.299, +0.587, +0.114, // 밝기
  -0.147, -0.289, +0.436,
  +0.615, -0.515, -0.100
};

const static half3x3 MAT_YUV_TO_RGB = {
  +1.0, +0.000, +1.140,
  +1.0, -0.396, -0.581,
  +1.0, +2.029, +0.000
};
</code></pre>
<h2 id="ref-25"><a class="header" href="#ref-25">Ref</a></h2>
<ul>
<li><a href="https://raphlinus.github.io/color/2021/01/18/oklab-critique.html">https://raphlinus.github.io/color/2021/01/18/oklab-critique.html</a></li>
<li><a href="https://bottosson.github.io/posts/oklab/">https://bottosson.github.io/posts/oklab/</a></li>
<li>The Dimensions of Colour
<ul>
<li><a href="http://www.huevaluechroma.com/index.php">http://www.huevaluechroma.com/index.php</a></li>
<li><a href="https://sites.google.com/site/djcbriggs/1-basic-colour-attributes#h.p_QpXoaFjHTppK">https://sites.google.com/site/djcbriggs/1-basic-colour-attributes#h.p_QpXoaFjHTppK</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eye-adaptation--luminance-adaptation--auto-exposure"><a class="header" href="#eye-adaptation--luminance-adaptation--auto-exposure">Eye Adaptation / Luminance Adaptation / Auto Exposure</a></h1>
<ul>
<li>광적응
<ul>
<li>현재밝기와 이전밝기를 이용하여 적절한밝기를 구하고, 이를 원본 이미지에 적용한다.</li>
</ul>
</li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<ol>
<li>현재밝기(lumaAverageCurr)
<ul>
<li>현재 화면의 평균밝기 저장(사이즈를 줄여가며 1x1텍스쳐로)</li>
<li>휘도 전용, POT(Power of Two), Mipmap 적용(1x1용), R16 색이면 충분.</li>
</ul>
</li>
<li>적절한밝기(lumaAdaptCurr)
<ul>
<li>이전화면 평균밝기와 비교해서 적절한 밝기 얻기</li>
</ul>
</li>
<li>적절한밝기 적용
<ul>
<li>앞서구한 적절한 밝기를 원본 이미지에 적용</li>
</ul>
</li>
<li>이전밝기(lumaAdaptPrev)
<ul>
<li>적절한밝기를 이전밝기에 저장</li>
</ul>
</li>
</ol>
<h2 id="예제코드"><a class="header" href="#예제코드">예제코드</a></h2>
<p>L_w   : 해당 픽셀의 밝기
L_avg : 씬 평균 밝기
L_min : 최소밝기. 이 값 아래로 가면강제로 0이됨.
L_white(WhitePoint) : 최대밝기. 이 값 위로가면 강제로 1로됨.
Logarithmic / Exponential - 로그/지수 성질 이용.</p>
<pre><code class="language-hlsl">// https://en.wikipedia.org/wiki/Relative_luminance
// https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl
real Luminance(real3 linearRgb)
{
    return dot(linearRgb, real3(0.2126729, 0.7151522, 0.0721750));
}
</code></pre>
<pre><code class="language-hlsl">간상체T_robs  약 0.2
추상체T_cones 약 0.4

r = p * T_robs + (1 - p) * T_cones

float SensitivityOfRods(float y)
{
   return 0.04 / (0.04 + y);
}
</code></pre>
<pre><code class="language-hlsl">half middleGray = 1.03 - (2 / (2 + log10(lumaAverageCurr + 1)));
half lumaScaled = (lumCurr * middleGrey) / lumaAverageCurr;

half lumaAdaptCurr = lumaAdaptedPrev + (lumaAverageCurr - lumaAdaptedPrev) * (1 - exp(- (dt) / AdaptationConstatnt));
// half sensitivity = SensitivityOfRod(luma)
half lumaAdaptCurr = lumaAdaptedPrev + (lumaAverageCurr - lumaAdaptedPrev) * (1 - exp( -(dt) / sensitivity * _FrameSpeed));
</code></pre>
<pre><code class="language-hlsl">///  ref: Programming Vertex Geometry and Pixel Shaders : High-Dynamic Range Rendering
float lumaScaled = Yxy.r * MiddleGray / (AdaptedLum.x + 0.001f);
Yxy.r = (lumaScaled * (1.0f + lumaScaled / WhitePoint))/(1.0f + lumaScaled);
</code></pre>
<p>// HSV로 변경후 V(명도)를 이용하는 방법도 있음.
// HSV를 이용하는 방식은 LUT를 이용해서 성능을 올려야함.
// Yxy를 이용하는 방식은 충분히 빠름.</p>
<pre><code class="language-hlsl">AutoKey = saturate(1.5 - (1.5 / (lumaAverageCurr * 0.1 + 1))) + 0.1; 


Color *= Key / (lumaAdaptCurr + 0.0001f);
Color = ToneMap(Color);

/// ref: 2007 Realtime HDR Rendering - Christian Luksch = 13.4. Adaptive Logarithmic Mapping
// _B = 0.5 and 1 
Color = Key
       / log10(lumaAverageCurr + 1)
       * log(Color + 1)
       / log(2 + pow((Color / lumaAverageCurr), log(_B) / log(0.5)) * 8);
</code></pre>
<pre><code class="language-hlsl">/// ref: Perceptual Eects in Real-time Tone Mapping
lumaToned = ToneMap(luma);
rgbL = rgb * (lumaToned * (1 - s)) / luma + (1.05, 0.97, 1.27) * lumaToned * s;
</code></pre>
<h2 id="ref-26"><a class="header" href="#ref-26">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/fcarucci/HDR-Meets-Black-And-White-2-2006">GDC2006 - Hdr Meets Black And White 2</a></li>
<li><a href="https://github.com/walbourn/directx-sdk-samples/tree/master/HDRToneMappingCS11">HDRToneMappingCS11</a></li>
<li><a href="https://astralcode.blogspot.com/2017/10/reverse-engineering-rendering-of.html">Reverse engineering the rendering of The Witcher 3, part 2 - eye adaptation</a></li>
<li><a href="https://github.com/przemyslawzaworski/Unity3D-CG-programming/tree/master/HDR">https://github.com/przemyslawzaworski/Unity3D-CG-programming/tree/master/HDR</a></li>
<li><a href="http://developer.download.nvidia.com/SDK/9.5/Samples/samples.html">http://developer.download.nvidia.com/SDK/9.5/Samples/samples.html</a>
<ul>
<li><a href="http://developer.download.nvidia.com/SDK/9.5/Samples/DEMOS/Direct3D9/DeferredShading.zip">http://developer.download.nvidia.com/SDK/9.5/Samples/DEMOS/Direct3D9/DeferredShading.zip</a></li>
</ul>
</li>
<li>High dynamic range : <a href="https://www.slideshare.net/cagetu/high-dynamic-range">https://www.slideshare.net/cagetu/high-dynamic-range</a></li>
<li>Programming Vertex Geometry and Pixel Shaders : Range Mapping, Light Adaptation</li>
<li><a href="https://www.cg.tuwien.ac.at/research/publications/2007/Luksch_2007_RHR/">https://www.cg.tuwien.ac.at/research/publications/2007/Luksch_2007_RHR/</a></li>
<li><a href="https://knarkowicz.wordpress.com/2016/01/09/automatic-exposure/">https://knarkowicz.wordpress.com/2016/01/09/automatic-exposure/</a></li>
<li><a href="http://resources.mpi-inf.mpg.de/tmo/logmap/">http://resources.mpi-inf.mpg.de/tmo/logmap/</a></li>
<li>블로그
<ul>
<li><a href="https://blog.naver.com/canny708/221892561143">canny708 - Eye Adaptation (Automatic Exposure)</a></li>
<li><a href="https://superrealizm.tistory.com/entry/HDR-Bloom">SuperRealizm - HDR + Bloom</a></li>
</ul>
</li>
<li><a href="https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/">https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/</a></li>
<li>ShaderX3 Advanced Rendering with DirectX and OpenGL
<ul>
<li>4.2 Adaptive Glare</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fxaa-fast-approximate-anti-aliasing"><a class="header" href="#fxaa-fast-approximate-anti-aliasing">FXAA (Fast Approximate Anti-Aliasing)</a></h1>
<ul>
<li>밝기를 분석하여 바뀌는 곳을 기반, 외곽선을 추출하여 블러시켜줌.</li>
<li>나중에 AA를 적용할 것을 감안하여, SSR같은 곳에서 적절히 디더링만 시켜주고 블러는 안해주는 식으로 흐림 효과를 AA에 맡길 수 있다.</li>
</ul>
<div class="juxtapose" data-animate="false">
  <img src="Postprocess/../res/SRP/FXAA_before.png" data-label="before" />
  <img src="Postprocess/../res/SRP/FXAA_after.png" data-label="after" />
</div>
<pre><code class="language-txt">
- Luminance Conversion
  - 픽셀당 8방향의 Luma가 필요하니 미리 계산해서 alpha채널에 넣거나, 그냥 green그대로 쓰기(명암차는 green에 민감하니)
- Local Contrast Check
  - 4방(상하좌우) Luma 차이 계산
  - 차이가 미미하면 AA미적용.
    - early exit
- Vertical/Horizontal Edge Test
  - 8방중 나머지 4방(대각선)의 luma역시 구해서 수평, 수직으로 외곽선 검출하여(Sobel필터 비슷하게) 외곽선의 방향을 얻어낸다.
- End-of-edge Search
  - 앞서구한 방향(수평 혹은 수직)으로 외곽선이 끝나는 양쪽 지점 검출
  - 양쪽 지점에 대한 평균 luma계산
- Blending
  - 외곽선이 끝나는 점 사이에 있는 기준점에 대한 blend값 구함
  - blend값을 이용하여 기준점에서 어느정도 떨어진 픽셀값을 반환
    - RenderTexture(이하 RT)는 Bilinear filtering된것을 이용
</code></pre>
<pre><code class="language-hlsl">// https://en.wikipedia.org/wiki/Relative_luminance
// https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl
real Luminance(real3 linearRgb)
{
    return dot(linearRgb, real3(0.2126729, 0.7151522, 0.0721750));
}
</code></pre>
<pre><code class="language-hlsl">// 블루값은 거의 영향이 없기에 무시(연산 아낌)
// ref: [FXAA WhitePaper - Nvidia - Timothy Lottes](https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf)
float FxaaLuma(float3 rgb)
{
    return rgb.g * (0.587/0.299) + rgb.r;
}

</code></pre>
<h2 id="ref-27"><a class="header" href="#ref-27">Ref</a></h2>
<ul>
<li><a href="https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf">FXAA WhitePaper - Nvidia - Timothy Lottes</a></li>
<li><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/">https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/</a></li>
<li><a href="https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/FXAA.hlsl">https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/FXAA.hlsl</a></li>
<li><a href="https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/fxaa-fast-approximate-anti-aliasing-3590?locale=ko-KR#content">assetstore: FXAA Fast Approximate Anti-Aliasing</a></li>
<li><a href="http://iryoku.com/aacourse/downloads/09-FXAA-3.11-in-15-Slides.pdf">SIGGRAPH2011 - FXAA 3.11</a>
<ul>
<li><a href="http://iryoku.com/aacourse/">http://iryoku.com/aacourse/</a></li>
</ul>
</li>
<li><a href="http://blog.simonrodriguez.fr/articles/2016/07/implementing_fxaa.html">Implementing FXAA - Simon Rodriguez</a>
<ul>
<li><a href="https://scahp.tistory.com/68">[번역] Implementing FXAA</a></li>
</ul>
</li>
<li><a href="https://www.slideshare.net/JinWooLee2/anti-aliasing">https://www.slideshare.net/JinWooLee2/anti-aliasing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lightstreak"><a class="header" href="#lightstreak">LightStreak</a></h1>
<ul>
<li>aka. CrossFilter</li>
<li>Streak 자국, 흔적</li>
</ul>
<p><img src="Postprocess/../res/crossFilter.JPG" alt="crossFilter.JPG" /></p>
<pre><code class="language-txt">- 원본
- 축소
  - 밝은부분
    - 블러
    - 카메라 기준 6방향 늘이기
    - 늘린것 합치기
- 원본과 합쳐진 늘려진것 더하기
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>용도</th><th>사이즈</th><th>Format</th><th>기타</th></tr></thead><tbody>
<tr><td>원본</td><td>w, h</td><td></td><td></td></tr>
<tr><td>축소</td><td>w/4, h/4</td><td>R16G16B16A16</td><td></td></tr>
<tr><td>휘도</td><td>w/4 +2, h/4 +2</td><td>R8G8B8A8</td><td></td></tr>
<tr><td>블러</td><td>w/4 +2, h/4 +2</td><td>R8G8B8A8</td><td></td></tr>
<tr><td>늘리기</td><td>w/4, h/4</td><td>품질(R16G16B16A16) // 속도(R8G8B8A8)</td><td>6장은 방향늘리기, 2장은 임시버퍼</td></tr>
</tbody></table>
</div>
<pre><code class="language-txt">                source,             _TmpCopy : 복사
               _TmpCopy,          _ScaledTex : 축소
            _ScaledTex,           _BrightTex : 밝기 추출
            _BrightTex, _BaseStarBlurredTex1 : 블러
  _BaseStarBlurredTex1, _BaseStarBlurredTex2 : 블러

  _BaseStarBlurredTex2,            _StarTex0 : 늘리기
             _StarTex0,            _StarTex1 : 늘리기2
             _StarTex1,            _StarTex2 : 광선 임시저장
             ...
           _StarTex2~7,            _StarTex0 : 최종적으로 광선별 합치기
  _TmpCopy + _StarTex0,               source : 원본 텍스쳐에 적용
</code></pre>
<pre><code class="language-txt">cropW = srcW - srcW / Scale
cropH = srcH - srcH / Scale
scaledW = cropW / Scale
scaledH = cropH / Scale
brightW = scaledW + 2;
brightH = scaledH + 2;
</code></pre>
<ul>
<li>Scale을 4로 축소시키면서 축소버퍼의 복사로 픽셀과 텍셀이 1:1 대응함으로 무리없이 복사가능.</li>
<li>휘도버퍼에서 패딩은(+2)
<ul>
<li>블러를 먹이거나 광선을 늘일 경우, 화면을 초과한 픽셀을 검은색으로 처리하기 위한 방법</li>
<li>안하면 텍스쳐 끝부분이 밝으면, 바깥쪽이 모두 밝은것으로 계산되어 필요 이상으로 빛나게됨.</li>
<li>예전 GPU에서는 NPOT인경우 성능하락이 있었음. 최신은 아님.
<ul>
<li><a href="https://forum.unity.com/threads/disadvantages-of-non-power-of-two-textures.814542/#post-5403687">https://forum.unity.com/threads/disadvantages-of-non-power-of-two-textures.814542/#post-5403687</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-cs">public static int ToPow2RoundUp(int x)
{
  if(x == 0)
  {
    return 0;
  }
  return MakeMSB(x - 1) + 1;
}

public static int MakeMSB(int x)
{
  // 0b_0000_0000_0000_0000_1000_0000_1000_1011
  // MakeMSB(0b_1000) =&gt; 0b_1111 //  8 =&gt; 15
  // MakeMSB(0b_1111) =&gt; 0b_1111 // 15 =&gt; 15

  x |= x &gt;&gt; 1;
  x |= x &gt;&gt; 2;
  x |= x &gt;&gt; 4;
  x |= x &gt;&gt; 8;
  x |= x &gt;&gt; 16;
  return x;
}
</code></pre>
<pre><code class="language-cs">int topBloomWidth = width &gt;&gt; Properties.DownSampleLevel;
int topBloomHeight = height &gt;&gt; Properties.DownSampleLevel;

w = TextureUtil.ToPow2RoundUp( topBloomWidth), 
h = TextureUtil.ToPow2RoundUp( topBloomHeight), 

brightnessOffsetX = (w - topBloomWidth) / 2;
brightnessOffsetY = (h - topBloomHeight) / 2;
</code></pre>
<h2 id="ref-28"><a class="header" href="#ref-28">Ref</a></h2>
<ul>
<li><a href="https://www.hanbit.co.kr/store/books/look.php?p_code=B9447539340">2004 - Directx 9 셰이더 프로그래밍 - 타카시 이마기레</a></li>
<li><a href="Postprocess/www.daionet.gr.jp/~masa/archives/GDC2003_DSTEAL.ppt">GDC2003 - Frame Buffer Postprocessing Effects in DOUBLE-S.T.E.A.L (Wreckless)</a></li>
<li><a href="Postprocess/www.chrisoat.com/papers/Oat-SteerableStreakFilter.pdf">A Steerable Streak Filter - Christopher Oat</a>
<ul>
<li>ShaderX3 Advanced Rendering with DirectX and OpenGL
<ul>
<li>4.1 A Steerable Streak Filter</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ssao"><a class="header" href="#ssao">SSAO</a></h1>
<ul>
<li>SSAO / Screen Space Ambient Occlusion</li>
<li>주변물체에 의해서 가려지는 곳이 어둡게 되어, 장면의 깊이감을 더함.</li>
<li>Ambient : 주변</li>
<li>Occlusion : 차폐, 가려짐</li>
</ul>
<div class="juxtapose" data-animate="false">
 <img src="Postprocess/../res/SRP/SSAO_blur_before.jpg" data-label="Raw RenderTexture" />
 <img src="Postprocess/../res/SRP/SSAO_blur_after.jpg" data-label="With Blur" />
</div>
<div class="juxtapose" data-animate="false">
 <img src="Postprocess/../res/SRP/SSAO_before.jpg" data-label="before SSAO" />
 <img src="Postprocess/../res/SRP/SSAO_after.jpg" data-label="after SSAO" />
</div>
<h2 id="역사"><a class="header" href="#역사">역사</a></h2>
<ul>
<li>2001 : 영화 진주만Pearl Harbor에서 Ambient Occlusion 사용</li>
<li>2007 : 게임 Crytek의 Crysis에서 SSAO(Screen Space Ambient Occlusion)등장
<ul>
<li>실제 지오메트리 데이터를 이용하는게 아니라 화면 공간 뎁스를 이용.</li>
</ul>
</li>
<li>2008 : SIGGRAPH2008에서 Nvidia 기존 SSAO개선판 HBAO(Horizon Based Ambient Occulusion)발표.
<ul>
<li>노멀등 추가정보를 이용.</li>
</ul>
</li>
<li>2011 : MSSAO(Multi-Scale Screen Space Ambient Occlusion)</li>
<li>2016 : SIGGRAPH2016에서 GTAO(Ground True Ambient Occulusion) 소개.</li>
<li>...</li>
</ul>
<h2 id="샘플링--구-반구"><a class="header" href="#샘플링--구-반구">샘플링 : 구? 반구?</a></h2>
<p><img src="Postprocess/../res/ssao_sphere.jpg" alt="ssao_sphere.jpg" /></p>
<ul>
<li>Sphere - Crysis Method
<ul>
<li>특정 점의 구형(Sphere) 주변의 뎁스값을 수집 및 계산 =&gt; 구형속 뎁스값이 많아지면 어두워짐</li>
<li>구형 주변의 샘플 갯수가 적으면, 정밀도가 줄어들고 소위 (줄무늬가 드리워지는) banding이라는 현상 발생.</li>
</ul>
</li>
</ul>
<p><img src="Postprocess/../res/ssao_hemisphere.jpg" alt="ssao_hemisphere.jpg" /></p>
<ul>
<li>Normal-oriented Hemisphere
<ul>
<li>특정 점의 노말방향으로 반구형(Hemisphere) 주변의 뎁스값을 수집 및 계산</li>
</ul>
</li>
</ul>
<h2 id="구현"><a class="header" href="#구현">구현</a></h2>
<ul>
<li>반구 주변의 점으로 가려짐 정도(Occlusion factor) 계산
<ul>
<li>성능상 샘플링 갯수를 줄이는게...</li>
</ul>
</li>
<li>계산된 가려짐 정도를 블러(Blur)로 적당히 흐려지게 만들기</li>
<li>원본 텍스쳐에 적용</li>
</ul>
<pre><code class="language-hlsl">// 1. 가려짐 정도(Occlusion factor) 계산
// 2. 계산된 가려짐 정도를 블러(Blur)로 적당히 흐려지게 만들기
// 3. 원본 텍스쳐에 적용
half4 mainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
half ambientOcclusionTex = SAMPLE_TEXTURE2D(_AmbientOcclusionTex, sampler_AmbientOcclusionTex, IN.uv).r;
col.rgb *= ambientOcclusionTex;
return col;
</code></pre>
<pre><code class="language-txt">// https://babytook.tistory.com/171
꽁수 1 : 2x downscaled depth buffer 사용
꽁수 2 : 랜덤 ray 벡터를 랜덤 벡터로 reflect (회전 변환보다 싸다)
꽁수 3 : view normal 값을 사용할 수 있다면 self occlusion 을 피하기 위해 sign(dot(ray, n)) 을 곱한다
꽁수 4 : 카메라와 가까이 있는 픽셀의 ray 는 작게 scale 하여 어색함을 줄임
꽁수 5 : 깊이값 비교 함수를 적절히 조절 ^^;
</code></pre>
<pre><code class="language-txt">예)

| rt                   | 넓이, 높이 |
| -------------------- | ---------- |
| source               | w, h       |
| _TmpCopy             | w, h       |
| _AmbientOcclusionTex | w/4, h/4   |
| _BlurTex0            | w/8, h/8   |
| _BlurTex1            | w/16, h/16 |

              source,             _TmpCopy : 복사
            _TmpCopy, _AmbientOcclusionTex : Occlusion factor 계산
_AmbientOcclusionTex,            _BlurTex0 : 블러 - DownSampling
           _BlurTex0,            _BlurTex1 : 블러 - DownSampling
           _BlurTex1,            _BlurTex0 : 블러 - UpSampling
           _BlurTex0, _AmbientOcclusionTex : 블러 - UpSampling
            _TmpCopy,               source : 원본 텍스쳐에 적용
</code></pre>
<p>흠 어차피 블러시킬것이고 채널 하나밖에 안쓰니, (r 혼은 rgb 채널 쓰는) Bloom효과에서 안쓰는 채널(a) 이용하면 괜춘할듯.</p>
<h2 id="case"><a class="header" href="#case">case</a></h2>
<pre><code class="language-hlsl">// [assetstore - Fast SSAO ( Mobile , URP , VR , AR , LWRP )](https://assetstore.unity.com/packages/vfx/shaders/fullscreen-camera-effects/fast-ssao-mobile-urp-vr-ar-lwrp-169024)
// 깊이텍스쳐를 이용해서 노말을 구하고, 노말방향으로 레이를 쏴서 AO를 구함.
// 빠름은 1번, 보통은 3번의 occlusion을 구하도록 코드가 작성됨.

float depthDiff = srcDepth - dstDepth;
float occlusion = step(0.02h, depthDiff) * (1.0h - smoothstep(0.02h, _Area, depthDiff));
</code></pre>
<pre><code class="language-hlsl">/// [canny - SSAO (Screen Space Ambient Occlusion)](https://blog.naver.com/canny708/221878564749)
// 중앙점 픽셀로부터 일정 범위 내에 있는 랜덤 위치의 샘플 좌표의 위치 값과 노멀 벡터를 얻어온 후,
// 중앙점의 노멀과 비교하여 각도가 가파를수록, 위치가 가까울수록 차폐의 영향이 크다고 판단.
// depth버퍼로 positionWS랑 normal을 구할 수 있다.

inline float Random(in float2 uv)
{
    // 렌덤텍스쳐 이용하는 방법
    // return SAMPLE_TEXTURE2D(_RandTex, sampler_RandTex, uv).r;

    // 그냥 계산하는 방법
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453);
}

float3 GetWorldSpacePosition(in float2 uv)
{
    float sceneRawDepth = SampleSceneDepth(uv);
    return ComputeWorldSpacePosition(uv, sceneRawDepth, UNITY_MATRIX_I_VP);
}

inline float3 GetNormal(in float2 uv)
{
    return SampleSceneNormals(uv);
}

float3 srcPos = GetWorldSpacePosition(IN.uv);
float3 srcNormal = GetNormal(IN.uv);

const int SAMPLE_COUNT = 32;
float AO = 0;

// 매 계산마다 depth를 불러오니 =&gt; 32번 depth를 불러온다
for (int i = 0; i &lt; SAMPLE_COUNT; ++i)
{
    float2 dstUV = IN.uv + (float2(Random(IN.uv.xy + i), Random(IN.uv.yx + i)) * 2 - 1) / _ScreenParams.xy * _Radius;
    float3 dstPos = GetWorldSpacePosition(dstUV);

    float3 distance = dstPos - srcPos;
    float3 direction = normalize(distance);
    float delta = length(distance) * _Scale;

    AO += max(0, dot(srcNormal, direction) - _Bias) * (1 / (1 + delta)) * _Amount;
}

AO /= SAMPLE_COUNT;
AO = 1 - AO;

return half4(AO.xxx, 1);
</code></pre>
<pre><code class="language-glsl">// [(X) SSAO (Screen Space Ambient Occlusion) 처리 기법(소스포함)](http://eppengine.com/zbxe/programmig/2982)
// - backup : https://babytook.tistory.com/158
// 장점 : 따로 blur pass 를 실행할 필요가 없다. ( 랜덤맵 텍스쳐를 활용하기에 가능한 부분)
//        시각적 품질이 나쁘지 않다.
//        노멀 버퍼없이도 깔끔하다.
// 단점 : 전통적 ssao 보다는 좀 느리다.
//        역시 노멀 버퍼를 사용하지 않는 것 으로 인한 약간의 시각적 어색함이 존재.. 약간...
// 

uniform sampler2D som;  // Depth texture 
uniform sampler2D rand; // Random texture
uniform vec2 camerarange = vec2(1.0, 1024.0);

float pw = 1.0/800.0*0.5;
float ph = 1.0/600.0*0.5; 

float readDepth(in vec2 coord) 
{ 
    if (coord.x&lt;0||coord.y&lt;0) return 1.0;
    float nearZ = camerarange.x; 
    float farZ =camerarange.y; 
    float posZ = texture2D(som, coord).x;  
    return (2.0 * nearZ) / (nearZ + farZ - posZ * (farZ - nearZ)); 
}  

float compareDepths(in float depth1, in float depth2,inout int far) 
{ 
    float diff = (depth1 - depth2)*100; //depth difference (0-100)
    float gdisplace = 0.2; //gauss bell center
    float garea = 2.0; //gauss bell width 2

    //reduce left bell width to avoid self-shadowing
    if (diff &lt; gdisplace)
    {
        garea = 0.1;
    }
    else
    {
        far = 1;
    }
    float gauss = pow(2.7182,-2*(diff-gdisplace)*(diff-gdisplace)/(garea*garea));

    return gauss;
} 

float calAO(float depth,float dw, float dh) 
{ 
    float temp = 0;
    float temp2 = 0;
    float coordw = gl_TexCoord[0].x + dw/depth;
    float coordh = gl_TexCoord[0].y + dh/depth;
    float coordw2 = gl_TexCoord[0].x - dw/depth;
    float coordh2 = gl_TexCoord[0].y - dh/depth;

    if (coordw  &lt; 1.0 &amp;&amp; coordw  &gt; 0.0 &amp;&amp; coordh &lt; 1.0 &amp;&amp; coordh  &gt; 0.0)
    {
        vec2 coord = vec2(coordw , coordh);
        vec2 coord2 = vec2(coordw2, coordh2);
        int far = 0;
        temp = compareDepths(depth, readDepth(coord),far);
        //DEPTH EXTRAPOLATION:
        if (far &gt; 0)
        {
            temp2 = compareDepths(readDepth(coord2),depth,far);
            temp += (1.0-temp)*temp2;
        }
    }
    return temp; 
}  

void main(void) 
{ 
    //randomization texture:
    vec2 fres = vec2(20,20);
    vec3 random = texture2D(rand, gl_TexCoord[0].st*fres.xy);
    random = random*2.0-vec3(1.0);

    //initialize stuff:
    float depth = readDepth(gl_TexCoord[0]); 
    float ao = 0.0;

    for(int i=0; i&lt;4; ++i)
    { 
        //calculate color bleeding and ao:
        ao+=calAO(depth,  pw, ph); 
        ao+=calAO(depth,  pw, -ph); 
        ao+=calAO(depth,  -pw, ph); 
        ao+=calAO(depth,  -pw, -ph);

        ao+=calAO(depth,  pw*1.2, 0); 
        ao+=calAO(depth,  -pw*1.2, 0); 
        ao+=calAO(depth,  0, ph*1.2); 
        ao+=calAO(depth,  0, -ph*1.2);

        //sample jittering:
        pw += random.x*0.0007;
        ph += random.y*0.0007;

        //increase sampling area:
        pw *= 1.7;
        ph *= 1.7;
    }        

    //final values, some adjusting:
    vec3 finalAO = vec3(1.0-(ao/32.0));


    gl_FragColor = vec4(0.3+finalAO*0.7,1.0); 
}
</code></pre>
<h2 id="ref-29"><a class="header" href="#ref-29">Ref</a></h2>
<ul>
<li>Game Engine Gems, Volume 1 - 18. Fast Screen-space Ambient Occlusion and Indirect Lighting</li>
<li>https://babytook.tistory.com/171</li>
<li><a href="https://github.com/sebastianhein/urp-ssao">https://github.com/sebastianhein/urp-ssao</a></li>
<li><a href="https://learnopengl.com/Advanced-Lighting/SSAO">https://learnopengl.com/Advanced-Lighting/SSAO</a></li>
<li><a href="https://ogldev.org/www/tutorial45/tutorial45.html">https://ogldev.org/www/tutorial45/tutorial45.html</a>
<ul>
<li><a href="https://ogldev.org/www/tutorial46/tutorial46.html">https://ogldev.org/www/tutorial46/tutorial46.html</a></li>
</ul>
</li>
<li><a href="https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.universal/ShaderLibrary/SSAO.hlsl">https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.universal/ShaderLibrary/SSAO.hlsl</a></li>
<li><a href="http://developer.amd.com/wordpress/media/2012/10/Chapter8-Mittring-Finding_NextGen_CryEngine2.pdf">SIGGRAPH2007 -  Finding Next Gen - CryEngine 2</a></li>
<li><a href="https://developer.download.nvidia.com/presentations/2008/GDC/GDC08_Ambient_Occlusion.pdf">GDC2008 - Real-Time Depth Buffer Based Ambient Occlusion</a></li>
<li><a href="https://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf">SIGGRAPH2008 - Image-Space Horizon-Based Ambient Occlusion</a></li>
<li><a href="https://developer.download.nvidia.com/presentations/2009/SIGGRAPH/Bavoil_MultiLayerDualResolutionSSAO.pdf">SIGGRAPH2009 - Multi-LayerDual-ResolutionScreen-SpaceAmbient Occlusion</a></li>
<li><a href="https://advances.realtimerendering.com/s2010/">SIGGRAPH2010 - Rendering techniques in Toy Story 3</a></li>
<li><a href="https://blog.selfshadow.com/publications/s2016-shading-course/">SIGGRAPH2016 - Practical Real-Time Strategies for Accurate Indirect Occlusion</a></li>
<li>일어
<ul>
<li><a href="http://maverickproj.web.fc2.com/d3d11_24.html">http://maverickproj.web.fc2.com/d3d11_24.html</a></li>
<li><a href="https://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20101122">https://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20101122</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tonemapping"><a class="header" href="#tonemapping">ToneMapping</a></h1>
<ul>
<li>컴퓨터 모니터와 같은 LDR 매체에서 볼 수 있지만 HDR 이미지의 선명도와 톤 범위를 갖는 결과 이미지를 생성</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th>nits</th></tr></thead><tbody>
<tr><td>eye</td><td>40,000</td></tr>
<tr><td>LDR/SDR(Low/Standard Dynamic Range)</td><td>100</td></tr>
<tr><td>HDR(High Dynamic Range)</td><td>1,000</td></tr>
</tbody></table>
</div>
<ul>
<li>Tone-mapping -&gt; 디스플레이에 출력가능한 값</li>
<li>평균 Luminance</li>
<li>Luminance 중심으로 0~1 : Tone Mapping</li>
<li>RGB -&gt; CIE XYZ -&gt; CIE Yxy -&gt; y : Luminance</li>
</ul>
<h2 id="reinhard"><a class="header" href="#reinhard">Reinhard</a></h2>
<pre><code class="language-hlsl">float3 Reinhard(float3 v)
{
    return v / (1.0f + v);
}

float3 Reinhard_extended(float3 v, float max_white)
{
    float3 numerator = v * (1.0f + (v / float3(max_white * max_white)));
    return numerator / (1.0f + v);
}

</code></pre>
<h2 id="flimic"><a class="header" href="#flimic">Flimic</a></h2>
<ul>
<li>Jim Hejl and Richard Burgess-Dawson
<ul>
<li>color_Linear =&gt; flmic =&gt; result_Gamma</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">half3 TonemapFilmic(half3 color_Linear)
{
    // optimized formula by Jim Hejl and Richard Burgess-Dawson
    half3 X = max(color_Linear - 0.004, 0.0);
    half3 result_Gamma = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
    return pow(result_Gamma, 2.2); // convert Linear Color
}
</code></pre>
<h2 id="uncharted2"><a class="header" href="#uncharted2">Uncharted2</a></h2>
<ul>
<li>John Hable</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>param</th><th></th></tr></thead><tbody>
<tr><td>Exposure_Bias</td><td></td></tr>
<tr><td>A</td><td>Soulder Strength</td></tr>
<tr><td>B</td><td>Linear Strength</td></tr>
<tr><td>C</td><td>Linear Angle</td></tr>
<tr><td>D</td><td>Toe Strength</td></tr>
<tr><td>E</td><td>Toe Numerator</td></tr>
<tr><td>F</td><td>Toe Denominator</td></tr>
<tr><td>LinearWhite</td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-hlsl">float3 Uncharted2_tonemap_partial(float3 x)
{
    const float A = 0.15f;
    const float B = 0.50f;
    const float C = 0.10f;
    const float D = 0.20f;
    const float E = 0.02f;
    const float F = 0.30f;
    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - (E / F);
}

float3 Uncharted2_filmic(float3 v)
{
    float exposure_bias = 2.0f;
    float3 curr = Uncharted2_tonemap_partial(v * exposure_bias);

    float3 W = 11.2f;
    float3 white_scale = 1.0 / Uncharted2_tonemap_partial(W);
    return curr * white_scale;
}
</code></pre>
<h2 id="flimic_hejl2015"><a class="header" href="#flimic_hejl2015">Flimic_Hejl2015</a></h2>
<pre><code class="language-hlsl">half3 TonemapFilmic_Hejl2015(half3 hdr, half whitePoint)
{
    half4 vh = half4(hdr, whitePoint);
    half4 va = (1.425 * vh) + 0.05;
    half4 vf = ((vh * va + 0.004) / ((vh * (va + 0.55) + 0.0491))) - 0.0821;
    return vf.rgb / vf.aaa;
}
</code></pre>
<h2 id="unreal3"><a class="header" href="#unreal3">Unreal3</a></h2>
<ul>
<li>Used in Unreal Engine 3 up to 4.14. Adapted to be close to ACES, with similar range.</li>
</ul>
<pre><code class="language-hlsl">float3 Unreal3(float3 color_Linear)
{
    float3 result_Gamma = color_Linear / (color_Linear + 0.155) * 1.019;
    return pow(result_Gamma, 2.2); // convert Linear Color
}
</code></pre>
<h2 id="aces"><a class="header" href="#aces">ACES</a></h2>
<ul>
<li>based on ‘ACES Filmic Tone Mapping Cuve‘ by Narkowicz in 2015.</li>
<li>unreal 4.8</li>
</ul>
<pre><code class="language-hlsl">// sRGB =&gt; XYZ =&gt; D65_2_D60 =&gt; AP1 =&gt; RRT_SAT
static const float3x3 ACESInputMat =
{
    {0.59719, 0.35458, 0.04823},
    {0.07600, 0.90834, 0.01566},
    {0.02840, 0.13383, 0.83777}
};

// ODT_SAT =&gt; XYZ =&gt; D60_2_D65 =&gt; sRGB
static const float3x3 ACESOutputMat =
{
    { 1.60475, -0.53108, -0.07367},
    {-0.10208,  1.10813, -0.00605},
    {-0.00327, -0.07276,  1.07602}
};

float3 RRTAndODTFit(float3 v)
{
    float3 a = v * (v + 0.0245786f) - 0.000090537f;
    float3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;
    return a / b;
}

float3 ACES_Fitted(float3 color)
{
    color = mul(ACESInputMat, color);

    // Apply RRT and ODT
    color = RRTAndODTFit(color);

    color = mul(ACESOutputMat, color);

    // Clamp to [0, 1]
    color = saturate(color);

    return color;
}
</code></pre>
<h2 id="uchimura"><a class="header" href="#uchimura">Uchimura</a></h2>
<ul>
<li>Practical HDR and Wide Color Techniques inGran TurismoSPORT</li>
<li>linear to gamma</li>
<li>CEDEC2017 "HDR, Theory and Practice"</li>
<li><a href="https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp">https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp</a></li>
</ul>
<h2 id="others"><a class="header" href="#others">Others</a></h2>
<ul>
<li>kawase
<ul>
<li><a href="http://cedec.cesa.or.jp/2016/session/ENG/13532.html">http://cedec.cesa.or.jp/2016/session/ENG/13532.html</a></li>
<li>CEDEC2016 - HDR Output Theory and Practice by Silicon Studio</li>
</ul>
</li>
<li>LottesVDR
<ul>
<li>GDC2016 - Advanced Techniques and Optimization of HDR VDR Color Pipelines</li>
</ul>
</li>
</ul>
<h2 id="ref-30"><a class="header" href="#ref-30">Ref</a></h2>
<ul>
<li><a href="https://danielilett.com/2019-05-01-tut1-1-smo-greyscale/">https://danielilett.com/2019-05-01-tut1-1-smo-greyscale/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Grayscale">https://en.wikipedia.org/wiki/Grayscale</a></li>
<li><a href="https://blog.ggaman.com/965">https://blog.ggaman.com/965</a></li>
<li><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2005/january/net-matters-sepia-tone-stringlogicalcomparer-and-more">https://docs.microsoft.com/en-us/archive/msdn-magazine/2005/january/net-matters-sepia-tone-stringlogicalcomparer-and-more</a></li>
<li><a href="https://www.gdcvault.com/play/1012351/Uncharted-2-HDR">https://www.gdcvault.com/play/1012351/Uncharted-2-HDR</a>
<ul>
<li><a href="https://www.slideshare.net/naughty_dog/lighting-shading-by-john-hable">https://www.slideshare.net/naughty_dog/lighting-shading-by-john-hable</a></li>
<li><a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">http://filmicworlds.com/blog/filmic-tonemapping-operators/</a></li>
<li><a href="https://github.com/dmnsgn/glsl-tone-map">https://github.com/dmnsgn/glsl-tone-map</a></li>
</ul>
</li>
<li><a href="https://twitter.com/jimhejl/status/633777619998130176">https://twitter.com/jimhejl/status/633777619998130176</a></li>
<li><a href="https://github.com/tizian/tonemapper">https://github.com/tizian/tonemapper</a></li>
<li><a href="https://64.github.io/tonemapping/">https://64.github.io/tonemapping/</a></li>
<li><a href="https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp">https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp</a></li>
<li>Color Control : <a href="https://www.slideshare.net/cagetu/928501785227148871">https://www.slideshare.net/cagetu/928501785227148871</a></li>
<li><a href="http://advances.realtimerendering.com/other/2016/naughty_dog/index.html">SIGGRAPH2016 - Technical Art of Uncharted 4</a>
<ul>
<li><a href="https://www.slideshare.net/DaeHyekKIM/naughty-dog-techartfinalpart1tonemappingamphdrcolorgrading">https://www.slideshare.net/DaeHyekKIM/naughty-dog-techartfinalpart1tonemappingamphdrcolorgrading</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=7z_EIjNG0pQ">GDC2017 - High Dynamic Range Color Grading and Display in Frostbite</a></li>
<li>https://mynameismjp.wordpress.com/2010/04/30/a-closer-look-at-tone-mapping/</li>
<li>http://renderwonk.com/publications/s2010-color-course/</li>
<li><a href="https://www.shadertoy.com/view/lslGzl">shadertoy -  Tone mapping</a></li>
<li>GDC2004 - Advanced Depth of Field</li>
<li><a href="https://www.slideshare.net/DAMSIGNUP/so4-flexible-shadermanagmentandpostprocessing">GDC2009 - Star Ocean 4 - Flexible Shader Managment and Post-processing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chromatic-aberration"><a class="header" href="#chromatic-aberration">Chromatic Aberration</a></h1>
<ul>
<li>빛의 파장에 따라 다른 초점 거리를 가짐.</li>
<li>Chromatic : 색채</li>
<li>Aberration : 일탈 / 변형</li>
</ul>
<p><img src="Postprocess/../res/Chromatic_diag.gif" alt="Chromatic_diag.gif" /></p>
<ul>
<li>종 색수차(Longitudinal/Axial Chromatic Aberration)</li>
<li>횡 색수차(Lateral/Yanal Chromatic Aberration)</li>
</ul>
<pre><code class="language-hlsl">// ref: https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.universal/Shaders/PostProcessing/UberPost.shader

#define DistCenter              _Distortion_Params1.xy
#define DistAxis                _Distortion_Params1.zw
#define DistTheta               _Distortion_Params2.x
#define DistSigma               _Distortion_Params2.y
#define DistScale               _Distortion_Params2.z
#define DistIntensity           _Distortion_Params2.w

#define ChromaAmount            _Chroma_Params.x

float2 DistortUV(float2 uv)
{
    // Note: this variant should never be set with XR
    #if _DISTORTION
    {
        uv = (uv - 0.5) * DistScale + 0.5;
        float2 ruv = DistAxis * (uv - 0.5 - DistCenter);
        float ru = length(float2(ruv));

        UNITY_BRANCH
        if (DistIntensity &gt; 0.0)
        {
            float wu = ru * DistTheta;
            ru = tan(wu) * (rcp(ru * DistSigma));
            uv = uv + ruv * (ru - 1.0);
        }
        else
        {
            ru = rcp(ru) * DistTheta * atan(ru * DistSigma);
            uv = uv + ruv * (ru - 1.0);
        }
    }
    #endif

    return uv;
}

float2 uvDistorted = DistortUV(uv);
half3 color = (0.0).xxx;

float2 coords = 2.0 * uv - 1.0;
float2 end = uv - coords * dot(coords, coords) * ChromaAmount;
float2 delta = (end - uv) / 3.0;

half r = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uvDistorted                ).x;
half g = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, DistortUV(delta + uv)      ).y;
half b = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, DistortUV(delta * 2.0 + uv)).z;

color = half3(r, g, b);
</code></pre>
<pre><code class="language-hlsl">// ref: [2019 - [Unite Seoul 2019] 최재영 류재성 - 일곱개의 대죄 : "애니메이션의 감성을 그대로"와 "개발 최적화."](https://youtu.be/0LwlNVS3FJo?t=1988)
half3 mainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv).rgb;
half k = _ParamK;
half kcube = _ParamKcube;

float2 centerUV = (IN.uv - 0.5);
half r2 = dot(centerUV, centerUV);
half f = 0;
if (kcube == 0)
{
    f = 1 + r2 * k;
}
else
{
    f = 1 + r2 * (k + kcube * sqrt(r2));
}

float2 chromaticUV = 0.5 + centerUV * f;
half3 final_chromatic = half3(SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, chromaticUV).rg, mainTex.b);
</code></pre>
<h2 id="ref-31"><a class="header" href="#ref-31">Ref</a></h2>
<ul>
<li><a href="https://www.nvidia.com/en-us/geforce/news/the-witcher-3-wild-hunt-graphics-performance-and-tweaking-guide/#the-witcher-3-wild-hunt-chromatic-aberration">The Witcher 3 - Chromatic Aberration</a></li>
<li><a href="https://mgun.tistory.com/3253">Chromatic Aberration 1 (색수차)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="depth-of-field"><a class="header" href="#depth-of-field">Depth of Field</a></h1>
<ul>
<li>
<p>DOF: Depth Of Field</p>
</li>
<li>
<p>CoC: Circle of Confusion</p>
</li>
<li>
<p>Bokeh</p>
</li>
<li>
<p>초점을 맞춘 이 위치의 물체를 제외하고는 전경과 배경이 모두 흐려짐.</p>
</li>
<li>
<p>흐릿함의 정도는 초점에서 멀어질수록(비선형적으로) 커짐.</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Coc</td><td>depth texture</td></tr>
<tr><td>soft edge</td><td>blur</td></tr>
</tbody></table>
</div>
<h2 id="coccircle-of-confusion"><a class="header" href="#coccircle-of-confusion">CoC(Circle of Confusion)</a></h2>
<p>착란원</p>
<pre><code class="language-txt">// SIGGRAPH2018 A Life of a Bokeh

A         = Apertune diameter         // 센서크기
F         = Focal length              // 피사체와의 거리
P         = Focus distance            // 초점거리
MaxBgdCoc = (A * F)/(P - F)           // 배경의 최대 착란원의 반경
Coc(z)    = (1 - (P / z)) * MaxBgdCoc // 혼란원(확산원)
</code></pre>
<pre><code class="language-hlsl">float z = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.uv));
float CoC = (1 - (_FocusDistance / z));
CoC = clamp(CoC, -1, 1) * _MaxBgdCoc;
</code></pre>
<h2 id="ref-32"><a class="header" href="#ref-32">REF</a></h2>
<ul>
<li><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/depth-of-field/">https://catlikecoding.com/unity/tutorials/advanced-rendering/depth-of-field/</a></li>
<li><a href="https://www.slideshare.net/youpyo/d2-depth-of-field">slideshare.net/youpyo/d2-depth-of-field</a></li>
<li><a href="https://blog.naver.com/eryners/220152909470">https://blog.naver.com/eryners/220152909470</a></li>
<li>ShaderX3 Advanced Rendering with DirectX and OpenGL
<ul>
<li>4.4 Improved Depth-of-Field Rendering</li>
</ul>
</li>
<li><a href="https://qiita.com/UWATechnology/items/2742e5726f3b8a01796d">https://qiita.com/UWATechnology/items/2742e5726f3b8a01796d</a></li>
<li>SIGGRAPH2018 A Life of a Bokeh
<ul>
<li><a href="https://www.youtube.com/watch?v=wIm25R5Z9lc">A Life Of A Bokeh Advances in real-time rendering SIGGRAPH 2018 UE4</a></li>
</ul>
</li>
<li><a href="https://www.slideshare.net/ohyecloudy/gpu-gems3-chapter-28-practical-post-process-depth-of-field">https://www.slideshare.net/ohyecloudy/gpu-gems3-chapter-28-practical-post-process-depth-of-field</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hdr"><a class="header" href="#hdr">HDR</a></h1>
<p>High Dynamic Range</p>
<ul>
<li>컴퓨터 모니터와 같은 LDR 매체에서 볼 수 있지만 HDR 이미지의 선명도와 톤 범위를 갖는 결과 이미지를 생성</li>
<li>Bloom(빛발산)/Eye Adaptation(광적응)/ToneMapping/감마보정</li>
</ul>
<h2 id="bloom-1"><a class="header" href="#bloom-1">Bloom</a></h2>
<ol>
<li>일정 밝기의 한계점(Threshold)을 넘는 부분을 저장</li>
<li>블러</li>
<li>원본이미지와 합치기</li>
</ol>
<h2 id="eye-adaptation"><a class="header" href="#eye-adaptation">Eye Adaptation</a></h2>
<ul>
<li>참고: <a href="Postprocess/./EyeAdaptation.html">EyeAdaptation</a></li>
</ul>
<h2 id="tonemapping-1"><a class="header" href="#tonemapping-1">ToneMapping</a></h2>
<ul>
<li>참고: <a href="Postprocess/./ToneMapping.html">ToneMapping</a></li>
</ul>
<h2 id="감마보정"><a class="header" href="#감마보정">감마보정</a></h2>
<ul>
<li>linear color를 마지막에 gamma적용시킴</li>
<li><code>pow(linearColor, 2.2);</code></li>
</ul>
<h2 id="rgbm과-logluv"><a class="header" href="#rgbm과-logluv">RGBM과 LogLUV</a></h2>
<p>TODO</p>
<ul>
<li><a href="http://egloos.zum.com/cagetu/v/5697725">http://egloos.zum.com/cagetu/v/5697725</a></li>
<li><a href="https://kblog.popekim.com/2013/11/blendable-rgbm.html">https://kblog.popekim.com/2013/11/blendable-rgbm.html</a></li>
</ul>
<h2 id="통합셰이더-예제"><a class="header" href="#통합셰이더-예제">통합셰이더 예제</a></h2>
<ul>
<li>CHROMATIC_ABERRATION 색수차 - 렌즈 무지개현상</li>
<li>BLOOM(dirt w/o)</li>
<li>Vignette 카메라 가장자리 어둡게 하는 효과</li>
<li>ApplyColorGrading</li>
<li>FlimGrain 필름 표면 미세한 입자(노이즈)</li>
<li>DITHERING</li>
</ul>
<h2 id="ref-33"><a class="header" href="#ref-33">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/agebreak/ndc12-hdr">[Ndc12] 누구나 알기쉬운 hdr과 톤맵핑 박민근</a></li>
<li><a href="https://www.slideshare.net/cagetu/ndc11-hdr">Ndc11 이창희_hdr</a></li>
<li><a href="https://www.slideshare.net/youpyo/hdr-8480350">HDR - 김정희, 최유표</a></li>
<li><a href="https://www.slideshare.net/hyurichel/kgc2014-41150275">KGC2014 - 울프나이츠 엔진 프로그래밍 기록</a></li>
<li><a href="https://www.ea.com/frostbite/news/high-dynamic-range-color-grading-and-display-in-frostbite">https://www.ea.com/frostbite/news/high-dynamic-range-color-grading-and-display-in-frostbite</a></li>
<li><a href="https://research.activision.com/publications/archives/hdr-in-call-of-duty">https://research.activision.com/publications/archives/hdr-in-call-of-duty</a></li>
<li><a href="http://diaryofagraphicsprogrammer.blogspot.com/2013/09/call-for-new-post-processing-pipeline.html">http://diaryofagraphicsprogrammer.blogspot.com/2013/09/call-for-new-post-processing-pipeline.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="렌즈-플레어"><a class="header" href="#렌즈-플레어">렌즈 플레어</a></h1>
<ul>
<li><a href="https://www.slideshare.net/agebreak/0821-lens-flare">[0821 박민근] 렌즈 플레어(lens flare)</a></li>
<li><a href="http://cg.skku.edu/pub/2013-lee-egsr-matrixflare">http://cg.skku.edu/pub/2013-lee-egsr-matrixflare</a></li>
<li><a href="https://github.com/modanhan/Unity-Lens-Flare-2019">https://github.com/modanhan/Unity-Lens-Flare-2019</a></li>
<li><a href="https://opengameart.org/content/lens-flares-and-particles?page=1">https://opengameart.org/content/lens-flares-and-particles?page=1</a></li>
<li><a href="http://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html">http://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html</a></li>
<li><a href="https://developer.arm.com/documentation/102259/0100/Dirty-lens-effect">https://developer.arm.com/documentation/102259/0100/Dirty-lens-effect</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lightshaft_postprocess"><a class="header" href="#lightshaft_postprocess">LightShaft_Postprocess</a></h1>
<ul>
<li>Shaft : 한 줄기 광선, 전광</li>
<li><a href="https://en.wikipedia.org/wiki/Sunbeam#Crepuscular_rays">wiki</a> : aka. Sun beam / Sun Shafts/ Crepuscular Ray / God Ray</li>
</ul>
<h2 id="frustum"><a class="header" href="#frustum">Frustum</a></h2>
<ul>
<li>Frustum : 절두체</li>
</ul>
<p><img src="Postprocess/../res/Frustum.png" alt="Frustum.png" /></p>
<p><img src="Postprocess/../res/FrustumCorners.PNG" alt="FrustumCorners.PNG" /></p>
<ul>
<li><a href="https://docs.unity3d.com/ScriptReference/Camera-stereoActiveEye.html">Camera.stereoActiveEye</a>
<ul>
<li>Camera.MonoOrStereoscopicEye.Mono : 파랑</li>
<li>Camera.MonoOrStereoscopicEye.Left : 초록</li>
<li>Camera.MonoOrStereoscopicEye.Right : 빨강</li>
</ul>
</li>
</ul>
<pre><code class="language-cs">_materia_LightShaft.SetVector("_CameraPositionWS", camera.transform.position);
_materia_LightShaft.SetMatrix("_Matrix_CameraFrustum", FrustumCorners(camera));


private Matrix4x4 FrustumCorners(Camera cam)
{
  // ref: http://hventura.com/unity-post-process-v2-raymarching.html

    Transform camtr = cam.transform;

    // frustumCorners
    //    1  +----+ 2
    //       |    |
    //    0  +----+ 3
    Vector3[] frustumCorners = new Vector3[4];
    cam.CalculateFrustumCorners(
        new Rect(0, 0, 1, 1),  // viewport
        cam.farClipPlane,      // z
        cam.stereoActiveEye,   // eye
        frustumCorners         // outCorners
    );

    // frustumVectorsArray
    //    3  +----+ 2
    //       |    |
    //    0  +----+ 1
    Matrix4x4 frustumVectorsArray = Matrix4x4.identity;
    frustumVectorsArray.SetRow(0, camtr.TransformVector(frustumCorners[0]));
    frustumVectorsArray.SetRow(1, camtr.TransformVector(frustumCorners[3]));
    frustumVectorsArray.SetRow(2, camtr.TransformVector(frustumCorners[1]));
    frustumVectorsArray.SetRow(3, camtr.TransformVector(frustumCorners[2]));

    // in Shader
    // IN.uv
    // (0,1) +----+ (1,1)
    //       |    |
    // (0,0) +----+ (1,0)
    //
    // int frustumIndex = (int)(IN.uv.x +  2 * IN.uv.y);
    //    2  +----+ 3
    //       |    |
    //    0  +----+ 1
    return frustumVectorsArray;
}

</code></pre>
<pre><code class="language-hlsl">struct Ray
{
    float3 origin;
    float3 direction;
    float3 energy;
};

Ray CreateRay(in float3 origin, in float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.energy = float3(1, 1, 1);
    return ray;
}

Ray CreateCameraRay(in float2 uv)
{
    // 원점이 화면 중앙이 되도록 uv [0, 1]을 [-1, 1]로 변경.
    float2 screenUV = uv * 2.0f - 1.0f;

    // -1이 있는 이유는 unity_CameraToWorld의 구성요소가 camera.cameraToWorldMatrix와는 다르기 때문이다.
    float4x4 negativeMat = float4x4(
        1,  0,  0,  0,
        0,  1,  0,  0,
        0,  0, -1,  0,
        0,  0,  0,  1
    );
    float4x4 cameraToWorldMatrix = mul(unity_CameraToWorld, negativeMat);

    // 카메라 공간 (0, 0, 0)으로 cameraPositionWS 좌표를 얻어와서
    float3 cameraPositionWS = mul(cameraToWorldMatrix, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // 프로젝션 (curr.x, curr.y, 1)에서 currPositionWS를 얻어와서 ray의 방향을 구한다.
    float3 currPositionCamera = mul(unity_CameraInvProjection, float4(screenUV, 1.0f, 1.0f)).xyz;
    float3 currPositionWS = mul(cameraToWorldMatrix, float4(currPositionCamera, 0.0f)).xyz;
    float3 rayDirection = normalize(currPositionWS);

    return CreateRay(cameraPositionWS, rayDirection);
}
</code></pre>
<pre><code class="language-hlsl">float4x4 _Matrix_CameraFrustum;

// IN.uv
// (0,1) +----+ (1,1)
//       |    |
// (0,0) +----+ (1,0)

// frustumIndex
//    2  +----+ 3
//       |    |
//    0  +----+ 1
int   frustumIndex          = (int)(IN.uv.x +  2 * IN.uv.y);
half3 frustumPositionCamera = _Matrix_CameraFrustum[frustumIndex].xyz;
</code></pre>
<p><img src="Postprocess/../res/diff_cameramatrix.jpg" alt="diff_cameramatrix.jpg" /></p>
<h2 id="frustumpositionws와-normalizefrustumpositionws"><a class="header" href="#frustumpositionws와-normalizefrustumpositionws">frustumPositionWS와 normalize(frustumPositionWS)</a></h2>
<p><img src="Postprocess/../res/fragment_frustum.jpg" alt="fragment_frustum.jpg" /></p>
<p><img src="Postprocess/../res/fragment_normalize_frustum.jpg" alt="fragment_normalize_frustum.jpg" /></p>
<h2 id="예-2"><a class="header" href="#예-2">예</a></h2>
<pre><code class="language-hlsl">// 1. shadow맵과 depth 맵을 이용하여 마스크 맵을 만든다
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"

// 카메라의 Frustum의 각 꼭지점을 구하고, normalize하여 해당 방향으로 ray를 쏜다

half stepDistance = _MinDistance + (step * Random(rayDirWS.xy, _Time.y * 100));

// 2. 합한다
color = lerp(mainTex, _MainLightColor.rgb, lightShaftMask);
</code></pre>
<h2 id="관련자료"><a class="header" href="#관련자료">관련자료</a></h2>
<ul>
<li>Shadow Volume Algorithm (Modified) [ MAX 1986 ]</li>
<li>Slice-based volume-rendering technique [ Dobashi &amp; Nishta &amp; Yamamoto 2002 ]</li>
<li>Hardware Shadow Map [ Mitchell 2004 ]</li>
<li>Polygonal Volume [ James 2003 Based On Radomir Mech 2001]</li>
<li>Volumetric Light Scattering [ Hoffman &amp; Preetham 2003 ]</li>
</ul>
<h2 id="ref-34"><a class="header" href="#ref-34">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/TiagoAlexSousa/crysis-nextgen-effects-gdc-2008">GDC2008 - Crysis Next-Gen Effects</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process">https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process</a>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/405975067">https://zhuanlan.zhihu.com/p/405975067</a></li>
<li><a href="https://blog.csdn.net/qq_38275140/article/details/91049023">https://blog.csdn.net/qq_38275140/article/details/91049023</a></li>
<li><a href="https://github.com/togucchi/urp-postprocessing-examples/tree/main/Assets/LightShaft">https://github.com/togucchi/urp-postprocessing-examples/tree/main/Assets/LightShaft</a></li>
</ul>
</li>
<li><a href="https://blog.naver.com/sorkelf/40152690614">https://blog.naver.com/sorkelf/40152690614</a></li>
<li><a href="https://blog.naver.com/eryners/110127353463">https://blog.naver.com/eryners/110127353463</a></li>
<li><a href="http://maverickproj.web.fc2.com/pg65.html">http://maverickproj.web.fc2.com/pg65.html</a></li>
<li>ShaderX3 Advanced Rendering with DirectX and OpenGL
<ul>
<li>8.1 Light Shaft Rendering</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motionblur"><a class="header" href="#motionblur">MotionBlur</a></h1>
<ul>
<li>
<p>Frame Blur</p>
</li>
<li>
<p>Position Reconstruction</p>
</li>
<li>
<p>Velocity Buffer</p>
</li>
<li>
<p><a href="https://blog.naver.com/sorkelf/40158984437">https://blog.naver.com/sorkelf/40158984437</a></p>
</li>
<li>
<p><a href="https://medium.com/spaceapetech/motion-blur-for-mobile-devices-in-unity-656c8047508">https://medium.com/spaceapetech/motion-blur-for-mobile-devices-in-unity-656c8047508</a></p>
</li>
</ul>
<p><a href="https://www.nvidia.com/docs/io/8230/gdc2003_openglshadertricks.pdf">2023 - [GDC2023] Stupid OpenGL Shader Tricks by Simon Green, NVIDIA</a>
Image space (2.5D) motion blur</p>
<ul>
<li>3 stages:
<ul>
<li>Render scene to texture
<ul>
<li>At current time</li>
</ul>
</li>
<li>Calculate velocity at each pixel
<ul>
<li>Using vertex shader</li>
<li>Calculate current position – previous position</li>
</ul>
</li>
<li>Render motion blurred scene
<ul>
<li>Using fragment shader</li>
<li>Look up into scene texture</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">// Calculate velocity at each pixel
struct a2v {
    float4 coord;
    float4 prevCoord;
    float3 normal;
    float2 texture;
};
struct v2f {
    float4 hpos : HPOS;
    float3 velocity : TEX0;
};

v2f main(a2v in,
    uniform float4x4 modelView,
    uniform float4x4 prevModelView,
    uniform float4x4 modelViewProj,
    uniform float4x4 prevModelViewProj,
    uniform float3 halfWinSize,
)
{
    v2f out;
    
    // transform previous and current pos to eye space
    float4 P = mul(modelView, in.coord);
    float4 Pprev = mul(prevModelView, in.prevCoord);

    // transform normal to eye space
    float3 N = vecMul(modelView, in.normal);
    
    // calculate eye space motion vector
    float3 motionVector = P.xyz - Pprev.xyz;
    
    // calculate clip space motion vector
    P = mul(modelViewProj, in.coord);
    Pprev = mul(prevModelViewProj, in.prevCoord);
    
    // choose previous or current position based
    // on dot product between motion vector and normal
    float flag = dot(motionVector, N) &gt; 0;
    float4 Pstretch = flag ? P : Pprev;
    out.hpos = Pstretch;
    
    // do divide by W -&gt; NDC coordinates
    P.xyz = P.xyz / P.w;
    Pprev.xyz = Pprev.xyz / Pprev.w;
    Pstretch.xyz = Pstretch.xyz / Pstretch.w;
    
    // calculate window space velocity
    float3 dP = halfWinSize.xyz * (P.xyz - Pprev.xyz);
    out.velocity = dP;
    return v2f;
}
</code></pre>
<pre><code class="language-hlsl">// Motion Blur Shader Code
struct v2f {
    float4 wpos : WPOS;
    float3 velocity : TEX0;
};
struct f2f {
    float4 col;
};

f2fConnector main(
    v2f in,
    uniform samplerRECT sceneTex,
    uniform float blurScale = 1.0
)
{
    f2f out;
    
    // read velocity from texture coordinate
    half2 velocity = v2f.velocity.xy * blurScale;
    
    // sample scene texture along direction of motion
    const float samples = SAMPLES;
    const float w = 1.0 / samples; // sample weight
    fixed4 a = 0; // accumulator
    float i;
    for(i = 0; i &lt; samples; i += 1)
    {
        float t = i / (samples-1);
        a = a + x4texRECT(sceneTex, in.wpos + velocity*t) * w;
    }
    out.col = a;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ssgi"><a class="header" href="#ssgi">SSGI</a></h1>
<ul>
<li>SSGI / Screen Space Global Illumination</li>
<li>Illumination : 조명</li>
</ul>
<h2 id="구현-1"><a class="header" href="#구현-1">구현</a></h2>
<ul>
<li>반구 주변의 점으로 가려짐 정도(Occlusion factor) 계산
<ul>
<li>성능상 샘플링 갯수를 줄이는게...</li>
</ul>
</li>
<li>계산된 가려짐 정도를 블러(Blur)로 적당히 흐려지게 만들기</li>
<li>원본 텍스쳐에 적용</li>
</ul>
<h2 id="case-1"><a class="header" href="#case-1">Case</a></h2>
<pre><code class="language-glsl">// [(X) SSGI 관련 정리 (소스 포함)](http://eppengine.com/zbxe/programmig/2985)
// - backup article: https://babytook.tistory.com/157

uniform sampler2D som;  // Depth texture 
uniform sampler2D rand; // Random texture
uniform sampler2D color; // Color texture

uniform vec2 camerarange = vec2(1.0, 1024.0);

float pw = 1.0/800.0*0.5;
float ph = 1.0/600.0*0.5; 

float readDepth(in vec2 coord) 
{ 
    if (coord.x&lt;0||coord.y&lt;0) return 1.0;
    float nearZ = camerarange.x; 
    float farZ =camerarange.y; 
    float posZ = texture2D(som, coord).x;  
    return (2.0 * nearZ) / (nearZ + farZ - posZ * (farZ - nearZ)); 
}  

vec3 readColor(in vec2 coord) 
{ 
    return texture2D(color, coord).xyz; 
}

float compareDepths(in float depth1, in float depth2) 
{ 
    float gauss = 0.0;
    float diff = (depth1 - depth2)*100.0; //depth difference (0-100)
    float gdisplace = 0.2; //gauss bell center
    float garea = 3.0; //gauss bell width

    //reduce left bell width to avoid self-shadowing
    if (diff&lt;gdisplace) garea = 0.2;

    gauss = pow(2.7182,-2*(diff-gdisplace)*(diff-gdisplace)/(garea*garea));

    return max(0.2,gauss); 
} 

vec3 calAO(float depth,float dw, float dh, inout float ao) 
{ 
    float temp = 0;
    vec3 bleed = vec3(0.0,0.0,0.0);
    float coordw = gl_TexCoord[0].x + dw/depth;
    float coordh = gl_TexCoord[0].y + dh/depth;

    if (coordw  &lt; 1.0 &amp;&amp; coordw  &gt; 0.0 &amp;&amp; coordh &lt; 1.0 &amp;&amp; coordh  &gt; 0.0)
    {
        vec2 coord = vec2(coordw , coordh);
        temp = compareDepths(depth, readDepth(coord));
        bleed = readColor(coord);
    }
    ao += temp;
    return temp*bleed; 
}  

void main(void) 
{ 
    //randomization texture:
    vec2 fres = vec2(20,20);
    vec3 random = texture2D(rand, gl_TexCoord[0].st*fres.xy);
    random = random*2.0-vec3(1.0);

    //initialize stuff:
    float depth = readDepth(gl_TexCoord[0]);
    vec3 gi = vec3(0.0,0.0,0.0); 
    float ao = 0.0;

    for(int i=0; i&lt;8; ++i)
    { 
        //calculate color bleeding and ao:
        gi += calAO(depth,  pw, ph,ao); 
        gi += calAO(depth,  pw, -ph,ao); 
        gi += calAO(depth,  -pw, ph,ao); 
        gi += calAO(depth,  -pw, -ph,ao);

        //sample jittering:
        pw += random.x*0.0005;
        ph += random.y*0.0005;

        //increase sampling area:
        pw *= 1.4; 
        ph *= 1.4;   
    }        

    //final values, some adjusting:
    vec3 finalAO = vec3(1.0-(ao/32.0));
    vec3 finalGI = (gi/32)*0.6;

    gl_FragColor = vec4(readColor(gl_TexCoord[0])*finalAO+finalGI,1.0); 
}  
</code></pre>
<h2 id="ref-35"><a class="header" href="#ref-35">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/jangho/real-time-global-illumination-techniques">https://www.slideshare.net/jangho/real-time-global-illumination-techniques</a></li>
<li><a href="https://forum.unity.com/threads/my-ssao-ssgi-prototype.78566/#post-521710">https://forum.unity.com/threads/my-ssao-ssgi-prototype.78566/#post-521710</a></li>
<li><a href="https://github.com/demonixis/StylisticFog-URP/tree/master/Assets/StylisticFog-URP">https://github.com/demonixis/StylisticFog-URP/tree/master/Assets/StylisticFog-URP</a></li>
<li><a href="https://people.mpi-inf.mpg.de/~ritschel/SSDO/index.html">https://people.mpi-inf.mpg.de/~ritschel/SSDO/index.html</a></li>
<li><a href="http://walkingfat.com/%e7%94%a8unity-srp%e5%ae%9e%e7%8e%b0ssgi%ef%bc%8c%e5%92%8c%e6%89%8b%e6%9c%ba%e7%ab%af%e7%9a%84%e6%95%88%e6%9e%9c%e6%b5%8b%e8%af%95%ef%bc%88%e4%b8%80%ef%bc%89/">用Unity SRP实现SSGI，和手机端的效果测试（一）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ssr"><a class="header" href="#ssr">SSR</a></h1>
<ul>
<li>SSR(Screen Space Reflection)</li>
</ul>
<h2 id="주의점"><a class="header" href="#주의점">주의점</a></h2>
<ul>
<li>화면 공간이므로, 당연히 화면밖이나 가려져 있는 것을 반사시키진 못한다
<ul>
<li>화면 바깥과 가까우면 fadeout</li>
<li>어느정도 구께일때만 반사적용</li>
</ul>
</li>
<li>깊이버퍼를 이용함으로, 깊이버퍼를 안쓰는 오브젝트는 반사가 안됨</li>
<li>3d ray marching 언더샘플링 오버샘플링</li>
<li>모션블러 감소</li>
</ul>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<ul>
<li>SSR 준비물
<ul>
<li>색상</li>
<li>깊이(위치를 얻기 위해)</li>
<li>노말</li>
<li>반사 마스크</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>구할것</th><th>구하는 법</th></tr></thead><tbody>
<tr><td>카메라레이</td><td>uv와 카메라 역행렬을 이용</td></tr>
<tr><td>반사레이 시작점(VS)</td><td>카메라 레이와 뎁스버퍼를 이용</td></tr>
<tr><td>입사벡터(VS)</td><td>반사레이 시작점을 노말라이즈함. (incident : 입사/투사되는)</td></tr>
<tr><td>반사레이벡터(VS)</td><td>입사벡터와 노멀을 이용</td></tr>
<tr><td>반사레이 도착점(VS)</td><td>반사레이벡터에서 점진적 이동(Ray Marching)</td></tr>
<tr><td>반사색</td><td>반사레이 도착점의 색 (두께처리가 있으면 처리하고, uv가 범위안에 있는지도 체크)</td></tr>
</tbody></table>
</div>
<h2 id="반사-레이를-쏘는-방식"><a class="header" href="#반사-레이를-쏘는-방식">반사 레이를 쏘는 방식</a></h2>
<ul>
<li><a href="http://casual-effects.blogspot.com/2014/08/screen-space-ray-tracing.html">http://casual-effects.blogspot.com/2014/08/screen-space-ray-tracing.html</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>3D</td><td>원근법때문에 언더샘플링(가까운거), 오버샘플링(먼것) 이슈</td></tr>
<tr><td>2D</td><td>DDA(Digital Differential Analyzer)</td></tr>
</tbody></table>
</div>
<h2 id="코드-예"><a class="header" href="#코드-예">코드 예</a></h2>
<pre><code class="language-cs">_material_SSR.SetMatrix( "_MATRIX_InverseCameraProjection", _camera.projectionMatrix.inverse);
</code></pre>
<pre><code class="language-hlsl">// vert =====================
// 카메라레이
float4 cameraRay = float4(IN.uv * 2 - 1, 1, 1);
cameraRay = mul(_MATRIX_InverseCameraProjection, cameraRay);
OUT.cameraRay = cameraRay.xyz / cameraRay.w;



// frag =====================
half reflectMask = SAMPLE_TEXTURE2D(_ReflectMask_, sampler_ReflectMask, IN.uv).r;
clip(reflectMask - 0.1);

// 반사레이 시작점
half sceneRawDepth = SampleSceneDepth(IN.uv);
half scene01Depth  = Linear01Depth(sceneRawDepth, _ZBufferParams);
half3 reflectRayStartPositionWS = IN.cameraRay * sceen01Depth;

// 입사벡터
half3 incidentVec = normalize(reflectRayStartPositionWS);

// 반사레이벡터
half3 sceneNormal = SampleSceneNormals(IN.uv);
half3 reflectRayDirWS = normalize(reflect(incidentVec, sceneNormal));

// 레이 처리
half step = _MaxDistance / _MaxIteration;
half stepDistance = _MinDistance + step;
half availableThickness = _MaxThickness / _MaxIteration;
int iteratorCount = min(64, _MaxIteration);
half3 reflectionColor = 0;

UNITY_UNROLL
for (int i = 0; i &lt; iteratorCount; ++i)
{
    // 반사레이 도착점 
    half3 reflectRayEndPositionWS = reflectRayStartPositionWS + (reflectRayDirWS * stepDistance);
    float4 reflectRayEndPositionCS = TransformWorldToHClip(reflectRayEndPositionWS);
    float2 reflectRayEndUV = reflectRayEndPositionCS.xy / reflectRayEndPositionCS.w * 0.5 + 0.5;

    bool isValidUV = max(abs(reflectRayEndUV.x - 0.5), abs(reflectRayEndUV.y - 0.5)) &lt;= 0.5;
    if (!isValidUV)
    {
        break;
    }

    half reflectRayEndDepth = ComputeDepth(reflectRayEndPositionCS);
    half sceneReflectRayEndDepth = SampleSceneDepth(reflectRayEndUV);
    half depthDiff = reflectRayEndDepth - sceneReflectRayEndDepth;
    if (0 &lt; depthDiff &amp;&amp; depthDiff &lt; availableThickness)
    {
        // 반사색
        reflectionColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, reflectRayEndUV).rgb;
        break;
    }

    stepDistance += step;
}
return half4(reflectionColor, 1);


// etc ==========================
float ComputeDepth(float4 positionCS)
{
#if defined(SHADER_TARGET_GLSL) || defined(SHADER_API_GLES) || defined(SHADER_API_GLES3)
    return (positionCS.z / positionCS.w) * 0.5 + 0.5;
#else
    return (positionCS.z / positionCS.w);
#endif
}
</code></pre>
<pre><code>???
    float sampleDepth = tex_depth.read(tid).x;
    float4 samplePosInCS =  float4(((float2(tid)+0.5)/sceneInfo.ViewSize)*2-1.0f, sampleDepth, 1);
    samplePosInCS.y *= -1;
</code></pre>
<pre><code class="language-hlsl">
incidentVec = normalize(rayStartPositionWS)
N

half3 reflectionColor = 0;
if (reflectMask &gt; 0)
{
  reflectionColor = 
}

half3 scaledR = _RayStepScale * R;
for (_MaxRayStep)
{

}
</code></pre>
<h2 id="hi-z-buffer"><a class="header" href="#hi-z-buffer">Hi-Z Buffer</a></h2>
<ul>
<li>Hierarchical-Z buffer</li>
<li>기존 Z buffer를 축소시키며 계층을 만들며(밉맵)
<ul>
<li>셀은 최소 3×3 셀</li>
</ul>
</li>
<li>기존 Z Buffer보다 비교적 적은 샘플 횟수로 교차점을 얻을 수 있다.</li>
</ul>
<p><img src="Postprocess/../res/zbuffer_to_hiz.jpg" alt="zbuffer_to_hiz.png" /></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/278793984">https://zhuanlan.zhihu.com/p/278793984</a></li>
</ul>
<h2 id="ref-36"><a class="header" href="#ref-36">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/xtozero/screen-space-reflection">https://www.slideshare.net/xtozero/screen-space-reflection</a></li>
<li><a href="http://www.kode80.com/blog/2015/03/11/screen-space-reflections-in-unity-5/">http://www.kode80.com/blog/2015/03/11/screen-space-reflections-in-unity-5/</a>
<ul>
<li><a href="https://github.com/kode80/kode80SSR">https://github.com/kode80/kode80SSR</a></li>
</ul>
</li>
<li>Screen Space Reflections : Implementation and optimization
<ul>
<li><a href="https://github.com/leesg213/ssr_optimizing">src</a>, <a href="https://sugulee.wordpress.com/2021/01/16/performance-optimizations-for-screen-space-reflections-technique-part-1-linear-tracing-method/">pt1</a>, <a href="https://sugulee.wordpress.com/2021/01/19/screen-space-reflections-implementation-and-optimization-part-2-hi-z-tracing-method/">pt2</a></li>
<li><a href="https://scahp.tistory.com/66">번역1</a>, <a href="https://scahp.tistory.com/67">번역2</a></li>
</ul>
</li>
<li>GPU Pro 5: Hi-Z Screen-Space Cone-Traced Reflections by Yasin Uludag</li>
<li><a href="https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.postprocessing/PostProcessing/Shaders/Builtins/ScreenSpaceReflections.hlsl">https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.postprocessing/PostProcessing/Shaders/Builtins/ScreenSpaceReflections.hlsl</a></li>
<li><a href="https://tips.hecomi.com/entry/2016/04/04/022550">Unity で Screen Space Reflection の実装をしてみた</a>
<ul>
<li><a href="https://github.com/hecomi/UnityScreenSpaceReflection">https://github.com/hecomi/UnityScreenSpaceReflection</a></li>
</ul>
</li>
<li><a href="https://youtu.be/RdN06E6Xn9E?t=2243">GDC2016 - Low Complexity, High Fidelity: The Rendering of INSIDE</a></li>
<li><a href="https://www.youtube.com/watch?v=2XXS5UyNjjU">GDC2016 - Temporal Reprojection Anti-Aliasing in INSIDE</a>
<ul>
<li><a href="https://github.com/playdeadgames/temporal">https://github.com/playdeadgames/temporal</a></li>
</ul>
</li>
<li><a href="https://books.google.co.kr/books?id=30ZOCgAAQBAJ&amp;pg=PA65&amp;lpg=PA65#v=onepage&amp;q&amp;f=false">GPU Pro 6: Advanced Rendering Techniques - II: RENDERING - 1.2.3 Screen-Space Reflections</a></li>
<li>Approximating ray traced reflections using screen-space data by MATTIAS JOHNSSON</li>
<li><a href="https://dataprocess.tistory.com/315">https://dataprocess.tistory.com/315</a></li>
<li><a href="https://sakibsaikia.github.io/graphics/2016/12/26/Screen-Space-Reflection-in-Killing-Floor-2.html">https://sakibsaikia.github.io/graphics/2016/12/26/Screen-Space-Reflection-in-Killing-Floor-2.html</a></li>
<li><a href="http://roar11.com/2015/07/screen-space-glossy-reflections/">http://roar11.com/2015/07/screen-space-glossy-reflections/</a></li>
<li><a href="https://www.slideshare.net/MicheleGiacalone1/screen-space-reflections-in-the-surge">Screen Space Reflections in The Surge</a></li>
<li><a href="https://www.slideshare.net/DICEStudio/stochastic-screenspace-reflections">SIGGRAPH2015 -  Stochastic Screen-Space Reflections</a></li>
<li><a href="https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html">https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html</a></li>
<li><a href="https://www.gamedeveloper.com/disciplines/screen-space-reflections-in-blightbound">https://www.gamedeveloper.com/disciplines/screen-space-reflections-in-blightbound</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="taa--temporal-anti-aliasing"><a class="header" href="#taa--temporal-anti-aliasing">TAA / Temporal Anti-Aliasing</a></h1>
<ul>
<li><a href="https://scahp.tistory.com/m/77">[번역] Temporal Anti-Aliasing(TAA) Tutorial</a></li>
<li><a href="https://github.com/sienaiwun/TAA_Unity_URP/">https://github.com/sienaiwun/TAA_Unity_URP/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-fade-shader"><a class="header" href="#cross-fade-shader">Cross Fade Shader</a></h1>
<ul>
<li>LOD 변환시 블렌딩</li>
</ul>
<p><img src="Environment/../res/lodgroup.jpg" alt="lodgroup.jpg" /></p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>설명</th></tr></thead><tbody>
<tr><td>FadeMode - CrossFade</td><td>현재 LOD와 다음 LOD사이에 CrossFade 스타일 블렌딩을 수행</td></tr>
<tr><td>Fade Transaction Width</td><td>CrossFade 전환 영역의 비율</td></tr>
<tr><td>unity_LODFade</td><td>x : fade [0 .. 1] - [-1 .. 0], y is fade quantized to 16 levels, z, w  사용안함.</td></tr>
</tbody></table>
</div>
<pre><code class="language-hlsl">// LOD_FADE_CROSSFADE 정의는
// |- LOD Group 컴포넌트에서
// |- Fade Mode : Cross Fade
// |- 그리고 각 LOD에서 Fade Transition Width값이 0이 아닐때 활성화가 된다.

// 현재 LOD가 `1`에서 `0`으로, 다음 LOD가 `-1`에서 `0`로 전환된다.

// 예)
// RootGameObject | FadeMode : CrossFade
//   - Sphere     | LOD : 2, Fade Transaction Width : 0.3
//   - Cube       | LOD : 1, Fade Transaction Width : 0.2

#pragma multi_compile _ LOD_FADE_CROSSFADE

TEXTURE2D(_DitherTex);   SAMPLER(sampler_DitherTex);
float4 _DitherTex_TexelSize;
SAMPLER(unity_DitherMask); // 유니티가 4x4 디더링 마스크를 제공해준다.

#ifdef LOD_FADE_CROSSFADE
    half2 screenUV = IN.positionNDC.xy / IN.positionNDC.w;
    float fade = unity_LODFade.x;

    // ex-1
    // float dither = (IN.positionCS.y % 32) / 32;
    // clip(fade - dither);

    // ex-2
    // half ditherTex = SAMPLE_TEXTURE2D(_DitherTex, sampler_DitherTex, IN.uv).r;
    // clip(fade - ditherTex);

    // ex-3
    //float2 ditherUV = screenUV.xy * _ScreenParams.xy * _DitherTex_TexelSize.xy;
    //half ditherTex = SAMPLE_TEXTURE2D(_DitherTex, sampler_DitherTex, ditherUV).r;
    //clip(fade - CopySign(ditherTex, fade));

    // ex-4
    // float2 fadeMaskSeed = IN.positionCS.xy;
    // LODDitheringTransition(fadeMaskSeed, fade);

    // ex-5
    //float2 ditherUV = screenUV * _ScreenParams.xy;
    //float DITHER_THRESHOLDS[16] =
    //{
    //    1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
    //    13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
    //    4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
    //    16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
    //};
    //uint index = (uint(ditherUV.x) % 4) * 4 + uint(ditherUV.y) % 4;
    //clip(fade - CopySign(DITHER_THRESHOLDS[index], fade));

    // ex-6
    float2 ditherUV = screenUV.xy * _ScreenParams.xy / 4.0;
    float dither = tex2D(unity_DitherMask, ditherUV).a;
    clip(fade - CopySign(dither, fade));
 #endif
</code></pre>
<pre><code class="language-hlsl">// built-in
// CGIncludes/UnityCG.cginc
#ifdef LOD_FADE_CROSSFADE
    #define UNITY_APPLY_DITHER_CROSSFADE(vpos)  UnityApplyDitherCrossFade(vpos)
    sampler2D unity_DitherMask;
    void UnityApplyDitherCrossFade(float2 vpos)
    {
        vpos /= 4; // the dither mask texture is 4x4
        float mask = tex2D(unity_DitherMask, vpos).a;
        float sgn = unity_LODFade.x &gt; 0 ? 1.0f : -1.0f;
        clip(unity_LODFade.x - mask * sgn);
    }
#else
    #define UNITY_APPLY_DITHER_CROSSFADE(vpos)
#endif

float2 vpos = IN.screenPos.xy / IN.screenPos.w * _ScreenParams.xy;
UnityApplyDitherCrossFade(vpos);


// URP
// com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl
void LODDitheringTransition(uint2 fadeMaskSeed, float ditherFactor)
{
    // Generate a spatially varying pattern.
    // Unfortunately, varying the pattern with time confuses the TAA, increasing the amount of noise.
    float p = GenerateHashedRandomFloat(fadeMaskSeed);

    // This preserves the symmetry s.t. if LOD 0 has f = x, LOD 1 has f = -x.
    float f = ditherFactor - CopySign(p, ditherFactor);
    clip(f);
}

float CopySign(float x, float s, bool ignoreNegZero = true)
{
#if !defined(SHADER_API_GLES)
    if (ignoreNegZero)
    {
        return (s &gt;= 0) ? abs(x) : -abs(x);
    }
    else
    {
        uint negZero = 0x80000000u;
        uint signBit = negZero &amp; asuint(s);
        return asfloat(BitFieldInsert(negZero, signBit, asuint(x)));
    }
#else
    return (s &gt;= 0) ? abs(x) : -abs(x);
#endif
}

float fade = unity_LODFade.x;
float2 fadeMaskSeed = IN.positionCS.xy;
LODDitheringTransition(fadeMaskSeed, fade);
</code></pre>
<h2 id="ref-37"><a class="header" href="#ref-37">Ref</a></h2>
<ul>
<li><a href="https://docs.unity3d.com/Manual/class-LODGroup.html">https://docs.unity3d.com/Manual/class-LODGroup.html</a></li>
<li><a href="https://github.com/keijiro/CrossFadingLod">https://github.com/keijiro/CrossFadingLod</a></li>
<li><a href="https://blog.naver.com/daehuck/221562275385">https://blog.naver.com/daehuck/221562275385</a></li>
<li><a href="https://youtu.be/giPA3ycc8_M?t=1895">NDC2018 - 'AxE' 클라이언트 최적화와 문제해결-MMORPG를 Unity로 만들 때 겪을 수 있는 이야기</a></li>
<li><a href="https://assetstore.unity.com/packages/add-ons/lcfs-lod-cross-fading-shaders-for-urp-177298?locale=ko-KR#content">https://assetstore.unity.com/packages/add-ons/lcfs-lod-cross-fading-shaders-for-urp-177298?locale=ko-KR#content</a></li>
<li>LOD asset
<ul>
<li><a href="https://assetstore.unity.com/packages/tools/game-toolkits/ultimate-lod-system-mt-automatic-lod-generator-mesh-simplifier-m-170425">Ultimate LOD System MT - Automatic LOD Generator, Mesh Simplifier &amp; More</a></li>
<li><a href="https://assetstore.unity.com/packages/tools/utilities/poly-few-mesh-simplifier-and-auto-lod-generator-160139">Poly Few | Mesh Simplifier and Auto LOD Generator</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cracked-ice"><a class="header" href="#cracked-ice">Cracked Ice</a></h1>
<ul>
<li><a href="https://blog.naver.com/daehuck/222228360615">https://blog.naver.com/daehuck/222228360615</a></li>
<li><a href="https://www.youtube.com/watch?v=rlGNbq5p5CQ">Unity Shadergraph Tutorial - Cracked Ice</a></li>
<li><a href="https://80.lv/articles/how-to-build-cracked-ice-in-material-editor/">https://80.lv/articles/how-to-build-cracked-ice-in-material-editor/</a></li>
</ul>
<p>Parallax쓰면 조금 들어간것처럼 보임. - 이걸 겹겹히 쌓으면 더 깊이 들어간것처럼 보임</p>
<pre><code class="language-hlsl">
baseColor = blend(mainTex, parallax(heightMap), 0.5)

blendNormal(Normal1, strength(Normal2(uv * 0.25), 0.25))

void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
{
    Out = {precision}3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
}

float2 ParallaxSampling(half3 viewDirTS, half scale, float2 uv)
{
    half h = 0.217637;// pow(0.5, 2.2);
    float2 offset = ParallaxOffset1Step(h, scale, viewDirTS);
    return offset;
}

half2 ParallaxMappingUV(TEXTURE2D_PARAM(heightMap, sampler_heightMap), half2 uv, half3 V_TS, half amplitude)
{
    // 높이 맵에서 높이를 구하고,
    half height = SAMPLE_TEXTURE2D(heightMap, sampler_heightMap, uv).r;
    height = height * amplitude - amplitude / 2.0;

    // 시선에 대한 offset을 구한다.
    // 시선은 반대방향임으로 부호는 마이너스(-) 붙여준다.
    // TS.xyz == TS.tbn

    // TS.n에 0.42를 더해주어서 0에 수렴하지 않도록(E가 너무 커지지 않도록) 조정.
    half2 E = -(V_TS.xy / (V_TS.z + 0.42));

    // 근사값이기에 적절한 strength를 곱해주자.
    return uv + E * height;
}

void ParallaxMapping_float(in float amplitude, in float numSteps, in float4 UV, in float3 viewDir, out float4 Out)
{
    float one = 1;
    float4 ParallaxedTexture = (0, 0, 0, 0);
    float4 UV2 = (0, 0, 0, 0);
    for (float d = 0.0; d &lt; amplitude; d += amplitude / numSteps)
    {
        one = one - (1 / numSteps);
        UV2.xy = UV.xy + ParallaxSampling(viewDir, d * 0.01, UV);
        ParallaxedTexture += saturate(SAMPLE_TEXTURE2D_BIAS(_MainTex, SamplerState_Linear_Repeat, UV2.xy, 0)) * (one + (1 / numSteps));
    }
    Out = saturate(ParallaxedTexture);
}

half ParallaxMappingMask(TEXTURE2D_PARAM(maskTex, sampler_maskTex), in half2 uv, in half3 V_TS, in half parallaxOffset, in int iterCount)
{
    half one = 1;
    half parallaxedMask = 0;
    half result = 1;
    half2 parallaxUV;
    half totalOffset = 0.0;
    parallaxOffset = parallaxOffset * -0.001;

    for (int i = 0; i &lt; iterCount; ++i)
    {
        totalOffset += parallaxOffset;
        parallaxUV = uv + half2(V_TS.x * totalOffset, V_TS.y * totalOffset);
        parallaxedMask = SAMPLE_TEXTURE2D(maskTex, sampler_maskTex, parallaxUV).r;
        result *= clamp(parallaxedMask + (i / iterCount), 0, 1);
    }

    return result;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fake-thickness-window"><a class="header" href="#fake-thickness-window">Fake Thickness Window</a></h1>
<ul>
<li>ID맵과 Parallax(ID맵)의 겹쳐지는 부분(cross)을 이용.</li>
</ul>
<pre><code class="language-hlsl">half2 parallaxUV = ParallaxMappingUV(_IdMaskHeightTex, sampler_IdMaskHeightTex, IN.uv, mul(TBN, V), _ParallaxScale * 0.01);

half idMaskTex = SAMPLE_TEXTURE2D(_IdMaskTex, sampler_IdMaskTex, IN.uv).r;
half idMaskParallaxTex = SAMPLE_TEXTURE2D(_IdMaskTex, sampler_IdMaskTex, parallaxUV).r;

half cross = 0;
if (idMaskTex != idMaskParallaxTex)
{
    cross = 1;
}
return half4(cross, cross, cross, 1);
</code></pre>
<ul>
<li>Parallax Mapping</li>
</ul>
<pre><code class="language-hlsl">half2 ParallaxMappingUV(TEXTURE2D_PARAM(heightMap, sampler_heightMap), half2 uv, half3 V_TS, half amplitude)
{
    // 높이 맵에서 높이를 구하고,
    half height = SAMPLE_TEXTURE2D(heightMap, sampler_heightMap, uv).r;
    height = height * amplitude - amplitude / 2.0;

    // 시선에 대한 offset을 구한다.
    // 시선은 반대방향임으로 부호는 마이너스(-) 붙여준다.
    // TS.xyz == TS.tbn

    // TS.n에 0.42를 더해주어서 0에 수렴하지 않도록(E가 너무 커지지 않도록) 조정.
    half2 E = -(V_TS.xy / (V_TS.z + 0.42));

    // 근사값이기에 적절한 strength를 곱해주자.
    return uv + E * height;
}
</code></pre>
<ul>
<li>라스트 오브 어스 2에서
<ul>
<li>ID맵 샘플 + Parallax(ID맵) 샘플 =&gt; cross section</li>
<li>노말맵 샘플
<ul>
<li>diffuse는 cross section 이용해서</li>
<li>specular는 그대로</li>
</ul>
</li>
<li>환경맵 샘플
<ul>
<li>cross section 노말 이용.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ref-38"><a class="header" href="#ref-38">Ref</a></h2>
<ul>
<li><a href="https://www.naughtydog.com/blog/naughty_dog_at_siggraph_2020">https://www.naughtydog.com/blog/naughty_dog_at_siggraph_2020</a></li>
<li><a href="https://youtu.be/tvBIqPHaExQ?t=2729">SIGGRAPH 2020 - Fake Thickness - The Technical Art of The Last of Us Part II by Waylon Brinck and Steven Tang</a></li>
<li><a href="https://blog.naver.com/daehuck/222286264294">daehuck - 라스트 오브 어스2에 쓰인 유리 쉐이더 유니티로 따라해 보기</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="screen-space-decal"><a class="header" href="#screen-space-decal">Screen Space Decal</a></h1>
<ul>
<li>Deferred Decals(Jan Krassnigg, 2010)</li>
<li>Volume Decals (Emil Persson, 2011)</li>
<li>SSD : <a href="https://www.slideshare.net/blindrenderer/screen-space-decals-in-warhammer-40000-space-marine-14699854">SIGGRAPH2012 - ScreenSpaceDecal</a></li>
<li>큐브를 프로젝터처럼 이용, 화면에 데칼을 그린다.</li>
<li>뎁스로부터 포지션을 다시 구축하는 것이므로 <code>Reconstructing position from depth</code>라고도 한다.</li>
</ul>
<ol>
<li>SSD를 제외한 메쉬들을 화면에 그림</li>
<li>SSD 상자를 그림(rasterization)</li>
<li>각 픽셀마다 장면깊이(scene depth)를 읽어옴</li>
<li>그 깊이로부터 3D 위치를 계산함</li>
<li>그 3D 위치가 SSD 상자 밖이면 레젝션(rejection)</li>
<li>그렇지 않으면 데칼 텍스처를 그림</li>
</ol>
<h2 id="ver1-urp"><a class="header" href="#ver1-urp">ver1. URP</a></h2>
<pre><code class="language-hlsl">// NDC에서 depth를 이용 역산하여 데칼 위치를 구하는법.

// vert:
OUT.positionNDC = vertexPositionInput.positionNDC;

// frag:
// ============== 1. 씬뎁스 구하기
half2 uv_Screen = IN.positionNDC.xy / IN.positionNDC.w;
half sceneRawDepth = SampleSceneDepth(uv_Screen);
half sceneEyeDepth = LinearEyeDepth(sceneRawDepth, _ZBufferParams);

// ============== 2. 뎁스로부터 3D위치를 구하기
// positionNDC: [-1, 1]
float2 positionNDC = uv_Screen * 2.0 - 1.0;
half4 positionVS_decal;
positionVS_decal.x = (positionNDC.x * sceneEyeDepth) / unity_CameraProjection._11;
positionVS_decal.y = (positionNDC.y * sceneEyeDepth) / unity_CameraProjection._22;
positionVS_decal.z = -sceneEyeDepth;
positionVS_decal.w = 1;

half4x4 I_MV = mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V);
// positionOS_decal: [-0.5, 0.5] // clip 으로 잘려질것이기에 
half4 positionOS_decal = mul(I_MV, positionVS_decal);

// ============== 3. SSD상자 밖이면 그리지않기
clip(0.5 - abs(positionOS_decal.xyz));

// ============== 4. 데칼 그리기
// uv_decal: [0, 1]
half2 uv_decal = positionOS_decal.xz + 0.5;
half2 uv_MainTex = TRANSFORM_TEX(uv_decal, _MainTex);
half4 mainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv_MainTex);
</code></pre>
<h2 id="ver2-urp"><a class="header" href="#ver2-urp">ver2. URP</a></h2>
<ul>
<li><a href="Environment/./Basic/Depth.html">Depth</a>에선 WorldSpace상 좌표를 이용해서 Depth로부터 위치를 구했는데, 최적화를 위해 Object Space상에서 구함(한눈에 봐서는 어색하지만 따라가다보면 말이 되긴 한다)</li>
</ul>
<pre><code class="language-hlsl">// 오브젝트 공간의 viewRay를 구하고 depth에 맞추어 데칼 위치를 구하는법.

// vert:
float4x4 I_MV = mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V);
OUT.positionOS_camera = mul(I_MV, float4(0, 0, 0, 1)).xyz;

OUT.positionOSw_viewRay.xyz = mul((float3x3)I_MV, -vertexPositionInput.positionVS);
OUT.positionOSw_viewRay.w = vertexPositionInput.positionVS.z;

// frag:
// ============== 1. 씬뎁스 구하기
half2 uv_Screen = IN.positionNDC.xy / IN.positionNDC.w;
half sceneRawDepth = SampleSceneDepth(uv_Screen);
half sceneEyeDepth = LinearEyeDepth(sceneRawDepth, _ZBufferParams);

// ============== 2. 뎁스로부터 3D위치를 구하기
// positionOS_decal: [-0.5, 0.5] // clip 으로 잘려질것이기에
half3 positionOS_decal = IN.positionOS_camera + IN.positionOSw_viewRay.xyz / IN.positionOSw_viewRay.w * sceneEyeDepth;

// ============== 3. SSD상자 밖이면 그리지않기
clip(0.5 - abs(positionOS_decal.xyz));

// ============== 4. 데칼 그리기
// uv_decal: [0, 1]
half2 uv_decal = positionOS_decal.xz + 0.5;
half2 uv_MainTex = TRANSFORM_TEX(uv_decal, _MainTex);
half4 mainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv_MainTex);
</code></pre>
<h2 id="ver-pope"><a class="header" href="#ver-pope">ver. Pope</a></h2>
<ol>
<li>알파블렌딩
<ul>
<li>Blend Factor</li>
</ul>
</li>
<li>움직이는 물체들
<ul>
<li>움직이면 데칼 적용안함(Stencil)</li>
</ul>
</li>
<li>옆면이 늘어나요.... ㅜ.ㅠ
<ul>
<li>투영방향 Gbuffer의 법선방향의 각도이용 리젝션.</li>
<li>NormalThreashold
<ul>
<li>60도(적정값)</li>
<li>180도(리젝션안함)</li>
</ul>
</li>
</ul>
</li>
<li>짤린(clipped) 데칼
<ul>
<li>데칼상자범위가 카메라를 뚷어버리면, 뒷면을 그림(깊이 데스트 방향을 뒤집어서)</li>
<li>회피책
<ul>
<li>엄청 얇게</li>
<li>엄청 두껍게(성능 떨어짐)</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="language-hlsl">// 3. 옆면이 늘어나요.... ㅜ.ㅠ

// 정점 셰이더에서 데칼 상자의 방위를 구함:
output.Orientation = normalize(WorldView[1].xyz);

gNormalThreashold == cos(각도)

// 픽셀 셰이더에서 GBuffer 법선을 읽어와 리젝션 테스트
float3 normal = DecodeGbufferNormal(tex2D(GNormalMap, depth_uv));
clip(dot(normal, orientation) - gNormalThreshold);
</code></pre>
<h2 id="fadeout"><a class="header" href="#fadeout">fadeout</a></h2>
<ul>
<li><a href="https://web.archive.org/web/20170508024615/http://ttmayrin.tistory.com/37">http://ttmayrin.tistory.com/37</a></li>
</ul>
<p>수직인 지형에서의 경계면이 잘리는 거 fadeout</p>
<pre><code class="language-hlsl">// 유니티는 Y가 높이이기에
// #define HALF_Y 0.25f
// OutColor *= (1.f - max((positionOS_decal.y - HALF_Y) / HALF_Y, 0.f));
OutColor *= (1.f - max(4 * positionOS_decal.y - 1, 0.f));
</code></pre>
<h2 id="컨택트-섀도contact-shadow"><a class="header" href="#컨택트-섀도contact-shadow">컨택트 섀도(Contact Shadow)</a></h2>
<ul>
<li><a href="https://www.slideshare.net/devcatpublications/10ndc2012">전형규, 가성비 좋은 렌더링 테크닉 10선, NDC2012</a></li>
</ul>
<pre><code class="language-hlsl">float4 ContactShadowPSMain(PSInput input) : COLOR
{
  input.screenTC.xyz /= input.screenTC.w;

  float depthSample = tex2D(DepthSampler, input.screenTC.xy).x;
  float sceneDepth = GetClipDistance(depthSample);
  float3 scenePos = FromScreenToView(input.screenTC.xy, sceneDepth);

  float shadow = length(scenePos - input.origin) / (input.attributes.x + 0.001f);
  shadow = pow(saturate(1 - shadow), 2);

  const float radiusInMeter = input.attributes.x;
  float aoIntensity = saturate(4.0f - 2.5 * radiusInMeter);

  shadow *= 0.7f * input.attributes.y;

  return float4(shadow, 0.0f, shadow * aoIntensity, 0);
}
</code></pre>
<h2 id="ref-39"><a class="header" href="#ref-39">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/blindrendererkr/40000">KGC2012 - 스크린 스페이스 데칼에 대해 자세히 알아보자(워햄머 40,000: 스페이스 마린)</a>
<ul>
<li><a href="https://www.slideshare.net/blindrenderer/rendering-tech-of-space-marinekgc-2011">KGC 2011</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=RdN06E6Xn9E&amp;t=2153s">GDC2016 - Low Complexity, High Fidelity: The Rendering of INSIDE</a></li>
<li><a href="https://ubm-twvideo01.s3.amazonaws.com/o1/vault/gdc2012/slides/Programming%20Track/Robin_Marshall_EffectsTechniquesUsed.pdf">GDC2012 - Effects Techniques Used in Uncharted 3: Drake's Deception</a></li>
<li><a href="https://github.com/ColinLeung-NiloCat/UnityURPUnlitScreenSpaceDecalShader">https://github.com/ColinLeung-NiloCat/UnityURPUnlitScreenSpaceDecalShader</a>
<ul>
<li><a href="https://assetstore.unity.com/packages/vfx/shaders/lux-urp-essentials-150355">https://assetstore.unity.com/packages/vfx/shaders/lux-urp-essentials-150355</a></li>
</ul>
</li>
<li><a href="https://blog.theknightsofunity.com/make-it-snow-fast-screen-space-snow-shader/">https://blog.theknightsofunity.com/make-it-snow-fast-screen-space-snow-shader/</a></li>
<li><a href="https://samdriver.xyz/article/decal-render-intro">https://samdriver.xyz/article/decal-render-intro</a></li>
<li><a href="http://www.ozone3d.net/tutorials/glsl_texturing_p08.php#part_8">http://www.ozone3d.net/tutorials/glsl_texturing_p08.php#part_8</a>
<ul>
<li><a href="https://diehard98.tistory.com/entry/Projective-Texture-Mapping-with-OpenGL-GLSL">https://diehard98.tistory.com/entry/Projective-Texture-Mapping-with-OpenGL-GLSL</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/puppet_master/article/details/84310361">https://blog.csdn.net/puppet_master/article/details/84310361</a></li>
<li><a href="https://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/">https://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rain"><a class="header" href="#rain">Rain</a></h1>
<ul>
<li>메쉬 생성해서 텍스쳐 입히고 메쉬 자체를 흘려내리기.</li>
<li>Geometry Shader이용하기</li>
<li>PostProcessing으로 처리하기(부하크고 각도 변화 힘듬)</li>
<li>파티클로 처리하기
<ul>
<li>컬링 유의</li>
<li><a href="https://blog.unity.com/technology/unitytips-particlesystem-performance-culling">https://blog.unity.com/technology/unitytips-particlesystem-performance-culling</a></li>
</ul>
</li>
</ul>
<h2 id="ref-40"><a class="header" href="#ref-40">Ref</a></h2>
<ul>
<li><a href="https://github.com/tsugi/exampleunityangrybots/tree/master/Assets/Scripts/Rain">https://github.com/tsugi/exampleunityangrybots/tree/master/Assets/Scripts/Rain</a></li>
<li><a href="https://blog-api.unity.com/sites/default/files/2011/08/FastMobileShaders_siggraph2011.pdf">SIGGRAPH2011-FastMobileShaders</a></li>
<li><a href="https://medium.com/@andresgomezjr89/rain-snow-with-geometry-shaders-in-unity-83a757b767c1">Rain And Snow Effect With Geometry Shaders In Unity</a>
<ul>
<li><a href="https://github.com/tiredamage42/RainSnowGeometryShader">https://github.com/tiredamage42/RainSnowGeometryShader</a></li>
<li><a href="https://seblagarde.wordpress.com/2012/12/27/water-drop-2a-dynamic-rain-and-its-effects/">https://seblagarde.wordpress.com/2012/12/27/water-drop-2a-dynamic-rain-and-its-effects/</a></li>
</ul>
</li>
<li>Artist-directable Real-Time Rain Rendering in City Environments
<ul>
<li>SIGGRAPH2006</li>
<li>GDC06</li>
</ul>
</li>
<li>ShaderX7 Advanced Rendering Techniques
<ul>
<li>5.1 Dynamic Weather Effects</li>
</ul>
</li>
<li><a href="https://www1.cs.columbia.edu/CAVE/databases/rain_streak_db/rain_streak.php">rain_streak 이미지들</a></li>
<li><a href="https://developer.download.nvidia.com/SDK/10/direct3d/samples.html#rain">https://developer.download.nvidia.com/SDK/10/direct3d/samples.html#rain</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sky"><a class="header" href="#sky">Sky</a></h1>
<h2 id="skybox-메쉬-형태"><a class="header" href="#skybox-메쉬-형태">Skybox 메쉬 형태</a></h2>
<ul>
<li>
<p>Cube, Sphere, HemiSphere, Ring, Plane</p>
</li>
<li>
<p>유니티 Shader별 사용 메쉬 형태</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Shader</th><th>Mesh</th><th>draw</th></tr></thead><tbody>
<tr><td>Mobile/Skybox</td><td>Cube</td><td>Draw(6) * 6</td></tr>
<tr><td>Skybox/6 Sided</td><td>Cube</td><td>Draw(6) * 6</td></tr>
<tr><td>Skybox/Cubemap</td><td>Sphere</td><td>Draw(5040)</td></tr>
<tr><td>Skybox/Panoramic</td><td>Sphere</td><td>Draw(5040)</td></tr>
<tr><td>Skybox/Procedural</td><td>Sphere</td><td>Draw(5040)</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>렌더독으로 본 유니티의 Sphere Sky Mesh</p>
<ul>
<li>일반 Sphere 와는 다르게, 버텍스 갯수는 적게 그리고 수평선 부분이 조금 디테일에 힘을 줬다.</li>
</ul>
<p><img src="Environment/../res/renderdoc_skyboxmesh.png" alt="renderdoc_skyboxmesh.png" /></p>
</li>
</ul>
<h2 id="유니티-skybox셰이더-작성시-주의점"><a class="header" href="#유니티-skybox셰이더-작성시-주의점">유니티 Skybox셰이더 작성시 주의점</a></h2>
<ul>
<li>유니티 Skybox 설정 : <code>Window &gt; Rendering &gt; Lighting &gt; Environment</code>
<ul>
<li><code>unity_SpecCube0</code>가 위에서 설정된 메테리얼로 스카이박스를 렌더링함.(<code>Camera &gt; Background Type</code>과는 상관없음)</li>
</ul>
</li>
<li>URP 환경이라도 Built-in(legacy)의 기본 Pass의 태그값 <code>"LightMode" = "ForwardBase"</code>로 하여야만 동작한다.</li>
</ul>
<h2 id="유니티의-skybox"><a class="header" href="#유니티의-skybox">유니티의 Skybox</a></h2>
<ul>
<li>유니티에서는 Skybox의 메쉬를 지정할 수 있는 방법이 없다.(2021.09.23 기준)</li>
<li>유니티 Skybox 설정을 안따르면 ReflectionProbe(unity_SpecCube0)를 다루기 껄끄러워진다.
<ul>
<li><code>Window &gt; Rendering &gt; Lighting &gt; Environment &gt; Environment Reflections &gt; Source &gt; Custom</code> 으로 처리 가능.</li>
</ul>
</li>
</ul>
<h2 id="skybox-메쉬-조합"><a class="header" href="#skybox-메쉬-조합">Skybox 메쉬 조합</a></h2>
<ul>
<li><a href="https://80.lv/articles/how-to-create-skies-for-3d-games/">How to Create Skies for 3D Games?</a></li>
</ul>
<p>구름을 표현하기 위해 돔형태의 메쉬, 링형 매쉬, 평면 매쉬를 이용했다.</p>
<p><img src="Environment/../res/skybox.jpg" alt="skybox.jpg" /></p>
<p><img src="Environment/../res/skybox2.jpg" alt="skybox2.jpg" /></p>
<h2 id="case-study"><a class="header" href="#case-study">Case Study</a></h2>
<pre><code class="language-hlsl">half daytimeGradient            = max(0, L_Sun.y);                   // 낮시간 변화 // max(0, dot(-L, DIR_DOWN));
half skybox_MidTopGradient      = max(0, -V.y);                      // 하늘쪽 변화 // max(0, dot(-V, DIR_UP));
half skybox_HorizBottomGradient = pow(1 - skybox_MidTopGradient, 8); // 바닥 + 수평 변화



// 낮시간 하늘의 3단계 변화
// - 카메라가 스카이박스 안쪽에 있으니 `-V`를 시켜주고, 하늘(Up)쪽으로 변화를 넣는다.
// - 수평선은 역으로해서 역변화를 얻음.
half3 daytimeSkyMiddleColor       = lerp(_SkyColor_Sunset, _SkyColor_DaytimeMiddle, daytimeGradient);
half3 daytimeSkyMiddleBottomColor = lerp(daytimeSkyMiddleColor, _SkyColor_DaytimeBottom, skybox_HorizBottomGradient);
half3 daytimeSkyGradientColor     = lerp(daytimeSkyMiddleBottomColor, _SkyColor_DaytimeTop, skybox_MidTopGradient);



// 밤낮을 표현하기 위해 빛이 땅을 바라볼때 변화량([0, 1]) 이용.
half3 skyNightDayColor = lerp(_SkyColor_Night, daytimeSkyGradientColor, daytimeGradient);



// 빛이 바라보는 반대 방향에 해를 위치 시킨다.
half sunGradient = dot(-L_Sun, V);
half sun = pow(sunGradient, 20);


// 노을의 빛의 퍼짐을 표현하기 위해, 노을색과 붉기를 조절한 빛의 색을 섞는다.
half _SunsetRedness = 0.5; // [0, 1]
half invRedness = 1 - _SunsetRedness;
half3 redishLightColor;
redishLightColor.r = IN.colorLight.r;
redishLightColor.g = IN.colorLight.g * invRedness;
redishLightColor.b = IN.colorLight.b * invRedness * 0.5;
half3 sunsetColor = lerp(_SkyColor_Sunset, redishColor, sun);



// 해 위치를 빛 방향과 같게 조정하면
// 케릭터에 조명효과를 다르게 주고 싶어 불가피하게 빛 방향을 바꿔 버리면,
// 의도치 않도록 해 위치가 바뀌어 버릴 수 있다.
_ControlledDaytime // [0, 1]
#define TWO_PI            6.28318530717958647693  // com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl
#define SHORT_TWO_PI      6.2831853

half rad =  _ControlledDaytime * SHORT_TWO_PI;
half s;
half c;
sincos(rad, s, c);
OUT.L_Sun.x = -c;
OUT.L_Sun.y = s;
OUT.L_Sun.z = 0;

|                       | 0   | 90   | 180 | 270  | 360    |
| --------------------- | --- | ---- | --- | ---- | ------ |
| _ControlTime          | 0   | 0.25 | 0.5 | 0.75 | 1      |
| _ControlTime x TWO_PI | 0   |      | PI  |      | TWO_PI |
| x (-cos)              | -1  | 0    | 1   | 0    | -1     |
| y (sin)               | 0   | 1    | 0   | -1   | 0      |

</code></pre>
<h2 id="기타-코드-조각들"><a class="header" href="#기타-코드-조각들">기타 코드 조각들</a></h2>
<pre><code class="language-hlsl">// ref: [mapping texture uvs to sphere for skybox](https://gamedev.stackexchange.com/questions/189357/mapping-texture-uvs-to-sphere-for-skybox)
// ref: [Correcting projection of 360° content onto a sphere - distortion at the poles](https://gamedev.stackexchange.com/questions/148167/correcting-projection-of-360-content-onto-a-sphere-distortion-at-the-poles/148178#148178)

uv.x = (PI + atan2(positionWS.x, positionWS.z)) * INV_TWO_PI;
uv.y = uv.y * 0.5 + 0.5
</code></pre>
<pre><code class="language-hlsl">// ref: [ARM - The Ice Cave demo](https://developer.arm.com/documentation/102259/0100/Procedural-skybox)

half3 _SunPosition;
half3 _SunColor;
half _SunDegree;    // [0.0, 1.0], corresponds to a sun of diameter of 5 degrees: cos(5 degrees) = 0.995

half4 SampleSun(in half3 viewDir, in half alpha)
{
    // 원형 해
    half sunContribution = dot(viewDir,_SunPosition);

    half sunDistanceFade = smoothstep(_SunDegree - (0.025 * alpha), 1.0, sunContribution);
    half sunOcclusionFade = clamp(0.9 - alpha, 0.0, 1.0);
    half3 sunColorResult = sunDistanceFade * sunOcclusionFade * _SunColor;
    return half4(sunColorResult, 1.0);
}
</code></pre>
<pre><code class="language-hlsl">// ['Infinite' sky shader for Unity](https://aras-p.info/blog/2019/02/01/Infinite-sky-shader-for-Unity/)
// 유니티는 "reversed-Z projection"을 이용하지만, "infinite projection"은 아니다

#if defined(UNITY_REVERSED_Z)
// when using reversed-Z, make the Z be just a tiny
// bit above 0.0
OUT.positionCS.z = 1.0e-9f;
#else
// when not using reversed-Z, make Z/W be just a tiny
// bit below 1.0
OUT.positionCS.z = o.positionCS.w - 1.0e-6f;
#endif
</code></pre>
<h2 id="todo-1"><a class="header" href="#todo-1">TODO</a></h2>
<ul>
<li>구름 그림자
<ul>
<li><a href="https://github.com/EntroPi-Games/Unity-Cloud-Shadows/">https://github.com/EntroPi-Games/Unity-Cloud-Shadows/</a></li>
</ul>
</li>
</ul>
<h2 id="ref-41"><a class="header" href="#ref-41">Ref</a></h2>
<ul>
<li><a href="https://github.com/TwoTailsGames/Unity-Built-in-Shaders/blob/master/DefaultResourcesExtra/Skybox-Procedural.shader">Unity's built-in Skybox-Procedural.shader</a></li>
<li><a href="https://www.slideshare.net/ajinkim/ss-58266584">마른 하늘에 날구름 넣기</a></li>
<li><a href="https://www.slideshare.net/valhashi/2011-03-gametechtadptforpdf">[TA] 테라에 사용된 렌더링 테크닉 - 임신형 (valhashi)</a></li>
<li><a href="https://www.e2gamedev.com/skybox">Procedural Skybox - Evan edwards</a></li>
<li><a href="https://80.lv/articles/easysky-breakdown-of-a-procedural-skybox-for-ue4/">EasySky: Breakdown of a Procedural Skybox for UE4</a></li>
<li><a href="https://www.youtube.com/watch?v=o66p1QDH7aI">GDC2014  - Moving the Heavens: An Artistic and Technical Look at the Skies of The Last of Us</a></li>
<li><a href="https://medium.com/@jannik_boysen/procedural-skybox-shader-137f6b0cb77c">Reaching for the stars - Let’s create a procedural skybox shader with Unity’s Shader Graph!</a></li>
<li>Unity ShaderGraph Procedural Skybox Tutorial
<ul>
<li><a href="https://timcoster.com/2019/09/09/tileable-clouds-texture/">cloud texture</a></li>
<li><a href="https://timcoster.com/2019/09/03/unity-shadergraph-skybox-quick-tutorial/">pt1</a></li>
<li><a href="https://timcoster.com/2020/02/26/unity-shadergraph-procedural-skybox-tutorial-pt-2-day-night-cycle/">pt2</a></li>
</ul>
</li>
<li>Rastertek's Terrain Tutorial
<ul>
<li>Tutorial 10: Sky Domes : <a href="http://www.rastertek.com/tertut10.html">원문</a>, <a href="https://copynull.tistory.com/313">번역</a></li>
<li>Tutorial 11: Bitmap Clouds : <a href="http://www.rastertek.com/tertut11.html">원문</a>, <a href="https://copynull.tistory.com/314">번역</a></li>
<li>Tutorial 12: Perturbed Clouds : <a href="http://www.rastertek.com/tertut12.html">원문</a>, <a href="https://copynull.tistory.com/315">번역</a></li>
</ul>
</li>
<li><a href="http://cr4zyb4st4rd.co.uk/SkyShader.html">Creating a unique animated sky shader for UT3/UDK</a> - <a href="http://cr4zyb4st4rd.co.uk/SkyShader/Cr4zys_Cloud_Textures.rar">Cr4zys_Cloud_Textures.rar</a></li>
<li><a href="https://www.youtube.com/watch?v=YwzOMHXYFyw">Maya - Skydome Techniques</a></li>
<li>Unity Assets
<ul>
<li><a href="https://assetstore.unity.com/packages/tools/particles-effects/tenkoku-dynamic-sky-34435">https://assetstore.unity.com/packages/tools/particles-effects/tenkoku-dynamic-sky-34435</a></li>
<li><a href="https://assetstore.unity.com/packages/2d/textures-materials/sky/procedural-sky-builtin-lwrp-urp-jupiter-159992">https://assetstore.unity.com/packages/2d/textures-materials/sky/procedural-sky-builtin-lwrp-urp-jupiter-159992</a></li>
<li><a href="https://assetstore.unity.com/packages/tools/particles-effects/azure-sky-dynamic-skybox-36050">https://assetstore.unity.com/packages/tools/particles-effects/azure-sky-dynamic-skybox-36050</a></li>
</ul>
</li>
<li><a href="https://simul.co/">https://simul.co/</a></li>
<li><a href="https://github.com/shadowlenz/Procedural.SkyBox">https://github.com/shadowlenz/Procedural.SkyBox</a></li>
<li><a href="https://github.com/SebLague/Clouds">https://github.com/SebLague/Clouds</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=4QOcCGI6xOU">https://www.youtube.com/watch?v=4QOcCGI6xOU</a></li>
</ul>
</li>
<li><a href="https://guildofwriters.org/wiki/Adding_Atmosphere">https://guildofwriters.org/wiki/Adding_Atmosphere</a></li>
<li><a href="http://walkingfat.com/volumetric-clouds-%e4%bd%93%e7%a7%af%e4%ba%91%e7%9a%84%e5%81%9a%e6%b3%95/">Volumetric Clouds – 体积云的做法</a></li>
<li>천체리소스 : <a href="https://pngtree.com/so/celestial">https://pngtree.com/so/celestial</a></li>
<li>ShaderX3 Advanced Rendering with DirectX and OpenGL
<ul>
<li>8.4 Volumetric Clouds</li>
</ul>
</li>
<li>ShaderX2 Shader Programming Tips and Tricks with DirectX 9
<ul>
<li>Advanced Sky Dome Rendering</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="_grass"><a class="header" href="#_grass">_Grass</a></h1>
<ul>
<li><a href="https://roystan.net/articles/grass-shader.html">https://roystan.net/articles/grass-shader.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="물"><a class="header" href="#물">물</a></h1>
<ul>
<li>
<p><a href="https://ateliersera.blog.me/220413097549">https://ateliersera.blog.me/220413097549</a></p>
</li>
<li>
<p><a href="https://www.ronja-tutorials.com/2018/11/03/river.html">https://www.ronja-tutorials.com/2018/11/03/river.html</a></p>
</li>
<li>
<p><a href="https://alexanderameye.github.io/simple-water.html">https://alexanderameye.github.io/simple-water.html</a></p>
</li>
<li>
<p><a href="https://darkcatgame.tistory.com/30?category=806332">https://darkcatgame.tistory.com/30?category=806332</a></p>
</li>
<li>
<p><a href="https://github.com/simplestargame/UniversalOceanShaderGraph">https://github.com/simplestargame/UniversalOceanShaderGraph</a></p>
</li>
<li>
<p><a href="https://www.gamedeveloper.com/programming/water-interaction-model-for-boats-in-video-games-part-2">https://www.gamedeveloper.com/programming/water-interaction-model-for-boats-in-video-games-part-2</a></p>
</li>
<li>
<p><a href="https://www.e2gamedev.com/water-buoyancy">https://www.e2gamedev.com/water-buoyancy</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=PH9q0HNBjT4">Acerola - Rendering Water With Sine Waves</a></p>
</li>
<li>
<p><a href="https://youtu.be/yPfagLeUa7k?si=n9owb07c8P-rgG8c">Acerola - I Tried Simulating The Entire Ocean</a></p>
</li>
<li>
<p><a href="https://youtu.be/kGEqaX4Y4bQ?si=IyHfueQ_X_CiNIrN">Ocean waves simulation with Fast Fourier transform</a></p>
</li>
<li>
<p><a href="https://www.shadertoy.com/view/MdXyzX">Very fast procedural ocean</a></p>
</li>
<li>
<p>http://peerplay.nl/ripple-water-shader/</p>
</li>
<li>
<p>rain</p>
<ul>
<li>https://tympanus.net/codrops/2015/11/04/rain-water-effect-experiments/</li>
</ul>
</li>
<li>
<p>위치</p>
<ul>
<li>sin을 이용한 리니어 방식
<ul>
<li>linear wave : y = y - Amplitude * sin(Frequency * x - Phase)</li>
</ul>
</li>
<li>noise를 이용한 방식</li>
</ul>
</li>
<li>
<p>디테일</p>
<ul>
<li>노말맵
<ul>
<li>1장 - 단조로움</li>
<li>2장 - 역방향으로 하고 합친다
<ul>
<li>n = n1 + n2 * 0.5 * (0.5, 0.5, 1)</li>
</ul>
</li>
</ul>
</li>
<li>버텍스칼라 가중치</li>
</ul>
</li>
<li>
<p>주의해야할 점</p>
<ul>
<li>너무 단순히 만들면 타일링 패턴으로, 부자연스럽게 보임</li>
</ul>
</li>
</ul>
<h2 id="바다강"><a class="header" href="#바다강">바다/강</a></h2>
<ul>
<li>특징 짚기
<ul>
<li>물결</li>
<li>거품
<ul>
<li>sea form
<ul>
<li>오브젝트 상호작용은 깊이맵 이용</li>
</ul>
</li>
<li>sea spray</li>
</ul>
</li>
<li>거리 가까울때 투명</li>
<li>거리 멀때 거울처럼 반사
<ul>
<li>cubemap ? Planar Reflection</li>
</ul>
</li>
<li>수면 아래 Caustic
<ul>
<li>카메라 앞에 커스틱 매쉬를 둬서 처리</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="셰이더-참고-단어"><a class="header" href="#셰이더-참고-단어">셰이더 참고 단어</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Amplitude</td><td>웨이브 진폭(amplitude)</td></tr>
<tr><td>Caustic</td><td>커스틱. 반사/굴절광이 다른 물체에 맺히는 특성</td></tr>
</tbody></table>
</div>
<h2 id="ref-42"><a class="header" href="#ref-42">Ref</a></h2>
<ul>
<li>
<p>gpugems 1</p>
<ul>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models">Chapter 1. Effective Water Simulation from Physical Models</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-2-rendering-water-caustics">Chapter 2. Rendering Water Caustics</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-42-deformers">Chapter 42. Deformers</a></li>
</ul>
</li>
<li>
<p>gpugems 2</p>
<ul>
<li><a href="https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-18-using-vertex-texture-displacement">Chapter 18. Using Vertex Texture Displacement for Realistic Water Rendering</a>
<ul>
<li><a href="https://blog.naver.com/lifeisforu/80026280288">번역</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Boat Attack</p>
<ul>
<li>https://github.com/Unity-Technologies/BoatAttack</li>
<li><a href="https://www.youtube.com/watch?v=LyiRALUOQqo&amp;list=PL412Ym60h6uvBOpPSP-tcnINt971OD7ZC">모바일 플랫폼을 위한 URP에서의 물 표현. 모바일 플랫폼을 위한 물 표현 (1/6)</a></li>
<li>2 Gerstner wave - 카메라를 따라다니게</li>
<li>3 Planar Reflection</li>
<li>4 Caustic - 카메라를 따라다니게</li>
<li>5 Fresnel</li>
</ul>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Trochoidal_wave">https://en.wikipedia.org/wiki/Trochoidal_wave</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=ofLYUlhoxAI">Water Caustics Shader - Unity </a></p>
<ul>
<li><a href="https://github.com/z4gon/water-caustics-shader-unity">https://github.com/z4gon/water-caustics-shader-unity</a></li>
</ul>
</li>
<li>
<p>Deep-Water Animation and Rendering</p>
<ul>
<li><a href="https://www.semanticscholar.org/paper/Deep-Water-Animation-and-Rendering-Jensen-Goli%C3%A1%C5%A1/b82acf6a543aff6a3581b1e7ad02efb88b501750">https://www.semanticscholar.org/paper/Deep-Water-Animation-and-Rendering-Jensen-Goli%C3%A1%C5%A1/b82acf6a543aff6a3581b1e7ad02efb88b501750</a></li>
<li><a href="https://blog.naver.com/lifeisforu/80104510751">번역</a></li>
</ul>
</li>
<li>
<p>https://catlikecoding.com/unity/tutorials/flow/waves/</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=y9BOz2dFZzs">[SIGGRAPH2018] The Technical Art of Sea of Thieves</a></p>
<ul>
<li>https://history.siggraph.org/learning/the-technical-art-of-sea-of-thieves/</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">float3 GerstnerWave (
      float4 wave,
      float3 p,
      inout float3 tangent,
      inout float3 binormal)
{
  float steepness = wave.z;
  float wavelength = wave.w;
 
  float  k = 2 * UNITY_PI / wavelength;
  float  c = sqrt(9.8 / k);
  float2 d = normalize(wave.xy);
  float  f = k * (dot(d, p.xz) - c * _Time.y);
  float  a = steepness / k;
  
  float sinf;
  float cosf;
  sincos(f, sinf, cosf);

  tangent += float3(
    -d.x * d.x * (steepness * sinf),
    d.x * (steepness * cosf),
    -d.x * d.y * (steepness * sinf)
  );
  binormal += float3(
    -d.x * d.y * (steepness * sinf),
    d.y * (steepness * cosf),
    -d.y * d.y * (steepness * sinf)
  );
  
  return float3(
    d.x * (a * cosf),
    a * sinf,
    d.y * (a * cosf)
  );
}
</code></pre>
<p>퓨리에변환
fourier transform
https://en.wikipedia.org/wiki/Fourier_transform</p>
<p>웨블레트 (Wavelet)
웨이블릿이란 0을 중심으로 증가와 감소를 반복하는 진폭을 수반한 파동 같은 진동을 말한다</p>
<p>phillips spectrum
https://github.com/Scrawk/Phillips-Ocean</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="얼음"><a class="header" href="#얼음">얼음</a></h1>
<p><a href="https://www.youtube.com/watch?v=Gym5JWHgjkk">Unity Shader Graph - Ice Tutorial</a></p>
<p>ScreenColor
add Fresnel</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interior-mapping"><a class="header" href="#interior-mapping">Interior Mapping</a></h1>
<ul>
<li>인테리어 맵핑</li>
<li><a href="https://www.youtube.com/watch?v=dfWxshvTo60">youtube: Overwatch: фейковое окно на King's Row (fake window)</a></li>
</ul>
<p>잘 모르겠다...</p>
<h2 id="ref-43"><a class="header" href="#ref-43">Ref</a></h2>
<ul>
<li><a href="https://chulin28ho.tistory.com/521">AABB(Axis Aligned Bounding Box) 방식의 레이 충돌공식</a></li>
<li>coposuke 설명(일본어)
<ul>
<li><a href="https://coposuke.hateblo.jp/entry/2018/12/11/064755">https://coposuke.hateblo.jp/entry/2018/12/11/064755</a></li>
<li><a href="https://coposuke.hateblo.jp/entry/2020/12/24/003734">https://coposuke.hateblo.jp/entry/2020/12/24/003734</a></li>
</ul>
</li>
<li><a href="https://forum.unity.com/threads/interior-mapping.424676/#post-2751518">https://forum.unity.com/threads/interior-mapping.424676/#post-2751518</a></li>
<li><a href="https://forums.ogre3d.org/viewtopic.php?t=30275">https://forums.ogre3d.org/viewtopic.php?t=30275</a></li>
<li>gamasutra
<ul>
<li><a href="https://www.gamasutra.com/view/news/332409/Game_Tech_Deep_Dive_A_window_into_Playground_Games_latest_shader_development.php">Game Tech Deep Dive: A window into Playground Games' latest shader development</a></li>
<li><a href="https://www.gamasutra.com/blogs/JoostVanDongen/20180925/327159/Interior_Mapping_rendering_real_rooms_without_geometry.php">Interior Mapping: rendering real rooms without geometry</a></li>
</ul>
</li>
<li><a href="https://www.alanzucconi.com/2018/09/10/shader-showcase-9/">Shader Showcase Saturday #9: Interior Mapping</a></li>
<li><a href="http://www.andrewwillmott.com/talks/from-aaa-to-indie">From AAA to Indie</a>
<ul>
<li><a href="https://youtu.be/_x88tvkAGuo?t=59">https://youtu.be/_x88tvkAGuo?t=59</a></li>
</ul>
</li>
<li>assetstore
<ul>
<li><a href="https://assetstore.unity.com/packages/vfx/shaders/fake-interiors-free-104029">Fake Interiors FREE</a></li>
<li><a href="https://assetstore.unity.com/packages/vfx/shaders/toz-interior-shaders-35003">TOZ Interior Shaders</a></li>
</ul>
</li>
<li><a href="http://interiormapping.oogst3d.net/">http://interiormapping.oogst3d.net/</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=9Jy3cXwR7Ws">Interior mapping with Godot - Pedro J. Estébanez | GodotCon Brussels 2020</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=9zq3mcFcofk">Interior Mapping shader</a> (<a href="https://drive.google.com/file/d/1zh_yOfxnim6esSMHx-hD9lULOb21Wl4a/view">.unitypackage</a>)</li>
<li>andrewgotow(<a href="https://andrewgotow.com/2018/09/09/interior-mapping-part-1/">1</a>, <a href="https://andrewgotow.com/2018/09/09/interior-mapping-part-2/">2</a>, <a href="https://andrewgotow.com/2019/02/27/interior-mapping-part-3/">3</a>)</li>
<li><a href="https://docs.unrealengine.com/udk/Three/DevelopmentKitGemsInteriorMapping.html">https://docs.unrealengine.com/udk/Three/DevelopmentKitGemsInteriorMapping.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vegetation"><a class="header" href="#vegetation">Vegetation</a></h1>
<ul>
<li>Mesh의 중앙에서 vertex사이의 거리 이용.</li>
<li>작은것은 r채널만 이용해서 흔들거려도 될듯</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>r</td><td>the stiffness of leaves' edges</td></tr>
<tr><td>g</td><td>per-leaf phase variation</td></tr>
<tr><td>b</td><td>overall stiffness of the leaves</td></tr>
<tr><td>a</td><td>precomputed ambient occlusion</td></tr>
</tbody></table>
</div>
<h2 id="ref-44"><a class="header" href="#ref-44">Ref</a></h2>
<ul>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-16-vegetation-procedural-animation-and-shading-crysis">https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-16-vegetation-procedural-animation-and-shading-crysis</a></li>
<li>https://docs.unity3d.com/Packages/com.unity.polybrush@1.0/manual/modes_color.html
<ul>
<li><a href="https://youtu.be/JQyntL-Z5bM?t=448">u: Polybrush Intro and Tutorial</a></li>
</ul>
</li>
<li><a href="https://blogs.unity3d.com/kr/2018/06/29/book-of-the-dead-quixel-wind-scene-building-and-content-optimization-tricks/">https://blogs.unity3d.com/kr/2018/06/29/book-of-the-dead-quixel-wind-scene-building-and-content-optimization-tricks/</a></li>
<li><a href="https://blogs.unity3d.com/2018/08/07/shader-graph-updates-and-sample-project/">https://blogs.unity3d.com/2018/08/07/shader-graph-updates-and-sample-project/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="billboard"><a class="header" href="#billboard">Billboard</a></h1>
<h2 id="all-axis--spherical"><a class="header" href="#all-axis--spherical">All-Axis / Spherical</a></h2>
<ul>
<li>뷰까지 오브젝트 정보(회전/확대)를 들고 가는게 아니라, 뷰공간에서 오브젝트의 정보를 더해 화면을 바라보게 만든다.</li>
</ul>
<pre><code class="language-hlsl">float3 positionVS = TransformWorldToView(UNITY_MATRIX_M._m03_m13_m23);
positionVS += float3(IN.positionOS.xy * _Scale, 0);

OUT.positionCS = TransformWViewToHClip(positionVS);
</code></pre>
<h2 id="y-axis--cylindrical"><a class="header" href="#y-axis--cylindrical">Y-Axis / Cylindrical</a></h2>
<pre><code class="language-hlsl">// 개념위주, 장황하게
float3 viewDirWS = -GetWorldSpaceViewDir(UNITY_MATRIX_M._m03_m13_m23);

float toViewAngleY = atan2(viewDirWS.x, viewDirWS.z);
float s = sin(toViewAngleY);
float c = cos(toViewAngleY);
float3x3 ROTATE_Y_AXIS_M = {
    c, 0, s,
    0, 1, 0,
    -s, 0, c
};

float3 positionOS = mul(ROTATE_Y_AXIS_M, IN.positionOS.xyz);
</code></pre>
<pre><code class="language-hlsl">// 간소화
float2 viewDirWS = -normalize(
    GetCameraPositionWS().xz - UNITY_MATRIX_M._m03_m23
);

float2x2 ROTATE_Y_AXIS_M = {
    viewDirWS.y, viewDirWS.x,
    -viewDirWS.x, viewDirWS.y
};

float3 positionOS;
positionOS.xz = mul(ROTATE_Y_AXIS_M, IN.positionOS.xz);
positionOS.y = IN.positionOS.y;
</code></pre>
<h2 id="ref-45"><a class="header" href="#ref-45">Ref</a></h2>
<ul>
<li><a href="https://www.sysnet.pe.kr/2/0/11641">https://www.sysnet.pe.kr/2/0/11641</a></li>
<li><a href="https://en.wikibooks.org/wiki/Cg_Programming/Unity/Billboards">https://en.wikibooks.org/wiki/Cg_Programming/Unity/Billboards</a></li>
<li><a href="https://80.lv/articles/the-shader-approach-to-billboarding/">https://80.lv/articles/the-shader-approach-to-billboarding/</a></li>
<li><a href="http://unity3d.ru/distribution/viewtopic.php?f=35&amp;t=24903">http://unity3d.ru/distribution/viewtopic.php?f=35&amp;t=24903</a></li>
<li><a href="https://forum.unity.com/threads/billboard-shader-using-vertex-offsets-in-color-or-uv2-data.192652/">https://forum.unity.com/threads/billboard-shader-using-vertex-offsets-in-color-or-uv2-data.192652/</a></li>
<li><a href="https://gam0022.net/blog/2019/07/23/unity-y-axis-billboard-shader/">https://gam0022.net/blog/2019/07/23/unity-y-axis-billboard-shader/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dissolve"><a class="header" href="#dissolve">Dissolve</a></h1>
<ul>
<li>dissolve : 녹다, 용해되다.</li>
<li>Dissolve텍스쳐를 이용하여, 특정 값 이하일때 표시를 안하면 사라지는 효과를 얻을 수 있다.</li>
<li><a href="Fx/../Basic/Alpha.html">Alpha.md</a> 참조.</li>
</ul>
<h2 id="sample-2"><a class="header" href="#sample-2">Sample</a></h2>
<pre><code class="language-hlsl">half dissolveTex = SAMPLE_TEXTURE2D(_DissolveTex, sampler_DissolveTex, IN.uv).r;
clip(dissolveTex - _Amount);
</code></pre>
<pre><code class="language-hlsl">// https://developer.download.nvidia.com/cg/clip.html

void clip(float4 x)
{
  if (any(x &lt; 0))
    discard;
}
</code></pre>
<ul>
<li>유니티 함수 <code>AlphaDiscard</code>를 쓰는 사람도 있는데, 이 경우 <code>_ALPHATEST_ON</code>를 이용하는지 여부에 따라 결과가 달라짐으로 주의.</li>
</ul>
<pre><code class="language-hlsl">// com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl

void AlphaDiscard(real alpha, real cutoff, real offset = real(0.0))
{
    #ifdef _ALPHATEST_ON
        clip(alpha - cutoff + offset);
    #endif
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spriteflipbook_flowmap_motionvector"><a class="header" href="#spriteflipbook_flowmap_motionvector">SpriteFlipBook_FlowMap_MotionVector</a></h1>
<h2 id="spriteflipbook"><a class="header" href="#spriteflipbook">SpriteFlipBook</a></h2>
<pre><code class="language-hlsl">// uv         : [0, 1]
// frame      : time * FramePerSeconds
// imageCount : (ColumnCount, RowCount)
half2 GetSubUV(in half2 uv, in half frame, in uint2 imageCount)
{

    // ex)
    // frame      = 9.9
    // imageCount = (8, 8)

    half2 scale = 1.0 / imageCount;           // scale = (0.125, 0.125)

    // floor : 소수점이하 버림.
    // frac  : 소수점이하 반환.
    half index = floor(frame);                 // index = 9
    // half index = frame - frac(frame);
    
    // fmod  : 나머지 반환.
    // offset.x = 9 % 8                                     =&gt; 1
    // offset.y = -1 - floor(9 * 0.125) =&gt; -1 -floor(1.125) =&gt; -2
    half2 offset = half2(
      fmod(index, imageCount.x),
      -1 - floor(index * scale.x)
    );

    // y가 -1로 시작하는 이유.
    //  - uv좌표     : 좌하단
    //  - 이미지시트 : 좌상단
    // 기준점을 uv(0, 0)을 sheet(0, -1)로 변환해야함.

    return (uv + offset) * scale;
}

half frameNumber = _Time.y * _FramesPerSeconds;
half2 subUV = GetSubUV(IN.uv, frameNumber, uint2(_ColumnsX, _RowsY));
</code></pre>
<h2 id="flowmap"><a class="header" href="#flowmap">FlowMap</a></h2>
<ul>
<li><a href="http://teckartist.com/?page_id=107">FlowMapPainter</a></li>
<li><a href="https://blog.naver.com/mnpshino/221456514365">mnpshino - 모션벡터와 플로우 맵 (2)</a></li>
<li><a href="https://www.slideshare.net/alexvlachos/">SIGGRAPH2010 presentation Water Flow in Portal 2</a></li>
<li><a href="https://catlikecoding.com/unity/tutorials/flow/texture-distortion/">https://catlikecoding.com/unity/tutorials/flow/texture-distortion/</a></li>
<li><a href="http://wiki.polycount.com/wiki/Flow_map">http://wiki.polycount.com/wiki/Flow_map</a></li>
<li><a href="https://www.youtube.com/watch?v=tEr3NE_XLbc">youtube: Flow Map Material Setup in 13 Minutes</a></li>
<li><a href="https://www.gdcvault.com/play/1015309/Water-Technology-of">GDC2012 - Water Technology of Uncharted</a></li>
<li><a href="http://graphicsrunner.blogspot.com/2010/08/water-using-flow-maps.html">Graphics Runner: Animating Water Using Flow Maps by Kyle Hayward</a></li>
<li><a href="https://web.archive.org/web/20170508024645/http://ttmayrin.tistory.com/40">http://ttmayrin.tistory.com/40</a></li>
</ul>
<p><img src="Fx/../res/01-uv-256.png" alt="../res/01-uv-256.png" /></p>
<p><img src="Fx/../res/flowsheet1.png" alt="../res/flowsheet1.png" /></p>
<pre><code class="language-hlsl">half2 flowTex = SAMPLE_TEXTURE2D(_FlowTex, sampler_FlowTex, IN.uv).rg;

// flowTex[0, 1] =&gt; [-1, 1]
half2 flowUV = flowTex * 2.0 - 1.0;

// or flowTex[0, 1] =&gt; [-0.5, 0.5]
// half2 flowUV = flowTex - 0.5;

// [-1, 1] 선형 반복.
// frac  : 소수점이하 반환.
half flowLerp = abs((frac(_Time.x * _FlowSpeed) - 0.5) * 2.0);

half2 uv0 = IN.uv + flowUV * frac(_Time.x * _FlowSpeed);
half2 uv1 = IN.uv + flowUV * frac(_Time.x * _FlowSpeed + 0.5);

half3 mainTex0 = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv0).rgb;
half3 mainTex1 = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv1).rgb;

half3 finalColor = lerp(mainTex0, mainTex1, flowLerp);
</code></pre>
<h2 id="motionvector"><a class="header" href="#motionvector">MotionVector</a></h2>
<ul>
<li><a href="http://www.klemenlozar.com/frame-blending-with-motion-vectors/">http://www.klemenlozar.com/frame-blending-with-motion-vectors/</a></li>
<li><a href="https://www.gdcvault.com/browse/gdc-12/play/1015655">GDC2012 - The Tricks Up Our Sleeves: A Walkthrough of the Special FX of Uncharted 3: Drake’s Deception</a></li>
</ul>
<pre><code class="language-hlsl">half frameNumber = _Time.y * _FramesPerSeconds;
uint2 imageCount = uint2(_ColumnsX, _RowsY);

OUT.frameNumber = frameNumber;
OUT.subUV0 = GetSubUV(IN.uv, frameNumber, imageCount);
OUT.subUV1 = GetSubUV(IN.uv, frameNumber + 1, imageCount);

// -------------------
// flowTex[0, 1] =&gt; [-1, 1]
half2 flowTex0 = SAMPLE_TEXTURE2D(_FlowTex, sampler_FlowTex, IN.subUV0).rg;
half2 flowTex1 = SAMPLE_TEXTURE2D(_FlowTex, sampler_FlowTex, IN.subUV1).rg;
flowTex0 = flowTex0 * 2.0 - 1.0;
flowTex1 = flowTex1 * 2.0 - 1.0;

half interval = frac(IN.frameNumber);

half2 mainUV0 = IN.subUV0 - (flowTex0 * interval * _DistortionStrength);
half2 mainUV1 = IN.subUV1 + (flowTex1 * (1 - interval) * _DistortionStrength);
half4 mainTex0 = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, mainUV0);
half4 mainTex1 = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, mainUV1);

half4 finalColor = lerp(mainTex0, mainTex1, interval);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hatching"><a class="header" href="#hatching">Hatching</a></h1>
<ul>
<li>TAM / Tonal Art Maps</li>
</ul>
<h2 id="ref-46"><a class="header" href="#ref-46">Ref</a></h2>
<ul>
<li><a href="http://gfx.cs.princeton.edu/proj/hatching/hatching.pdf">SIGGRAPH2001 - Real-Time Hatching</a></li>
<li><a href="https://github.com/OskarSigvardsson/tonal-art-map">https://github.com/OskarSigvardsson/tonal-art-map</a></li>
<li><a href="https://blog.naver.com/pch413/10001173790">https://blog.naver.com/pch413/10001173790</a></li>
<li><a href="http://kylehalladay.com/blog/tutorial/2017/02/21/Pencil-Sketch-Effect.html">http://kylehalladay.com/blog/tutorial/2017/02/21/Pencil-Sketch-Effect.html</a>
<ul>
<li><a href="https://github.com/khalladay/PencilSketchEffect">https://github.com/khalladay/PencilSketchEffect</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matcap"><a class="header" href="#matcap">MatCap</a></h1>
<ul>
<li>MatCap(Material Capture)
<ul>
<li>SEM(Spherical Environment Mapping) / Lit Sphere</li>
</ul>
</li>
<li>환경을 텍스쳐에 맵핑하고, <code>뷰스페이스 노말</code>로 색을 얻어온다.</li>
<li>케릭터에 사용할때는 Diffuse용/Reflect용 맵캡을 이용하도록 하자</li>
</ul>
<pre><code class="language-hlsl">// vert
float4x4 MATRIX_IT_MV = UNITY_MATRIX_IT_MV;
float3 binormalOS = cross(IN.normalOS, IN.tangentOS.xyz) * IN.tangentOS.w * unity_WorldTransformParams.w;
float3x3 TBN_os = float3x3(IN.tangentOS.xyz, binormalOS, IN.normalOS);

OUT.TtoV0 = mul(TBN_os, MATRIX_IT_MV[0].xyz);
OUT.TtoV1 = mul(TBN_os, MATRIX_IT_MV[1].xyz);

// frag
half2 normalVS;
normalVS.x = dot(IN.tan0, normalTS);
normalVS.y = dot(IN.tan1, normalTS);
half2 uv_Matcap = normalVS * 0.5 + 0.5;

half3 matcapTex = SAMPLE_TEXTURE2D(_MatcapTex, sampler_MatcapTex, uv_Matcap).rgb;
</code></pre>
<pre><code class="language-hlsl">// vert
half4x4 MATRIX_IT_MV = UNITY_MATRIX_IT_MV;

half2 normalVS;
normalVS.x = dot(MATRIX_IT_MV[0].xyz, IN.normalOS);
normalVS.y = dot(MATRIX_IT_MV[1].xyz, IN.normalOS);
OUT.uv_Matcap = normalVS * 0.5 + 0.5;

// vert
half3 normalWS = TransformObjectToWorldNormal(IN.normalOS);
half3 normalVS = normalize(TransformWorldToView(normalWS));
</code></pre>
<pre><code class="language-hlsl">// 좀 더 디테일한 버전
half3 normalVS = normalize(mul(UNITY_MATRIX_IT_MV, IN.normal));
half3 positionVS = UnityObjectToViewPos(IN.positionOS);
half3 r = reflect(positionVS, normalVS);
half m = 2.0 * sqrt(r.x * r.x + r.y * r.y + (r.z + 1) * (r.z + 1));
OUT.uv_Matcap = r.xy / m + 0.5;
</code></pre>
<pre><code class="language-hlsl">// 회전
half s;
half c;
sincos(_RotateRadian, s, c);
half2x2 rot = {
	c, -s,
	s, c
};
normalVS = mul(rot, normalVS);
</code></pre>
<h2 id="번외"><a class="header" href="#번외">번외</a></h2>
<ul>
<li>normalWS를 이용함으로써 View에 대해 변하는게 아닌 고정효과
<ul>
<li><a href="https://chulin28ho.tistory.com/351">카메라 방향에 상관없는 Matcap 만들기</a></li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">OUT.uv_Matcap = normalWS.xy * 0.5 + 0.5;
</code></pre>
<h2 id="ref-47"><a class="header" href="#ref-47">Ref</a></h2>
<ul>
<li>MaCrea(MatCap 생성 도구) <a href="http://www.taron.de/">http://www.taron.de/</a>
<ul>
<li>사용법: <a href="https://vimeo.com/14030320">MaCrea introduction</a></li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Sphere_mapping">https://en.wikipedia.org/wiki/Sphere_mapping</a></li>
<li><a href="http://wiki.polycount.com/wiki/Spherical_environment_map">http://wiki.polycount.com/wiki/Spherical_environment_map</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3d9/spherical-environment-mapping">https://docs.microsoft.com/en-us/windows/win32/direct3d9/spherical-environment-mapping</a></li>
<li><a href="https://youtu.be/0LwlNVS3FJo?t=530">[Unite Seoul 2019] 최재영 류재성 - 일곱개의 대죄 : "애니메이션의 감성을 그대로＂와 “개발 최적화"</a></li>
<li><a href="https://github.com/nidorx/matcaps">https://github.com/nidorx/matcaps</a> : MatCap Textures</li>
<li><a href="https://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader/">https://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader/</a></li>
<li><a href="https://www.youtube.com/watch?v=ZB9bKhXPR74">에픽 라이브 | 언리얼 엔진 카툰 렌더링 | PART 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outline"><a class="header" href="#outline">Outline</a></h1>
<ul>
<li>2-pass
<ul>
<li>Scale 확장</li>
<li>Normal 확장</li>
</ul>
</li>
<li>Rim</li>
<li>SSO(Screen Space Outline)</li>
</ul>
<h2 id="2-pass"><a class="header" href="#2-pass">2-pass</a></h2>
<pre><code class="language-hlsl">Tags
{
    "RenderPipeline" = "UniversalRenderPipeline"
}

Pass
{
    Name "Outline"
    Tags
    {
        "LightMode" = "SRPDefaultUnlit"
        "Queue" = "Geometry"
        "RenderType" = "Opaque"
    }
    Cull Front
    
    HLSLPROGRAM
    // outline code
    ENDHLSL
}

Pass
{
    Name "Front"
    Tags
    {
        "LightMode" = "UniversalForward"
        "Queue" = "Geometry"
        "RenderType" = "Opaque"
    }
    Cull Back

    HLSLPROGRAM
    // render code
    ENDHLSL
}
</code></pre>
<h3 id="scale-확장"><a class="header" href="#scale-확장">Scale 확장</a></h3>
<ul>
<li>1pass 원래 Model 확대하여 외곽선 색으로 칠한다</li>
<li>2pass 원래 Model을 덧그린다</li>
</ul>
<pre><code class="language-hlsl">half4 Scale(half4 positionOS, half3 s)
{
    // s : scale
    // m : scale matrix

    half4x4 m;
    m[0][0] = 1.0 + s.x; m[0][1] = 0.0;       m[0][2] = 0.0;       m[0][3] = 0.0;
    m[1][0] = 0.0;       m[1][1] = 1.0 + s.y; m[1][2] = 0.0;       m[1][3] = 0.0;
    m[2][0] = 0.0;       m[2][1] = 0.0;       m[2][2] = 1.0 + s.z; m[2][3] = 0.0;
    m[3][0] = 0.0;       m[3][1] = 0.0;       m[3][2] = 0.0;       m[3][3] = 1.0;
    return mul(m, positionOS);
}

OUT.positionCS = TransformObjectToHClip(Scale(IN.positionOS, _OutlineScale).xyz);
</code></pre>
<h3 id="normal-확장"><a class="header" href="#normal-확장">Normal 확장</a></h3>
<ul>
<li><a href="https://www.videopoetics.com/tutorials/pixel-perfect-outline-shaders-unity/">https://www.videopoetics.com/tutorials/pixel-perfect-outline-shaders-unity/</a></li>
<li><a href="https://blog.naver.com/mnpshino/221495979665">마둠파 - 유니티 외곽선 셰이더 완벽정리편</a></li>
</ul>
<pre><code class="language-hlsl">OUT.positionCS = TransformObjectToHClip(IN.positionOS);

half4 normalCS = TransformObjectToHClip(IN.normal);

// 아웃라인은 2차원이므로. `normalCS.xy`에 대해서만 계산 및 `normalize`.
// 카메라 거리에 따라 아웃라인의 크기가 변경되는것을 막기위해 `positionCS.w`를 곱해준다.
// _ScreenParams.xy (x/y는 카메라 타겟텍스쳐 넓이/높이)로 나누어서 [-1, +1] 범위로 만듬.
// 길이 2인 범위([-1, +1])와 비율을 맞추기 위해 OutlineWidth에 `*2`를 해준다.

half2 offset = (normalize(normalCS.xy) * normalCS.w) / _ScreenParams.xy * (2 * _OutlineWidth) * OUT.positionCS.w;

// 버텍스 칼라를 곱해주면서 디테일 조정.
// offset *= IN.color.r;
OUT.positionCS.xy += offset;
</code></pre>
<ul>
<li>여러 갈래로 흩어진 normal을 부드럽게 하기
<ul>
<li><code>.fbx -&gt; Model, Normal &amp; Tangent Normals -&gt; Normals:Calculate, Smoothing Angel:180</code></li>
<li><a href="https://assetstore.unity.com/packages/vfx/shaders/toony-colors-pro-2-8105">TCP2 : Smoothed Normals Utility</a></li>
</ul>
</li>
</ul>
<h2 id="rim"><a class="header" href="#rim">Rim</a></h2>
<ul>
<li>림라이트 효과를 이용</li>
</ul>
<pre><code class="language-hlsl">half3 NdotL = normalize(N, L);
half rim = abs(NdotL);
if (rim &gt; _Outline)
{
    rim = 1;
}
else
{
    rim = -1;
}
final.rgb *= rim;
</code></pre>
<pre><code class="language-hlsl">half3 NdotV = normalize(N, V);
half rim = 1 - NdotV;
final.rgb *= pow(rim, 3);
</code></pre>
<h2 id="post-processing-이용---ssoscreen-space-outline"><a class="header" href="#post-processing-이용---ssoscreen-space-outline">Post Processing 이용 - SSO(Screen Space Outline)</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Roberts_cross">https://en.wikipedia.org/wiki/Roberts_cross</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sobel_operator">https://en.wikipedia.org/wiki/Sobel_operator</a></li>
</ul>
<h3 id="외곽선-검출edge-detection-필터"><a class="header" href="#외곽선-검출edge-detection-필터">외곽선 검출(Edge detection) 필터</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>색성분 엣지</td><td>밝기차</td></tr>
<tr><td>ID 엣지</td><td>알파값에 id: 1, 0이런식으로 넣기</td></tr>
<tr><td>깊이 엣지</td><td>깊이 맵 필요</td></tr>
<tr><td>법선 엣지</td><td>노말 맵 필요</td></tr>
<tr><td>확대 모델 엣지</td><td>셰이더 2패스</td></tr>
</tbody></table>
</div>
<h2 id="ref-48"><a class="header" href="#ref-48">Ref</a></h2>
<ul>
<li><a href="https://roystan.net/articles/outline-shader.html">https://roystan.net/articles/outline-shader.html</a></li>
<li><a href="https://alexanderameye.github.io/outlineshader.html">https://alexanderameye.github.io/outlineshader.html</a></li>
<li><a href="https://alexanderameye.github.io/notes/rendering-outlines/">https://alexanderameye.github.io/notes/rendering-outlines/</a></li>
<li><a href="https://musoucrow.github.io/2020/07/05/urp_outline/">https://musoucrow.github.io/2020/07/05/urp_outline/</a></li>
<li><a href="https://github.com/netpyoung/bs.introduction-to-shader-programming/blob/master/note/ch12.md">https://github.com/netpyoung/bs.introduction-to-shader-programming/blob/master/note/ch12.md</a></li>
<li><a href="https://www.ronja-tutorials.com/2020/07/23/sprite-outlines.html">https://www.ronja-tutorials.com/2020/07/23/sprite-outlines.html</a></li>
<li><a href="https://bgolus.medium.com/the-quest-for-very-wide-outlines-ba82ed442cd9">https://bgolus.medium.com/the-quest-for-very-wide-outlines-ba82ed442cd9</a></li>
<li><a href="https://www.codinblack.com/outline-effect-using-shader-graph-in-unity3d/">https://www.codinblack.com/outline-effect-using-shader-graph-in-unity3d/</a></li>
<li><a href="https://gamedevforever.com/18">외곽선 렌더링 구현에 관한 허접한 정리</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallax-mapping"><a class="header" href="#parallax-mapping">Parallax Mapping</a></h1>
<ul>
<li>parallax mapping, offset mapping, photonic mapping, virtual displace mapping 이라고 부른다.</li>
<li>높이 정보를 활용하여 텍스처 좌표를 보정.</li>
</ul>
<p><img src="Fx/../res/normal_mapping_tbn_vectors.png" alt="../res/normal_mapping_tbn_vectors.png" /></p>
<ul>
<li>Tangent Space 의 임의의 벡터 x는 <code>(t, b, n)</code>의 값을 갖게된다.</li>
<li>t는 UV.u와 관련있을 것이고, b는 UV.v와 관련이 있게 된다.</li>
</ul>
<p><img src="Fx/../res/parallax_mapping_depth.png" alt="../res/parallax_mapping_depth.png" /></p>
<pre><code class="language-hlsl">Eye
= -V_TS.tbn / V_TS.n
= -(V_TS.t / V_TS.n,  V_TS.b / V_TS.n, V_TS.n / V_TS.n)
= -(V_TS.t / V_TS.n,  V_TS.b / V_TS.n,               1)
</code></pre>
<p><img src="Fx/../res/LightTS.gif" alt="../res/LightTS.gif" /></p>
<p><img src="Fx/../res/LightTS2.gif" alt="../res/LightTS2.gif" /></p>
<pre><code class="language-hlsl">half3x3 TBN = half3x3(normalInputs.tangentWS, normalInputs.bitangentWS, normalInputs.normalWS);

// 시점에 대한 tangent space의 V
OUT.V_TS = mul(TBN, GetCameraPositionWS() - vertexInputs.positionWS);
// 광원 계산을 위한 tangent space의 L
OUT.L_TS = mul(TBN, mainLight.direction);

// OUT.V_TS.t = dot(V, T);
// OUT.V_TS.b = dot(V, B);
// OUT.V_TS.n = dot(V, N);

// OUT.L_TS.t = dot(L, T);
// OUT.L_TS.b = dot(L, B);
// OUT.L_TS.n = dot(L, N);


half2 ParallaxMapping(half2 uv, half3 V_TS)
{
    // 높이 맵에서 높이를 구하고,
    half height = SAMPLE_TEXTURE2D(_NormalDepthPackedTex, sampler_NormalDepthPackedTex, uv).b;

    // 시선에 대한 offset을 구한다.
    // 시선은 반대방향임으로 부호는 마이너스(-) 붙여준다.
    // TS.xyz == TS.tbn
    half2 E = -(V_TS.xy / V_TS.z);

    // 근사값이기에 적절한 strength를 곱해주자.
    return uv + E * (height * _HeightStrength);
}

half3 L_TS = normalize(IN.L_TS);
half3 V_TS = normalize(IN.V_TS);
half2 parallaxUV = ParallaxMapping(IN.uv, V_TS);
if ((parallaxUV.x &lt; 0.0 || 1.0 &lt; parallaxUV.x) || (parallaxUV.y &lt; 0.0 || 1.0 &lt; parallaxUV.y))
{
    // x, y가 범위([0, 1])를 벗어나면 discard.
    discard;
}

// 계산 절약을 위해 `tangent space`기준으로 반사 계산을 한다.
half3 N_TS = UnpackNormal(SAMPLE_TEXTURE2D(_NormalDepthPackedTex, sampler_NormalDepthPackedTex, parallaxUV));
half NdotL = saturate(dot(N_TS, L_TS));

// `world space` 기준이라면 계산이 더 들어가게 된다.
half3 N_TS = UnpackNormal(SAMPLE_TEXTURE2D(_NormalDepthPackedTex, sampler_NormalDepthPackedTex, parallaxUV));
half3 N = mul(normalTex, TBN);
half3 L = mul(L_TS, TBN);
half NdotL = saturate(dot(N, L));
</code></pre>
<ul>
<li>유니티에도 헬퍼 함수들이 있지만, 별로 추천안함...
<ul>
<li><a href="https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.core/ShaderLibrary/ParallaxMapping.hlsl">https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.core/ShaderLibrary/ParallaxMapping.hlsl</a></li>
<li>half4짜리 tangentWS를 원하지 않나... viewDirTS를 다시 normalze하질않나..</li>
</ul>
</li>
</ul>
<h2 id="종류"><a class="header" href="#종류">종류</a></h2>
<ul>
<li>Parallax Mapping</li>
<li>Parallax Mapping with offset limit</li>
<li>Steep Parallax Mapping</li>
<li>ReliefParallax</li>
<li>Parallax Occlusion Mapping (POM)</li>
<li>....</li>
</ul>
<h2 id="ref-49"><a class="header" href="#ref-49">Ref</a></h2>
<ul>
<li><a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">https://learnopengl.com/Advanced-Lighting/Parallax-Mapping</a>
<ul>
<li>번역본: <a href="https://gyutts.tistory.com/175">https://gyutts.tistory.com/175</a></li>
</ul>
</li>
<li><a href="https://bzyzhang.github.io/2020/11/29/2020-11-29-%EF%BC%88%E4%B8%89%EF%BC%89%E8%A1%A8%E9%9D%A2%E5%87%B9%E5%87%B8%E6%8A%80%E6%9C%AF/">bzyzhang -（三）表面凹凸技术</a></li>
<li><a href="http://blog.naver.com/sybershin/129399930">http://blog.naver.com/sybershin/129399930</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sss"><a class="header" href="#sss">SSS</a></h1>
<p>SSS(Sub-Surface Scattering) (피하산란)</p>
<ul>
<li>BSSRDF(Bidirectional surface-scattering reflectance distribution function)
<ul>
<li>입사한 지점과 반사되는 지점이 다름.</li>
<li>실시간으로 계산하기에는 부하가 큼</li>
</ul>
</li>
<li>여러 기법들
<ul>
<li>Texture-Space Diffusion</li>
<li>Scren-Space SSS</li>
<li>Pre-Integrated Skin Shading</li>
<li>other Fake/Fast/Approximated SSS</li>
</ul>
</li>
</ul>
<h2 id="tsd--texture-space-diffusion"><a class="header" href="#tsd--texture-space-diffusion">TSD / Texture-Space Diffusion</a></h2>
<h2 id="sssss--scren-space-sub-surface-scattering"><a class="header" href="#sssss--scren-space-sub-surface-scattering">SSSSS / Scren-Space Sub-Surface Scattering</a></h2>
<ul>
<li>https://www.iryoku.com/sssss/
<ul>
<li>https://www.iryoku.com/screen-space-subsurface-scattering/</li>
</ul>
</li>
<li>https://unityshader.hatenablog.com/entry/2016/12/25/175333</li>
<li>https://docs.unrealengine.com/udk/Three/ScreenSpaceSubsurfaceScattering.html</li>
<li><a href="https://advances.realtimerendering.com/s2018/Efficient%20screen%20space%20subsurface%20scattering%20Siggraph%202018.pdf">2018 - [Siggraph2018] Efficient screen-space subsurface scattering using Burley’s normalized diffusion in real-time - Evgenii Golubev (Unity Technologies)</a></li>
</ul>
<h2 id="piss--pre-integrated-skin-shading"><a class="header" href="#piss--pre-integrated-skin-shading">PISS / Pre-Integrated Skin Shading</a></h2>
<ul>
<li>
<p>LookUpTexture 이용</p>
</li>
<li>
<p>fwidth : abs(ddx(x)) + abs(ddy(x))</p>
</li>
<li>
<p>DirectX는 ddx_fine/ddy_fine함수도 있음.</p>
</li>
</ul>
<pre><code class="language-hlsl">half diffuse = LdotN;
half curvature = saturate(length(fwidth(N)) / length(fwidth(positionWS)) * curvatureScale);

half2 pissUV;
pissUV.x = diffuse;
pissUV.y = curvature;

half3 pissTex = SAMPLE_TEXTURE2D(_PissTex, sampler_PissTex, pissUV).rgb;
</code></pre>
<h2 id="localthickness"><a class="header" href="#localthickness">LocalThickness</a></h2>
<pre><code class="language-hlsl">// local thickness
half  localTicknessTex = SAMPLE_TEXTURE2D(_LocalThicknessTex, sampler_LocalThicknessTex, uv).r;
half3 H                = normalize(L + N * _Distortion);
half  VdotH            = pow(saturate(dot(V, -H)), _Power) * _Scale;
half  backLight        = _Attenuation * (VdotH + _Ambient) * localTicknessTex;
</code></pre>
<h2 id="other-fakefastapproximated-sss"><a class="header" href="#other-fakefastapproximated-sss">other Fake/Fast/Approximated SSS</a></h2>
<pre><code class="language-hlsl">half  halfLambert = NdotL * 0.5 + 0.5;
half3 fakeSSS     = (1 - halfLambert) * _SSSColor;
half3 color       = halfLambert + fakeSSS;
</code></pre>
<pre><code class="language-hlsl">half  rim     = 1 - NdotL;
// 역광일때만 하려면 VdotL처리
// rim *= VdotL;
half3 fakeSSS = pow(rim, _SSSPower) * _SSSMultiplier * _SSSColor;
half3 color   = lambert * fakeSSS;
</code></pre>
<pre><code class="language-hlsl">half  rim     = 1 - NdotL;
half3 fakeSSS = SAMPLE_TEXTURE2D(_SSS_RampTex, sampler_SSS_RampTex, half2(rim, 0)).rgb;
</code></pre>
<pre><code class="language-hlsl">half2 brdfUV;
brdfUV.x = dot(N, L);
brdfUV.y = dot(N, H);

half3 brdfTex = SAMPLE_TEXTURE2D(_BrdfTex, sampler_BrdfTex, brdfUV * 0.5 + 0.5).rgb;
</code></pre>
<pre><code class="language-hlsl">half LdotN = dot(L, N);
half LdotV = dot(L, V);

half2 rampUV;
rampUV.x = LdotN * 0.3 + 0.5;
rampUV.y = LdotV * 0.8;
half3 rampTex = SAMPLE_TEXTURE2D(_RampTex, sampler_RampTex, rampUV).rgb;
</code></pre>
<p>아니면 Albedo맵 / Normal맵 자체에 Blur(rgb에 가중치를 주어서)를 적용한다.</p>
<h2 id="ref-50"><a class="header" href="#ref-50">Ref</a></h2>
<ul>
<li><a href="https://www.slideshare.net/leemwymw/cheap-realisticskinshading-kor">Cheap realisticskinshading kor </a></li>
<li><a href="https://advances.realtimerendering.com/s2010/index.html">SIGGRAPH2010 - Uncharted 2: Character Lighting and Shading</a></li>
<li><a href="https://www.gdcvault.com/browse/gdc-11/play/1014661">GDC2011 - Iterating Realistic Human Rendering: Boxers in FIGHT NIGHT CHAMPION</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/97892884">https://zhuanlan.zhihu.com/p/97892884</a></li>
<li><a href="https://blog.naver.com/checkjei/60167971452">https://blog.naver.com/checkjei/60167971452</a></li>
<li><a href="https://therealmjp.github.io/posts/sss-intro/">https://therealmjp.github.io/posts/sss-intro/</a></li>
<li><a href="https://mgun.tistory.com/1600">https://mgun.tistory.com/1600</a></li>
<li>NVIDIA
<ul>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering">[GPU Gems 1] Chapter 16. Real-Time Approximations to Subsurface Scattering</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin">[GPU Gems 3] Chapter 14. Advanced Techniques for Realistic Real-Time Skin Rendering</a></li>
<li><a href="https://github.com/NVIDIAGameWorks/FaceWorks">https://github.com/NVIDIAGameWorks/FaceWorks</a></li>
</ul>
</li>
<li>기법별
<ul>
<li>using Half lambert
<ul>
<li><a href="http://chulin28ho.egloos.com/5591833">SSS 쉐이더 만들었어요 뿌우</a></li>
</ul>
</li>
<li>Pre-Integrated Skin Shading
<ul>
<li>GPU Pro 2 - Pre-Integrated Skin Shading</li>
</ul>
</li>
<li>LocalThickness
<ul>
<li>GPU Pro 2 - Real-Time Approximation of Light Transport in Translucent Homogenous Media</li>
<li><a href="https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/">GDC 2011 – Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look</a></li>
<li>Fast Subsurface Scattering in Unity(<a href="https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/">1</a>, <a href="https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-2/">2</a>)</li>
<li>실시간 SSS 셰이더 구현하는 세가지 방법(<a href="https://blog.naver.com/mnpshino/221442188568">1</a>, <a href="https://blog.naver.com/mnpshino/221442196618">2</a>, <a href="https://blog.naver.com/mnpshino/221442210257">3</a>)</li>
<li><a href="https://chulin28ho.tistory.com/515">SSS Shader for Unity</a></li>
</ul>
</li>
<li>Normal blur
<ul>
<li><a href="https://lifeisforu.tistory.com/517">[ 기고 ] Normal Blur Sub-Surface Scattering</a></li>
<li>NOC2012 - SubSurfaceScattering + UDK Custom Shader 권오찬</li>
</ul>
</li>
<li><a href="https://www.slideshare.net/leegoonz/penner-preintegrated-skin-rendering-siggraph-2011-advances-in-realtime-rendering-course">SIGGRAPH2011 - Penner pre-integrated skin rendering</a></li>
<li>BRDF
<ul>
<li><a href="https://www.slideshare.net/jalnaga/brdf">Brdf기반 사전정의 스킨 셰이더</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="_forcefieldshield"><a class="header" href="#_forcefieldshield">_ForceFieldShield</a></h1>
<p><a href="https://www.youtube.com/watch?v=NiOGWZXBg4Y">FORCE FIELD in Unity - SHADER GRAPH</a>
<a href="https://www.youtube.com/watch?v=hTJqo1HeEOs">Unity Shader Graph - Shield Effect Tutorial</a></p>
<ul>
<li><a href="https://github.com/Brackeys/Force-Field">https://github.com/Brackeys/Force-Field</a></li>
<li><a href="https://github.com/vaxkun/ReinhardtLike-Shield-ShaderForge">https://github.com/vaxkun/ReinhardtLike-Shield-ShaderForge</a></li>
<li><a href="https://github.com/WorldOfZero/UnityVisualizations">https://github.com/WorldOfZero/UnityVisualizations</a></li>
<li><a href="https://github.com/WorldOfZero/2D-Flat-Shape-Shader/blob/master/Assets/FlatSinShader.shader">https://github.com/WorldOfZero/2D-Flat-Shape-Shader/blob/master/Assets/FlatSinShader.shader</a></li>
<li><a href="https://github.com/yanagiragi/Unity_Shader_Learn">https://github.com/yanagiragi/Unity_Shader_Learn</a></li>
<li><a href="https://github.com/Toocanzs/Vertical-Billboard/blob/master/Toocanzs/Vertical%20Billboard/VerticalBillboard.cginc">https://github.com/Toocanzs/Vertical-Billboard/blob/master/Toocanzs/Vertical%20Billboard/VerticalBillboard.cginc</a></li>
<li><a href="https://github.com/Xiexe">https://github.com/Xiexe</a></li>
</ul>
<pre><code>Cast Shadow&gt; Off
var ScreenDepth
ScreenDepth -= ScreenPosition.a
var edge = smoothstep(0, 1, 1 - ScreenDepth) + fresnel
texture * edge
</code></pre>
<p>거기다 마스킹으로 강조
https://docs.unity3d.com/Packages/com.unity.shadergraph@11.0/manual/Sphere-Mask-Node.html</p>
<pre><code class="language-hlsl">void Unity_SphereMask_float4(float4 Coords, float4 Center, float Radius, float Hardness, out float4 Out)
{
    Out = 1 - saturate((distance(Coords, Center) - Radius) / (1 - Hardness));
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lightshaft_mesh"><a class="header" href="#lightshaft_mesh">LightShaft_Mesh</a></h1>
<ul>
<li><a href="https://developer.arm.com/documentation/102259/0100/Light-shafts">https://developer.arm.com/documentation/102259/0100/Light-shafts</a></li>
</ul>
<pre><code class="language-hlsl">Cull Off
ZWrite Off
Blend One One

// Project camera position onto cross section
float3 DIR_UP             = float3(0, 1, 0);
float  dotWithYAxis       = dot(cameraPositionOS, DIR_UP);
float3 projOnCrossSection = normalize(cameraPositionOS - (DIR_UP * dotWithYAxis));

// Dot product to fade the geometry at the edge of the cross section
float dotProd           = abs(dot(projOnCrossSection, input.normal));
output.overallIntensity = pow(dotProd, _FadingEdgePower) * _CurrLightShaftIntensity;
</code></pre>
<h2 id="ref-51"><a class="header" href="#ref-51">Ref</a></h2>
<ul>
<li><a href="https://assetstore.unity.com/packages/vfx/shaders/volumetric-light-beam-99888">https://assetstore.unity.com/packages/vfx/shaders/volumetric-light-beam-99888</a></li>
<li><a href="https://assetstore.unity.com/packages/tools/particles-effects/as-lightshafts-2-13196">https://assetstore.unity.com/packages/tools/particles-effects/as-lightshafts-2-13196</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rim-light"><a class="header" href="#rim-light">Rim Light</a></h1>
<p>카메라 각도 * 모델 90 | 그림
카메라 각도 * 모델 180 |안그림</p>
<ul>
<li>피격 연출에도 들어간다.</li>
<li>응용가능
<ul>
<li>반전하여 카메라 방향에 따른 라이트 효과로 응용가능.</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">half rim = 1 - NdotV;
half steppedRim = smoothstep(1.0 - _RimWidth, 1.0, rim);
</code></pre>
<h1 id="ref-52"><a class="header" href="#ref-52">Ref</a></h1>
<ul>
<li><a href="https://youtu.be/9B3BDsFxP6I?t=1074">Unite '17 Seoul - 모바일 하드웨어에서 퀄리티있는 유니티 셰이더 구현</a></li>
<li><a href="https://www.slideshare.net/agebreak/0806-rim-lighting">[0806 박민근] 림 라이팅(rim lighting)</a></li>
<li>http://cagetu.egloos.com/5883856</li>
<li><a href="https://www.gdcvault.com/play/1014360/Cinematic-Character-Lighting-in-STAR">GDC2011 - Cinematic Character Lighting in STAR WARS: THE OLD REPUBLIC</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>눈쌓기</p>
<p>월드 노말 기준으로</p>
<p>눈 각도</p>
<pre><code class="language-hlsl">float _SnowSize;
float _SnowHeight;
float3 _SnowDirOS = float4(0, 1, 0, 1);

float3 snowDirWS = TransformObjectToWorldDir(normalize(_SnowDirOS));
float3 N = TransformObjectToWorldNormal(IN.normalOS);
if (dot(N, snowDirWS) &gt;= _SnowSize)
{
    IN.positionOS.xyz += (v.positionOS.xyz * _SnowHeight);
}
</code></pre>
<ul>
<li>http://blog.naver.com/plasticbag0/221436480475</li>
<li><a href="https://www.slideshare.net/proyZ/daniel-barrero-coh2renderingtech">KGC2013 -  Company of Heroes 2 (COH2) Rendering Technology: The cold facts of recreating the hardest winter conditions of World War 2</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toon"><a class="header" href="#toon">Toon</a></h1>
<ul>
<li>ceil / Ramp Texture / smoothstep</li>
</ul>
<pre><code class="language-hlsl">// ===== 계단 음영 표시 - ver. ceil() ====
// [0, 1]범위를 _ToonStep(int)을 곱해서 [0, _ToonStep]범위로 변경.
// ceil함수를 이용하여 올림(디테일 제거 효과).
// 다시 _ToonStep(int)으로 나눔으로써 [0, 1]범위로 변경.
half toonDiffuse = halfLambert;
toonDiffuse = ceil(toonDiffuse * _ToonStep) / _ToonStep;

// ===== 계단 음영 표시 - ver. Ramp Texture ====
// 아니면 Ramp Texture 이용
half3 toonColor = SAMPLE_TEXTURE2D(_RampTex, sampler_RampTex, half2(halfLambert, 0)).rgb;

// ===== 림라이트 ======================
// smoothstep으로 경계를 부드럽게 혼합.
half rim = 1 - NdotV;
half rimIntensity = smoothstep(0.715, 0.717, rim);

// 아니면, 빛방향으로 림
half rimIntensity = rim * pow(NdotL, 0.1);

// ===== 스펙큘러 ======================
// smoothstep으로 경계를 부드럽게 혼합.
half toonSpecular = smoothstep(0.005, 0.01, blinnphongSpecular);
</code></pre>
<h2 id="아웃라인"><a class="header" href="#아웃라인">아웃라인</a></h2>
<ul>
<li>
<p>https://github.com/DumoeDss/AquaSmoothNormals</p>
</li>
<li>
<p>버텍스 확장</p>
<ul>
<li>단순 확장</li>
<li>버텍스 칼라이용 세부 조절</li>
</ul>
</li>
<li>
<p>포스트이펙트</p>
</li>
</ul>
<h2 id="기타-예제"><a class="header" href="#기타-예제">기타 예제</a></h2>
<ul>
<li>SSS 텍스쳐</li>
</ul>
<pre><code class="language-hlsl">half3 sssColor = mainTex * sssTex;
half3 afterSssColor = lerp(sssColor, mainTex, diffuse);
</code></pre>
<ul>
<li>maskTex</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>채널</th><th>마스크</th></tr></thead><tbody>
<tr><td>r</td><td>반사영역</td></tr>
<tr><td>g</td><td>어두어짐</td></tr>
<tr><td>b</td><td>스펙큘러 세기</td></tr>
<tr><td>a</td><td>내부 선</td></tr>
</tbody></table>
</div>
<ul>
<li>vertex's color</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>채널</th><th>마스크</th></tr></thead><tbody>
<tr><td>r</td><td>어두워짐</td></tr>
<tr><td>g</td><td>카메라와의 거리</td></tr>
<tr><td>b</td><td>카메라의 zoffset. 헤어에서 storoke 조절</td></tr>
<tr><td>a</td><td>윤곽두께</td></tr>
</tbody></table>
</div>
<h2 id="원신"><a class="header" href="#원신">원신</a></h2>
<ul>
<li>ref: <a href="https://techartnomad.tistory.com/120">[번역]원신 셰이더 렌더링 복원 해석</a></li>
<li><a href="https://techartnomad.tistory.com/124">[번역/정리]만화 얼굴 그림자 매핑 생성 렌더링 원리</a>
<ul>
<li>https://github.com/mattdesl/image-sdf</li>
<li>https://github.com/xudxud/Unity-SDF-Generator</li>
<li>https://github.com/Weesals/UnitySDF</li>
<li>https://github.com/zeroruka/GI-Assets</li>
<li>https://github.com/JMargevics/Unity-Texture-Packer</li>
<li>https://github.com/andydbc/unity-texture-packer</li>
<li>https://github.com/rstecca/ColorBands</li>
</ul>
</li>
</ul>
<p>Diffuse
RampColor
Glossiness
Specular
LightMap
RampRange
MetalMap
FaceShadow</p>
<h3 id="ramp"><a class="header" href="#ramp">Ramp</a></h3>
<ul>
<li>layer
<ul>
<li>낮x5</li>
<li>밤x5</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>layer</th><th></th></tr></thead><tbody>
<tr><td>0.0</td><td>단단한 물체</td></tr>
<tr><td>0.3</td><td>부드러운 물체</td></tr>
<tr><td>0.5</td><td>금속/금속 투영</td></tr>
<tr><td>0.7</td><td>실크/스타킹</td></tr>
<tr><td>1.0</td><td>피부 텍스처/헤어 텍스처(헤어 부분은 피부가 없음)</td></tr>
</tbody></table>
</div>
<h2 id="ref-53"><a class="header" href="#ref-53">Ref</a></h2>
<ul>
<li><a href="https://alexanderameye.github.io/simple-toon.html">https://alexanderameye.github.io/simple-toon.html</a></li>
<li><a href="https://roystan.net/articles/toon-shader.html">https://roystan.net/articles/toon-shader.html</a>
<ul>
<li><a href="https://github.com/IronWarrior/UnityToonShader">https://github.com/IronWarrior/UnityToonShader</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=EDlbJdmo7KE">The Art Direction of Street Fighter V: The Role of Art in Fighting Games</a>
<ul>
<li><a href="https://www.gdcvault.com/play/1024506/Art-Direction-of-Street-Fighter">https://www.gdcvault.com/play/1024506/Art-Direction-of-Street-Fighter</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=lYV_-x2aFX0">[마비노기] 마비노기 카툰렌더링 제작과정 영상 [Mabinogi] Cartoon rendering Production Process Video</a></li>
<li><a href="https://steamcdn-a.akamaihd.net/apps/valve/2006/SIGGRAPH06_Course_ShadingInValvesSourceEngine.pdf">SIGGRAPH2006 - Shading In Valve's Source Engine</a>
<ul>
<li><a href="https://steamcdn-a.akamaihd.net/apps/valve/2007/NPAR07_IllustrativeRenderingInTeamFortress2.pdf">NPAR07_IllustrativeRenderingInTeamFortress2</a></li>
<li><a href="https://vimeo.com/25953235">Team Fortress 2 Shader for RenderMan RSL</a></li>
</ul>
</li>
<li><a href="https://youtu.be/gdBACyIOCtc">[GDC2024] - 3D Toon Rendering in 'Hi-Fi RUSH'</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://www.patreon.com/posts/toon-fire-write-22032503">Toon Fire Write-up</a>
https://www.youtube.com/watch?v=x2AlfAON5F8</p>
<div style="break-before: page; page-break-before: always;"></div><p>https://github.com/xraxra/IMP</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deferred"><a class="header" href="#deferred">Deferred</a></h1>
<ul>
<li><a href="http://walkingfat.com/unity-urpmicro-gbuffer%e8%87%aa%e5%ae%9a%e4%b9%89%e5%bb%b6%e8%bf%9f%e7%ae%a1%e7%ba%bf/">Unity URP+Micro Gbuffer自定义延迟管线</a></li>
</ul>
<h2 id="ref-54"><a class="header" href="#ref-54">Ref</a></h2>
<ul>
<li>SIGGRAPH2018 - Maximizing Rendering Efficiency</li>
<li>SIGGRAPH2020 - Deferred Shading in Unity URP
<ul>
<li><a href="https://youtu.be/wOBCWZJq6zs?t=3175">youtube</a>, <a href="https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/3_2D00_mmg2020_2D00_deferred_2D00_unity_2D00_chang.pdf">pdf</a></li>
</ul>
</li>
<li><a href="https://www.slideshare.net/ozlael/deferred-rendering-case-study">Deferred rendering case study by ozlael</a></li>
<li><a href="https://www.slideshare.net/cagetu/kgc2012-deferred-forward">[Kgc2012] deferred forward 이창희</a></li>
<li><a href="https://www.slideshare.net//ozlael/deferred-rendering-case-study">2012 - [KGC 2012] 디퍼드 랜더링 케이스 스터디 : 레이더즈 &amp; 건즈2</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="l-v-방향"><a class="header" href="#l-v-방향">L, V 방향</a></h1>
<p>빛(L)과 카메라(V)의 방향 부호는 취향에 따라 Vertex를 향하느냐, Vertex에서 나가느냐에 따라 결정된다.</p>
<p>보통 Vertex를 기준으로 나가는 방향을 많이 따른다.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Phong_reflection_model">https://en.wikipedia.org/wiki/Phong_reflection_model</a></li>
</ul>
<h2 id="from-vertex-unity"><a class="header" href="#from-vertex-unity">From Vertex (Unity)</a></h2>
<p><img src="Etc/../res/FromVertex.webp" alt="FromVertex.webp" /></p>
<pre><code class="language-hlsl">// com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl
light.direction = half3(_MainLightPosition.xyz);

// com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl
float3 GetCurrentViewPosition()
{
    return GetCameraPositionWS();
}

float3 GetCameraPositionWS()
{
    return _WorldSpaceCameraPos;
}

float3 GetWorldSpaceViewDir(float3 positionWS)
{
    if (IsPerspectiveProjection())
    {
        // Perspective
        return GetCurrentViewPosition() - positionWS;
    }
    else
    {
        // Orthographic
        return -GetViewForwardDir();
    }
}
</code></pre>
<pre><code class="language-hlsl">L = normalize(lightPositionWS - positionWS);
V = normalize(cameraPositionWS - positionWS);
H = normalize(V + L);
R = reflect(-L, N);

NdotL = dot(N, L);
RdotV = dot(R, V);
</code></pre>
<h2 id="to-vertex"><a class="header" href="#to-vertex">To Vertex</a></h2>
<p>Pope 책에서는 Vertex를 향하도록 코드가 작성이 되어있다.</p>
<p><img src="Etc/../res/ToVertex.jpg" alt="ToVertex.jpg" /></p>
<pre><code class="language-hlsl">L = normalize(positionWS - lightPositionWS);
V = normalize(positionWS - cameraPositionWS);
H = normalize((-V) + (-L));
R = reflect(L, N);

NdotL = dot(N, -L);
RdotV = dot(R, -V);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="코딩-스타일"><a class="header" href="#코딩-스타일">코딩 스타일</a></h1>
<pre><code class="language-hlsl">// 괄호: BSD스타일 - 새행에서 괄호를 열자.
Shader "example/03_texture_uv"
{
    Properties
    {
        // Texture변수는 뒤에 Tex를 붙이자.
        _MainTex("_MainTex",     2D) = "white" {}
        _HeightTex("_HeightTex", 2D) = "gray" {}
    }

    SubShader
    {
        Tags
        {
            "RenderPipeline" = "UniversalRenderPipeline"
            "Queue" = "Geometry"
            "RenderType" = "Opaque"
        }

        Pass
        {
            // Name: 내부적으로 대문자로 처리되니, 처음부터 대문자로 쓰자.
            Name "HELLO_WORLD"
            
            Tags
            {
                "LightMode" = "UniversalForward"
            }

            HLSLPROGRAM
            // pragma
            // include
            // 변수선언
            // CBUFFER 선언
            // 구조체선언
            // 함수선언(vert / frag)

            #pragma prefer_hlslcc gles // gles is not using HLSLcc by default
            #pragma exclude_renderers d3d11_9x // DirectX 11 9.x는 더 이상 지원되지 않으므로 제외.

            #pragma target 3.5
            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            // Texture와 sampler는 동일한 라인에 선언해주고, 중간엔 Tab으로 맞추어주자.
            TEXTURE2D(_MainTex);        SAMPLER(sampler_MainTex);

            CBUFFER_START(UnityPerMaterial)
                float4 _MainTex_ST;
            CBUFFER_END

            // Semantics는 특별히 Tab으로 정렬해주자.
            struct APPtoVS
            {
                float4 positionOS    : POSITION;
                float2 uv            : TEXCOORD0;
            };

            struct VStoFS
            {
                float4 positionCS    : SV_POSITION;
                float2 uv            : TEXCOORD0;
            };

            // vert/frag함수에서 입력/출력에는 IN/OUT을 쓴다.
            VStoFS vert(in APPtoVS IN)
            {
                VStoFS OUT;
                ZERO_INITIALIZE(VStoFS, OUT);

                OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.uv = TRANSFORM_TEX(IN.uv, _MainTex);

                // Time : https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html
                OUT.uv += frac(float2(0, 1) * _Time.x);

                return OUT;
            }

            half4 frag(in VStoFS IN) : SV_Target
            {
                // if / for등 괄호({, })를 빼먹지 말자.
                if (...)
                {
                    ...
                }
                return SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
            }
            ENDHLSL
        }
    }
}
</code></pre>
<pre><code class="language-hlsl">// mainTex - _MainTex 이름 맞추기.
half3 mainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv).rgb;
half3 normalTex = UnpackNormal(SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex, IN.uv));

// 월드스페이스 방향. 대문자로.
Light light = GetMainLight();
half3 T = normalize(IN.B);
half3 N = CombineTBN(normalTex, IN.T, IN.B, IN.N);
half3 L = normalize(light.direction);
half3 V = TransformWorldToViewDir(IN.positionWS);
half3 H = normalize(L + V);

// dot연산 변수는 NdotL과 같은 형식으로
half NdotL = max(0.0, dot(N, L));
half TdotL = dot(T, L);
half TdotV = dot(T, V);

// 나머지 함수 연산은 sinTL 이런식으로.
half sinTL = sqrt(1 - TdotL * TdotL);
</code></pre>
<h2 id="생각해-볼-것"><a class="header" href="#생각해-볼-것">생각해 볼 것</a></h2>
<ul>
<li><code>L</code>, <code>V</code></li>
<li>일단 흔히 사용되는 방식을 따르고, 좀 더 확신이 들면 바꾸던가 하자</li>
</ul>
<h3 id="ndotl-or-ldotn"><a class="header" href="#ndotl-or-ldotn"><code>NdotL</code> or <code>LdotN</code></a></h3>
<ul>
<li>어차피 동일한 값이지만 어떤 네이밍을 고를것인가</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>NdotL</td><td>흔히 사용(눈에 익음)</td></tr>
<tr><td>LdotN</td><td>주체가 L이라는게 드러남</td></tr>
</tbody></table>
</div>
<h3 id="l--normalizelightdirection-or-l--normalize-lightdirection"><a class="header" href="#l--normalizelightdirection-or-l--normalize-lightdirection"><code>L = normalize(light.direction)</code> or <code>L = normalize(-light.direction)</code></a></h3>
<ul>
<li>
<p>유니티의 <code>light.direction</code>은 오브젝에서 라이트로 향하는 방향(normalize되지 않은)</p>
<ul>
<li><code>light.direction = _MainLightPosition.xyz;</code></li>
</ul>
</li>
<li>
<p>postfix붙여볼까?</p>
<ul>
<li><code>L_from</code> , <code>L_to</code></li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>L_to</td><td>L = normalize(light.direction)</td><td>흔히 사용(눈에 익음)</td></tr>
<tr><td>L_from</td><td>L = normalize(-light.direction)</td><td>빛에서 나오는 방향이라는게 들어남</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th>LdotN</th><th>R</th><th>H</th></tr></thead><tbody>
<tr><td>L_to</td><td>dot(L, N)</td><td>reflect(-L, N)</td><td>normalize(L + V)</td></tr>
<tr><td>L_from</td><td>dot(-L, N)</td><td>reflect(L, N)</td><td>normalize(-L - V)</td></tr>
</tbody></table>
</div>
<h4 id="v"><a class="header" href="#v">V?</a></h4>
<ul>
<li>눈(eye)을 뜻하는 E를 쓰는 사람도 있지만... E보다는 V고.. 방향이 문제인데..</li>
<li><code>V = GetWorldSpaceNormalizeViewDir(positionWS);</code>
<ul>
<li>오브젝트에서 뷰로 향하는 방향임</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">float3 GetViewForwardDir()
{
    float4x4 viewMat = GetWorldToViewMatrix();
    return -viewMat[2].xyz;
}

float3 GetWorldSpaceNormalizeViewDir(float3 positionWS)
{
    if (IsPerspectiveProjection())
    {
        // Perspective
        float3 V = GetCurrentViewPosition() - positionWS;
        return normalize(V);
    }
    else
    {
        // Orthographic
        return -GetViewForwardDir();
    }
}

float3 GetPrimaryCameraPosition()
{
#if (SHADEROPTIONS_CAMERA_RELATIVE_RENDERING != 0)
    return float3(0, 0, 0);
#else
    return _WorldSpaceCameraPos;
#endif
}

// Could be e.g. the position of a primary camera or a shadow-casting light.
float3 GetCurrentViewPosition()
{
#if defined(SHADERPASS) &amp;&amp; (SHADERPASS != SHADERPASS_SHADOWS)
    return GetPrimaryCameraPosition();
#else
    // This is a generic solution.
    // However, for the primary camera, using '_WorldSpaceCameraPos' is better for cache locality,
    // and in case we enable camera-relative rendering, we can statically set the position is 0.
    return UNITY_MATRIX_I_V._14_24_34;
#endif
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trouble-shooting"><a class="header" href="#trouble-shooting">Trouble Shooting</a></h1>
<ul>
<li>zfighiting
<ul>
<li><a href="https://blog.naver.com/shol9570/222407549035">https://blog.naver.com/shol9570/222407549035</a></li>
<li>모바일 소수점 계산이 원할하지 않음</li>
<li>Near와 Far의 격차를 줄임</li>
</ul>
</li>
</ul>
<h2 id="아트팀"><a class="header" href="#아트팀">아트팀</a></h2>
<ul>
<li>노말이 뒤집혔다
<ul>
<li>normal 표시기를 만들어 둬서 확인</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-buffer"><a class="header" href="#command-buffer">Command Buffer</a></h1>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-render-multi-thread-render">https://docs.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-render-multi-thread-render</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">https://docs.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-render-multi-thread-command-list</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chromasubsampling"><a class="header" href="#chromasubsampling">ChromaSubsampling</a></h1>
<div class="table-wrapper"><table><thead><tr><th>사람 눈 세포</th><th>인식</th><th>갯수</th></tr></thead><tbody>
<tr><td>간상세포</td><td>밝기 변화</td><td>9천만 개 이상</td></tr>
<tr><td>원추세포</td><td>색상</td><td>600만 개정도</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>사람의 시각은 밝기의 변화에 비하여 색상의 변화에는 둔감.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Chroma_subsampling">https://en.wikipedia.org/wiki/Chroma_subsampling</a></p>
</li>
</ul>
<p><img src="Optimize/../res/Jab-subsampling-visualized.jpg" alt="Jab-subsampling-visualized.jpg" /></p>
<div class="table-wrapper"><table><thead><tr><th>예</th><th>텍스쳐 /사이즈</th><th>표현 픽셀당 필요 비트 수</th><th>비트 비율</th></tr></thead><tbody>
<tr><td>원본</td><td>ARGB32 / 256x256</td><td>32bit * 1 == 32</td><td>1</td></tr>
<tr><td>4:2:2</td><td>Alpha8 / 512x256</td><td>8bit * 2 == 16</td><td>0.5</td></tr>
<tr><td>4:2:0</td><td>Alpha8 / 384x256</td><td>8bit * 1.5 == 12</td><td>0.375</td></tr>
</tbody></table>
</div>
<ul>
<li>원본이미지를 Y'CbCr로 바뀌어 하나의 채널만을 이용하여 저장. (이미지 사이즈가 늘어나기에 POT이미지인 경우 NPOT로 바뀌게 됨)</li>
<li>메모리를 아껴주긴하니, 모션블러나같이 RenderTexture사용시 메모리 아낄때 이용하면 좋을듯.</li>
</ul>
<h2 id="chromapack"><a class="header" href="#chromapack">ChromaPack</a></h2>
<ul>
<li><a href="https://github.com/keijiro/ChromaPack">https://github.com/keijiro/ChromaPack</a>
<ul>
<li>4:2:0 Y'CbCr를 이용한다.</li>
<li>알파있는 것은 Y'의 8비트중 1비트를 이용하여 처리</li>
<li>변형하여 YCgCo를 이용한 버전 : <a href="https://github.com/n-yoda/unity-ycca-subsampling">https://github.com/n-yoda/unity-ycca-subsampling</a></li>
<li>이미지 압축시 품질 손실을 막기위해 고안
<ul>
<li>예로 유니티 내장 PVRTC 변환툴로 변환하면 텍스쳐 압축시 품질저하가 일어남(일러스트같은경우 문제가됨)</li>
<li>품질저하를 줄인 상용 이미지 편집기가 있기도 함(OPTPiX iMageStudio)</li>
<li>ASTC가 나온이상, 이게 필요할까? 라는 의문점이 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="Optimize/../res/ChromaPack.png" alt="ChromaPack.png" /></p>
<h2 id="ref-55"><a class="header" href="#ref-55">Ref</a></h2>
<ul>
<li><a href="https://blog.uwa4d.com/archives/TechSharing_186.html">https://blog.uwa4d.com/archives/TechSharing_186.html</a></li>
<li><a href="https://techblog.kayac.com/texture-compression-in-yuv">https://techblog.kayac.com/texture-compression-in-yuv</a>
<ul>
<li><a href="https://github.com/hiryma/UnitySamples/tree/master/Yuv">https://github.com/hiryma/UnitySamples/tree/master/Yuv</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=4kVffWfmJ60&amp;t=4870s">2020 - Dev Weeks: 성능 프로파일링과 최적화</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimize-combine-texture"><a class="header" href="#optimize-combine-texture">Optimize Combine Texture</a></h1>
<ul>
<li>
<p>여러장의 텍스쳐를 쓰는 대신, 안쓰는 채널이 없도록 packing한다면, 추가적인 텍스쳐를 불러오는 로딩시간과 메모리를 줄일 수 있다.</p>
</li>
<li>
<p>예)</p>
<ul>
<li>Albedo + Specular</li>
<li>NormalMap + HeightMap</li>
<li>...</li>
</ul>
</li>
<li>
<p><a href="https://gumroad.com/l/EasyChannelPacking">EasyChannelPacking</a></p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>_DiffuseTex</td><td>RGB</td><td>불투명시 3채널</td></tr>
<tr><td>_NormalTex</td><td>RG</td><td></td></tr>
<tr><td>_SpecularTex</td><td>R</td><td></td></tr>
<tr><td>_MaskTex</td><td>R</td><td></td></tr>
<tr><td>_HeightMapTex</td><td>R</td><td></td></tr>
<tr><td>_NoiseTex</td><td>R</td><td></td></tr>
<tr><td>_BrdfTex</td><td></td><td></td></tr>
<tr><td>...</td><td>R</td><td></td></tr>
</tbody></table>
</div>
<h2 id="ex-normalmap와-parallaxmapping"><a class="header" href="#ex-normalmap와-parallaxmapping">ex) <a href="Optimize/../NormalMap.html">NormalMap</a>와 <a href="Optimize/../ParallaxMapping.html">ParallaxMapping</a></a></h2>
<ul>
<li>NormalMap에선 R,G채널 2개의 채널을</li>
<li>ParallaxMapping에선 깊이에 대한 하나의 채널을 추가해서 사용한다</li>
</ul>
<h2 id="normamap-packing시-주의"><a class="header" href="#normamap-packing시-주의">NormaMap Packing시 주의</a></h2>
<p>BC5 (x, y, 0, 1)을 보면, <code>RGBA</code>채널중에서 <code>RG</code>채널만 사용하고 있다. 이를 이용하여, <code>BA</code>채널에 마스킹이나 다른 데이터값을 체워 넣을 수 있다.</p>
<p><code>B</code>채널은 공짜로 사용할 수 있으나, <code>A</code>채널까지 사용하려면  유니티의 <code>UnpackNormal</code>함수는 다음과 같이 채널을 바꾸는 기능이 있어, 따로 함수를 작성해 주어야 한다.</p>
<pre><code class="language-hlsl">// Unpack normal as DXT5nm (1, y, 0, x) or BC5 (x, y, 0, 1)
real3 UnpackNormalmapRGorAG(real4 packedNormal, real scale = 1.0)
{
    // Convert to (?, y, 0, x)
    // R과 A를 혼합하는 과정이 있는데, 이미 텍스쳐의 포맷을 알고 있으면 이 과정은 불필요하다.
    packedNormal.a *= packedNormal.r;
    return UnpackNormalAG(packedNormal, scale);
}
</code></pre>
<h2 id="ex-1"><a class="header" href="#ex-1">ex</a></h2>
<p><img src="Optimize/../res/texture_example1.jpg" alt="texture_example1.jpg" /></p>
<p><img src="Optimize/../res/texture_example2.jpg" alt="texture_example1.jpg" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimize-tip"><a class="header" href="#optimize-tip">Optimize tip</a></h1>
<h2 id="from-optimizing-unity-games-google-io-2014"><a class="header" href="#from-optimizing-unity-games-google-io-2014">from <a href="https://www.slideshare.net/AlexanderDolbilov/google-i-o-2014">Optimizing unity games (Google IO 2014)</a></a></h2>
<ul>
<li>Shader.SetGlobalVector</li>
<li>OnWillRenderObject(오브젝트가 보일때만), propertyID(string보다 빠름)</li>
</ul>
<pre><code class="language-cs">void OnWillRenderObject()
{
    material.SetMatrix(propertyID, matrix);
}
</code></pre>
<h2 id="tangent-space-라이트-계산"><a class="header" href="#tangent-space-라이트-계산">Tangent Space 라이트 계산</a></h2>
<ul>
<li>월드 스페이스에서 라이트 계산값과 탄젠트 스페이스에서 라이트 계산값과 동일.</li>
<li>vertex함수에서 tangent space V, L을 구하고 fragment함수에 넘겨줌.
<ul>
<li>월드 스페이스로 변환 후 계산하는 작업을 단축 할 수 있음</li>
</ul>
</li>
</ul>
<h2 id="데미지폰트"><a class="header" href="#데미지폰트">데미지폰트</a></h2>
<ul>
<li>셰이더로 한꺼번에 출력</li>
<li><a href="https://blog.naver.com/jinwish/221577786406">https://blog.naver.com/jinwish/221577786406</a></li>
</ul>
<h2 id="npot-지원안하는-텍스쳐-포맷"><a class="header" href="#npot-지원안하는-텍스쳐-포맷">NPOT 지원안하는 텍스쳐 포맷</a></h2>
<ul>
<li>NPOT지원안하는 ETC/PVRTC같은경우 POT로 자르고 셰이더로 붙여주는걸 작성해서 최적화
<ul>
<li><a href="https://blog.naver.com/jinwish/221576705990">https://blog.naver.com/jinwish/221576705990</a></li>
</ul>
</li>
</ul>
<h2 id="ggx-공식-간략화"><a class="header" href="#ggx-공식-간략화">GGX 공식 간략화</a></h2>
<ul>
<li>Optimizing PBR for Mobile
<ul>
<li><a href="https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_renaldas_2D00_slides.pdf">pdf</a>, <a href="https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_renaldas_2D00_notes.pdf">note</a></li>
</ul>
</li>
</ul>
<h2 id="밉맵-디테일-올리기"><a class="header" href="#밉맵-디테일-올리기">밉맵 디테일 올리기</a></h2>
<h3 id="샤픈"><a class="header" href="#샤픈">샤픈</a></h3>
<ul>
<li><a href="https://blog.popekim.com/ko/2013/06/24/mipmap-quality.html">https://blog.popekim.com/ko/2013/06/24/mipmap-quality.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/413834301">https://zhuanlan.zhihu.com/p/413834301</a></li>
</ul>
<h2 id="fast-srgb"><a class="header" href="#fast-srgb">FAST SRGB</a></h2>
<ul>
<li>pow에 계산되는 비용을 줄이기 위한 방법</li>
<li>ShaderFeatures.UseFastSRGBLinearConversion</li>
<li><a href="http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html">sRGB Approximations for HLSL</a></li>
</ul>
<pre><code class="language-hlsl">// com.unity.postprocessing/PostProcessing/Shaders/Colors.hlsl
half3 SRGBToLinear(half3 c)
{
#if USE_VERY_FAST_SRGB
    return c * c;
#elif USE_FAST_SRGB
    return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);
#else
    half3 linearRGBLo = c / 12.92;
    half3 linearRGBHi = PositivePow((c + 0.055) / 1.055, half3(2.4, 2.4, 2.4));
    half3 linearRGB = (c &lt;= 0.04045) ? linearRGBLo : linearRGBHi;
    return linearRGB;
#endif
}

half3 LinearToSRGB(half3 c)
{
#if USE_VERY_FAST_SRGB
    return sqrt(c);
#elif USE_FAST_SRGB
    return max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);
#else
    half3 sRGBLo = c * 12.92;
    half3 sRGBHi = (PositivePow(c, half3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4)) * 1.055) - 0.055;
    half3 sRGB = (c &lt;= 0.0031308) ? sRGBLo : sRGBHi;
    return sRGB;
#endif
}

// com.unity.postprocessing/PostProcessing/Shaders/StdLib.hlsl
float3 PositivePow(float3 base, float3 power)
{
    return pow(max(abs(base), float3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);
}
</code></pre>
<h2 id="anaylize"><a class="header" href="#anaylize">Anaylize</a></h2>
<ul>
<li><a href="https://developer.android.com/agi/frame-trace/shader-performance">https://developer.android.com/agi/frame-trace/shader-performance</a></li>
<li>ALU(arithmetic logic unit)</li>
<li><a href="https://www.youtube.com/watch?v=uXO9mPHyj_Q">Unity Shader Performance: How to Quickly Measure the GPU Cycles Your Shaders Take</a>
<ul>
<li><a href="https://developer.arm.com/documentation/101863/0804/Using-Mali-Offline-Compiler/Compiling-Vulkan-shaders">malioc</a>
<ul>
<li>https://github.com/Delt06/malioc-unity</li>
<li>https://github.com/Alunice/TaTa/tree/master/com.shac.shaderanalysis</li>
<li>https://github.com/Unity-Technologies/sol-games-unity-samples/tree/main/Graphics/MaliCompilerReport</li>
<li>https://github.com/wotakuro/UnityMaliocPlugin</li>
<li>https://blog.unity.com/games/tackling-profiling-for-mobile-games-with-unity-and-arm</li>
</ul>
</li>
</ul>
</li>
<li>https://shader-playground.timjones.io/
<ul>
<li>https://forum.unity.com/threads/2023-3-heatmap-color-mode.1507490/#post-9425870</li>
</ul>
</li>
</ul>
<h2 id="etc-4"><a class="header" href="#etc-4">Etc</a></h2>
<ul>
<li><a href="https://www.slideshare.net/LeeJungpyo/unite17-shanghailee-jungpyoneteasepangufull-chinese">https://www.slideshare.net/LeeJungpyo/unite17-shanghailee-jungpyoneteasepangufull-chinese</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postprocessubershader"><a class="header" href="#postprocessubershader">PostProcessUberShader</a></h1>
<ul>
<li>여러패스가 아닌 하나의 패스로 관리
<ul>
<li>여러번 전채화면이 Blit되는 것을 방지</li>
<li>공통되게 사용되는 정보(예: 밝기)등 이용</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">#pragma multi_compile_local_fragment _ _KEY_A
</code></pre>
<pre><code class="language-cs">material.EnableKeyword("_KEY_A");
material.DisableKeyword("_KEY_A");
</code></pre>
<h2 id="ref-56"><a class="header" href="#ref-56">Ref</a></h2>
<ul>
<li><a href="https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.universal/Shaders/PostProcessing/UberPost.shader">https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.universal/Shaders/PostProcessing/UberPost.shader</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specular-pow-approximation"><a class="header" href="#specular-pow-approximation">Specular Pow Approximation</a></h1>
<h2 id="제곱하는-횟수-n을-줄여보자면m만큼"><a class="header" href="#제곱하는-횟수-n을-줄여보자면m만큼">제곱하는 횟수 n을 줄여보자면(m만큼)?</a></h2>
<p>Specular 구할때 보통 pow쓰는데 이때 제곱되어 지는 횟수를 줄여봐보자</p>
<p><img src="Optimize/../res/powgraph.gif" alt="./powgraph.gif" /></p>
<p>이 그래프에서 예를들어 n=4와 n=16을 비교할때, n=4의 그래프의 기울기와 시작 위치를 얼추 조절하면 오차야 있겠지만, n=16그래프와 비슷해 질 것이다.</p>
<p><img src="Optimize/../res/n4n16.gif" alt="./n4n16gif" /></p>
<p>그럼 기울기와 오프셋을 구하는 것은 위 문서에 나와있다.</p>
<p>이걸 활용해보자.</p>
<p><img src="Optimize/../res/powtable1.gif" alt="./powtable1.gif" /></p>
<p><img src="Optimize/../res/powtable2.gif" alt="./powtable2.gif" /></p>
<p>예를들어, pow(x, 18)을 구하고자 한다면,</p>
<pre><code class="language-txt">x^n 
max(0, Ax + B)^m // 단,  x &lt; pow(256, -1/n )은 0으로 취급
</code></pre>
<p>테이블에서 다음 라인을 확인 할 수 있을 것이다.</p>
<div class="table-wrapper"><table><thead><tr><th>m</th><th>n</th><th>A</th><th>B</th><th>Max error</th></tr></thead><tbody>
<tr><td>2</td><td>18</td><td>6.645</td><td>-5.645</td><td>0.063146</td></tr>
</tbody></table>
</div>
<p>공식에 대입하면 다음과 같은 식을 얻을 수 있다.</p>
<pre><code class="language-hlsl">inline half n18Approximation(half x)
{
    // n | 18
    // m | 2
    //     pow(x, n)
    //     pow(x, 18)
    //     pow(max(0, Ax        + B     ), m)
    return pow(max(0, 6.645 * x + -5.645), 2);
}
</code></pre>
<pre><code class="language-hlsl">half3 specularColor = pow(max(0, dot(R, V)), 18);

half3 specularColor = n18Approximation(max(0, dot(R, V)));
</code></pre>
<h2 id="ref-57"><a class="header" href="#ref-57">Ref</a></h2>
<ul>
<li><a href="https://www.gamasutra.com/view/feature/131381/a_noninteger_power_function_on_.php?page=2">A Non-Integer Power Function on the Pixel Shader - by Juan Guardado, Phillippe Beaudoin</a></li>
<li><a href="https://gamedevforever.com/36">Fast Specular 계산</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vertexmultiplelight"><a class="header" href="#vertexmultiplelight">VertexMultipleLight</a></h1>
<ul>
<li>God of war 3에서 여러 광원처리 기법
<ul>
<li>pixel shader가 느렸던 기기여서 vertex에서 처리</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">// ref: https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl

half3 VertexLighting(float3 positionWS, half3 normalWS)
{
    half3 vertexLightColor = half3(0.0, 0.0, 0.0);

#ifdef _ADDITIONAL_LIGHTS_VERTEX
    uint lightsCount = GetAdditionalLightsCount();
    LIGHT_LOOP_BEGIN(lightsCount)
        Light light = GetAdditionalLight(lightIndex, positionWS);
        half3 lightColor = light.color * light.distanceAttenuation;
        vertexLightColor += LightingLambert(lightColor, light.direction, normalWS);
    LIGHT_LOOP_END
#endif

    return vertexLightColor;
}
</code></pre>
<pre><code class="language-hlsl">struct VStoFS
{
    half4 positionCS          : SV_POSITION;
    half2 uv                  : TEXCOORD0;
    half3 N                   : TEXCOORD1;
    half3 H_Sun               : TEXCOORD2;
    half3 H_Points            : TEXCOORD3;
    half3 Diffuse_Sun         : TEXCOORD4;
    half3 Diffuse_Points      : TEXCOORD5;
};

VStoFS vert(in APPtoVS IN)
{
    half3 L_points = half3(0, 0, 0);

    uint additionalLightsCount = min(GetAdditionalLightsCount(), 3);
    for (uint i = 0; i &lt; additionalLightsCount; ++i)
    {
        Light additionalLight = GetAdditionalLight(i, positionWS);
        half3 L_attenuated = additionalLight.direction * additionalLight.distanceAttenuation;

        OUT.Diffuse_Points += saturate(dot(N, L_attenuated)) * additionalLight.color;
        L_points += L_attenuated;
    }
    OUT.H_Points = normalize(L_points) + V;

    OUT.Diffuse_Sun = saturate(dot(N, L * mainLight.distanceAttenuation)) * mainLight.color;
    OUT.H_Sun = normalize(L + V);
}

half4 frag(in VStoFS IN) : SV_Target
{
{
    half3 diffuse = diffuseTex * (IN.Diffuse_Sun + IN.Diffuse_Points);

    half2 highlights;
    highlights.x = pow(saturate(dot(N, H_Sun)), _SpecularPower);
    highlights.y = pow(saturate(dot(N, H_Points)), _SpecularPower);
    half3 specular = specularMaskTex * ((IN.Diffuse_Sun * highlights.x) + (IN.Diffuse_Points * highlights.y));

    half3 result = diffuse + specular;
}
</code></pre>
<h2 id="ref-58"><a class="header" href="#ref-58">Ref</a></h2>
<ul>
<li><a href="https://advances.realtimerendering.com/s2011/index.html">SIGGRAPH2011 - Dynamic lighting in God of War 3</a>
<ul>
<li><a href="http://www.thetenthplanet.de/archives/1337">Comments on Advances in Real Time Rendering 2011</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animationtexture"><a class="header" href="#animationtexture">AnimationTexture</a></h1>
<h2 id="ref-59"><a class="header" href="#ref-59">Ref</a></h2>
<ul>
<li><a href="https://github.com/sugi-cho/Animation-Texture-Baker">https://github.com/sugi-cho/Animation-Texture-Baker</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawcall"><a class="header" href="#drawcall">DrawCall</a></h1>
<ul>
<li>
<p>DrawCall : CPU가 GPU에게 그려라(Draw)라고 명령하는 것</p>
</li>
<li>
<p><a href="https://youtu.be/UsyvT36vqpU?t=1460">Dev Weeks: 성능을 고려한 파이프라인, Universal Render Pipeline</a></p>
</li>
<li>
<p><a href="https://youtu.be/w14yjBlfNeQ?si=m_G8ru6j69EBit3i">[유니티 TIPS] 유니티 최적화를 위한 필수 기본기! Batching 방법 소개</a></p>
</li>
</ul>
<p><img src="Optimize/../res/batch.jpg" alt="batch.jpg" /></p>
<div class="table-wrapper"><table><thead><tr><th>Render States</th></tr></thead><tbody>
<tr><td>Shader</td></tr>
<tr><td>Mesh</td></tr>
<tr><td>Alpha Blending</td></tr>
<tr><td>Z Test</td></tr>
<tr><td>Texture 0...N</td></tr>
<tr><td>...</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Stats</th><th></th></tr></thead><tbody>
<tr><td>Batches</td><td>DrawCall + Render State Changes</td></tr>
<tr><td>Saved by Batching</td><td>Batch들을 모은 횟수</td></tr>
<tr><td>SetPass calls</td><td>값비싼 커맨드 호출 수</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Command</th><th>SetPass calls</th><th></th></tr></thead><tbody>
<tr><td>Draw Call</td><td></td><td>DrawIndxed()자체는 비용이 별로 안듬</td></tr>
<tr><td>Transform(MVP)</td><td></td><td></td></tr>
<tr><td>Geometry(VB, IB)</td><td></td><td></td></tr>
<tr><td>SetTexture</td><td>o</td><td></td></tr>
<tr><td>Shader Constant</td><td>o</td><td></td></tr>
<tr><td>Shader (VS, PS)</td><td>o</td><td></td></tr>
<tr><td>Blending State</td><td>o</td><td></td></tr>
<tr><td>...</td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="srp-batcher"><a class="header" href="#srp-batcher">SRP Batcher</a></h2>
<ul>
<li><a href="https://docs.unity3d.com/Manual/SRPBatcher.html">https://docs.unity3d.com/Manual/SRPBatcher.html</a></li>
<li>Material의 정보와 Object의 정보를 GPU 메모리에 상주</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th>배치 기준</th></tr></thead><tbody>
<tr><td>Built-in(legacy)</td><td>머테리얼</td></tr>
<tr><td>SRP Batcher</td><td>셰이더</td></tr>
</tbody></table>
</div>
<pre><code class="language-hlsl">// 메터리얼별로 상수버퍼(Constant buffer)를 만들어 주어
// 동일한 셰이더를 여러 머터리얼이 사용하는 경우 앞서 만든 상수버퍼를 이용하셔 성능 향상 도모.
// (상수버퍼안 개별 값을 전달하는게 아니라 상수버퍼 자체를 전달)
// 메모리 정렬(16바이트)가 되어 있는게 좋은데 유니티에서는 어떻게 내부적으로 되었는지 모르겠다.
CBUFFER_START(UnityPerMaterial)
float _Blabla;
CBUFFER_END
</code></pre>
<h2 id="gpu-instancing"><a class="header" href="#gpu-instancing">GPU Instancing</a></h2>
<ul>
<li><a href="https://docs.unity3d.com/Manual/GPUInstancing.html">https://docs.unity3d.com/Manual/GPUInstancing.html</a></li>
<li>동일한 메시끼리 한 번의 드로우콜로 처리</li>
<li>배칭과 달리 동일한 메시의 복사본들을 만든다는 점에서 구분. 배칭보다 런타임 오버헤드가 적다.</li>
<li>CPU에서 처리해서 보내준 정보를 GPU에서 별도의 버퍼에 담고 인스턴싱 처리를 함.</li>
<li>Renderer
<ul>
<li>Mesh Renderer에만 사용</li>
<li>Skinned Mesh Renderer에는 사용 불가(케릭터 불가)</li>
</ul>
</li>
</ul>
<pre><code class="language-hlsl">#pragma multi_compile_instancing

// ref: https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"

UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
    UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)
UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)

struct APPtoVS
{
    UNITY_VERTEX_INPUT_INSTANCE_ID
};

struct VStoFS
{
    UNITY_VERTEX_INPUT_INSTANCE_ID 
};

VStoFS vert(in APPtoVS IN)
{
    UNITY_SETUP_INSTANCE_ID(IN);

    VStoFS OUT;
    ZERO_INITIALIZE(VStoFS, OUT);
    UNITY_TRANSFER_INSTANCE_ID(IN, OUT);
    return OUT;
}

half4 frag(in VStoFS IN)
{
    UNITY_SETUP_INSTANCE_ID(IN);
    half4 color = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Color);
    return 1;
}

</code></pre>
<pre><code class="language-cs">static readonly int _BaseColor = Shader.PropertyToID("_BaseColor");

Mesh _mesh;
Material _material;
MaterialPropertyBlock _block;

Matrix4x4[] _matrices;
Vector4[] _baseColors ;

_block = new MaterialPropertyBlock();
_block.SetVectorArray(baseColorId, baseColors);

// ref: https://docs.unity3d.com/ScriptReference/Graphics.DrawMeshInstanced.html
Graphics.DrawMeshInstanced(_mesh, 0, _material, _matrices, _matrices.Length, block);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tool"><a class="header" href="#tool">Tool</a></h1>
<ul>
<li>
<p><a href="https://renderdoc.org/">RenderDoc</a></p>
</li>
<li>
<p><a href="https://developer.nvidia.com/nvidia-texture-tools-exporter">NVIDIA Texture Tools Exporter</a></p>
</li>
<li>
<p>텍스쳐 생성 : <a href="https://github.com/mtwoodard/TextureGenerator">https://github.com/mtwoodard/TextureGenerator</a></p>
</li>
<li>
<p><a href="http://teckartist.com/?page_id=107">FlowMap Painter</a></p>
</li>
<li>
<p><a href="https://gumroad.com/l/EasyChannelPacking">EasyChannelPacking</a></p>
</li>
<li>
<p><a href="https://docs.unity3d.com/Packages/com.unity.progrids@3.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.progrids@3.0/manual/index.html</a></p>
</li>
<li>
<p><a href="https://docs.unity3d.com/Packages/com.unity.polybrush@1.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.polybrush@1.0/manual/index.html</a></p>
</li>
<li>
<p><a href="https://docs.unity3d.com/Packages/com.unity.formats.fbx@4.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.formats.fbx@4.0/manual/index.html</a></p>
</li>
<li>
<p><a href="https://catlikecoding.com/sdf-toolkit/docs/texture-generator/">https://catlikecoding.com/sdf-toolkit/docs/texture-generator/</a></p>
</li>
<li>
<p><a href="https://github.com/andydbc/unity-texture-packer">https://github.com/andydbc/unity-texture-packer</a></p>
</li>
<li>
<p><a href="https://github.com/unity3d-jp/MeshSync">https://github.com/unity3d-jp/MeshSync</a></p>
</li>
<li>
<p><a href="https://github.com/unity3d-jp/NormalPainter">https://github.com/unity3d-jp/NormalPainter</a></p>
</li>
<li>
<p><a href="https://github.com/M-Fatah/texture_maker">https://github.com/M-Fatah/texture_maker</a></p>
</li>
<li>
<p><a href="http://mebiusbox.github.io/contents/EffectTextureMaker/">http://mebiusbox.github.io/contents/EffectTextureMaker/</a></p>
</li>
<li>
<p>BRDF explorer</p>
<ul>
<li><a href="https://oduska.com/datahoarder/Walt%20Disney%20Animation%20Studios/BRDF%20Explorer/Website/BRDF%20Explorer.html">https://oduska.com/datahoarder/Walt%20Disney%20Animation%20Studios/BRDF%20Explorer/Website/BRDF%20Explorer.html</a></li>
<li><a href="https://github.com/wdas/brdf/downloads">https://github.com/wdas/brdf/downloads</a></li>
</ul>
</li>
<li>
<p>MERL BRDF Database - <a href="https://www.merl.com/brdf/">https://www.merl.com/brdf/</a></p>
</li>
</ul>
<h2 id="texture-maker"><a class="header" href="#texture-maker">Texture maker</a></h2>
<ul>
<li><a href="https://github.com/njbrown/texturelab">https://github.com/njbrown/texturelab</a>
<ul>
<li>Free, Cross-Platform, GPU-Accelerated Procedural Texture Generator</li>
</ul>
</li>
<li><a href="https://github.com/alelievr/Mixture">https://github.com/alelievr/Mixture</a>
<ul>
<li>on unity</li>
</ul>
</li>
<li><a href="https://www.materialmaker.org/">https://www.materialmaker.org/</a></li>
<li>유료
<ul>
<li>substance designer</li>
</ul>
</li>
</ul>
<h2 id="모델"><a class="header" href="#모델">모델</a></h2>
<ul>
<li><a href="https://www.mixamo.com/">https://www.mixamo.com/</a></li>
<li><a href="https://www.models-resource.com/">https://www.models-resource.com/</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_common_3D_test_models">https://en.wikipedia.org/wiki/List_of_common_3D_test_models</a></li>
</ul>
<h2 id="etc-5"><a class="header" href="#etc-5">Etc</a></h2>
<ul>
<li><a href="https://www.afterworks.com/FumeFX.asp">FumeFX</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="presentation"><a class="header" href="#presentation">Presentation</a></h1>
<ul>
<li>년도별 작품 위주 셰이더관련 발표자료 모음.</li>
<li>일단 모바일 URP에서 쓰일법한 기술 위주로 담자.</li>
</ul>
<h2 id="국내"><a class="header" href="#국내">국내</a></h2>
<ul>
<li><a href="https://www.slideshare.net/valhashi/2011-03-gametechtadptforpdf">2011 - [TA] 2011. 03. 테라에 사용된 렌더링 테크닉 - 임신형 (valhashi)</a></li>
<li><a href="https://www.slideshare.net/jpcorp/kgc2012-multi-plaformmmo">2012 - [kgc2012] multi plaform Full3D MMO 만들기 "삼국지를 품다"의 테크니컬 아트</a></li>
<li><a href="https://www.slideshare.net/devcatpublications/10ndc2012">2012 - [NDC2012] 전형규, 가성비 좋은 렌더링 테크닉 10선</a>
<ul>
<li>업스케일: 세로 해상도를 더 확보하는게 인지적 측면 유리</li>
<li>Radiosity normal map</li>
</ul>
</li>
<li><a href="https://www.slideshare.net/jalnaga/ndc13ndc-2013-udk-19999169">2013 - [NDC2013] 김동석:UDK로 물리기반 셰이더 만들기</a></li>
<li><a href="https://www.slideshare.net/kokyoungseok/2-20009459">2013 - [NDC2013] 구세대 엔진 신데렐라 만들기 최종본</a></li>
<li><a href="https://www.slideshare.net/hyurichel/kgc2014-41150275">2014 - [KGC2014] 울프나이츠 엔진 프로그래밍 기록</a></li>
<li><a href="https://www.slideshare.net/ndoors/2014-33402528">2014 - [유나이트코리아] 영웅의 군단의 테크니컬 아트 - 황재철</a></li>
<li><a href="http://ndcreplay.nexon.com/NDC2014/sessions/NDC2014_0096.html">2014 - [NDC2014] 뉴비탈출 넘버원: 그래픽스 프로그래밍 길들이기</a></li>
<li><a href="https://www.slideshare.net/HwangGoonLife/ndc15-48732678">2015 - [NDC2015] 광개토태왕 테크니컬 아트</a></li>
<li><a href="https://www.slideshare.net/KiHyunwoo/ndc2016-a1-aaa-61450613">2016 - [NDC2016] 프로젝트 A1의 AAA급 캐릭터 렌더링 기술</a></li>
<li><a href="https://www.slideshare.net/ssuser052dd11/igc-2016-unreal4">2016 - [IGC 2016] 넷게임즈 김영희 - Unreal4를 사용해 모바일 프로젝트 제작하기</a></li>
<li><a href="http://www.inven.co.kr/webzine/news/?news=184847">2017 - [IGC2017] 펄어비스 개발자가 직접 알려주는 '검은사막의 압도적인 비주얼 노하우'</a></li>
<li><a href="https://www.youtube.com/watch?v=hC62O9NGXEw">2019 - [NDC2019] 모바일에서 사용 가능한 유니티 커스텀 섭스턴스 PBR 셰이더 만들기</a></li>
<li><a href="https://www.youtube.com/watch?v=RjaPVcciSuU">2019 - [NDC2019]〈드래곤하운드〉 비주얼이펙트 연출</a>
<ul>
<li>연기/나무에 불 붙이기</li>
</ul>
</li>
<li><a href="https://youtu.be/0LwlNVS3FJo">2019 - [Unite Seoul 2019] 최재영 류재성 - 일곱개의 대죄 : “애니메이션의 감성을 그대로＂와 “개발 최적화</a>
<ul>
<li><a href="https://youtu.be/8iKWEYvozws?t=800">https://youtu.be/8iKWEYvozws?t=800</a></li>
<li>MatCap / Imposter / LookAt</li>
<li>ChromaticAberration / Bloom / Noise / RadialBlur / Vignette / InvertColor / ScratchedFilm / ColorGradingLUT</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=ufNYLgE2WGA">2020 - Dev Weeks: A3 Still Alive - Technical Art Review</a></li>
</ul>
<h3 id="디퍼드"><a class="header" href="#디퍼드">디퍼드</a></h3>
<ul>
<li><a href="https://www.slideshare.net//ozlael/deferred-rendering-case-study">2012 - [KGC 2012] 디퍼드 랜더링 케이스 스터디 : 레이더즈 &amp; 건즈2</a></li>
</ul>
<h2 id="일본"><a class="header" href="#일본">일본</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=ZpWsinhPFLM">2018 - 【Unite Tokyo 2018】『崩壊3rd』開発者が語るアニメ風レンダリングの極意</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=egHSE0dpWRw">https://www.youtube.com/watch?v=egHSE0dpWRw</a></li>
</ul>
</li>
<li><a href="https://youtu.be/Ay45tmdqyws?si=4qBxPqVyQ7BFAI_X">2021 - [SIGGRAPH Asia 2021] 劇場クオリティのアニメをリアルタイムエンジンで実現するには - Unityステーション</a></li>
</ul>
<h2 id="중국"><a class="header" href="#중국">중국</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=00QugD5u1CU">2022 - 유나이트 서울 2020 - 원신 콘솔 플랫폼 개발 경험 및 렌더링 파이프라인 기술 소개 Track3-1</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=t0rOOs1701o">2022 - Unite Seoul 2020 세션 다시보기 - 원신 콘솔 플랫폼 개발 및 렌더링 파이프라인 기술 소개</a></li>
</ul>
</li>
</ul>
<h2 id="해외"><a class="header" href="#해외">해외</a></h2>
<ul>
<li>
<p><a href="https://www.gdcvault.com/play/1017660/Technical-Artist-Bootcamp-The-VFX">2013 - [GDC2013] Technical Artist Bootcamp: The VFX of Diablo</a></p>
</li>
<li>
<p><a href="https://youtu.be/oatF8e_PPh0?si=cGRE1lHZYaiKR9IE">2016 - [Unite2016] - A Guide for Achieving World-Class Visuals on Mobile Devices</a></p>
</li>
<li>
<p><a href="https://www.gdcvault.com/play/1023299/Delivering-Console-Car-Visuals-on">2016 - [GDC2016] Delivering Console Car Visuals on Mobile With 'CSR Racing 2'</a></p>
</li>
<li>
<p><a href="https://www.gdcvault.com/play/1023301/The-Environment-Pipeline-of-CSR">2016 - [GDC2016] The Environment Pipeline of 'CSR Racing 2'</a></p>
<ul>
<li><a href="https://archive.org/details/GDC2016Harber/">https://archive.org/details/GDC2016Harber/</a></li>
</ul>
</li>
<li>
<p>RIME</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=fwKQyDZ4ark">ADDON2017 - GAT #65: Stylized VFX in RIME</a></li>
<li><a href="https://www.youtube.com/watch?v=4FIDBeF_4SI">UNREALFEST2018 - GAT #67: Stylized VFX in RIME 2.0 - Water Edition</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<h2 id="books"><a class="header" href="#books">Books</a></h2>
<ul>
<li><a href="https://www.hanbit.co.kr/store/books/look.php?p_code=B9447539340">2004 - Directx 9 셰이더 프로그래밍 - 타카시 이마기레</a>
<ul>
<li>DirectX기준</li>
<li>저자 블로그 : <a href="https://t-pot.com/program/index.html">https://t-pot.com/program/index.html</a></li>
<li><a href="https://dw.hanbit.co.kr/exam/1285/cd.zip">부록소스</a></li>
</ul>
</li>
<li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B8421024205">2012 - 셰이더 프로그래밍 입문 - Pope Kim</a>
<ul>
<li>DirectX기준, rendermonkey</li>
<li><a href="https://github.com/netpyoung/bs.introduction-to-shader-programming">log</a></li>
</ul>
</li>
<li><a href="https://www.packtpub.com/product/unity-5-x-shaders-and-effects-cookbook/9781785285240">2016 - Unity 5.x Shaders and Effects Cookbook - Alan Zucconi , Kenneth Lammers</a>
<ul>
<li>Built-in(Legacy)</li>
</ul>
</li>
<li><a href="https://vielbooks.com/235">2017 - 유니티 쉐이더 스타트업 - 정종필</a>
<ul>
<li>Built-in(Legacy) / Surface</li>
<li><a href="https://github.com/netpyoung/bs.shader_startup">log</a></li>
</ul>
</li>
<li><a href="https://www.apress.com/kr/book/9781484233085">2017 - Physically Based Shader Development for Unity 2017 - Zignaigo, Claudia</a>
<ul>
<li>Built-in(Legacy)</li>
<li><a href="https://github.com/netpyoung/bs.physically_based_shader_develop_for_unity">log</a></li>
</ul>
</li>
<li>Become a Unity Shaders Guru
<ul>
<li>https://github.com/PacktPublishing/Become-a-Unity-Shaders-Guru</li>
</ul>
</li>
<li>Building Quality Shaders for Unity
<ul>
<li>12장</li>
<li>14장
<ul>
<li><a href="https://docs.unity3d.com/ScriptReference/GraphicsBuffer.html">GraphicsBuffer</a></li>
</ul>
</li>
<li>https://github.com/Apress/building-quality-shaders-unity</li>
</ul>
</li>
<li>Unity Shaders Bible
<ul>
<li>built-in(Legacy), 기초</li>
<li>compute, ray tracing and sphere tracing</li>
</ul>
</li>
</ul>
<h2 id="video"><a class="header" href="#video">Video</a></h2>
<ul>
<li><a href="https://shaderdev.com/">ShaderDev -  Chayan Vinayak Goswami</a>
<ul>
<li>Built-in(Legacy)</li>
<li><a href="https://github.com/netpyoung/vs.shader-developing-using-unity">log</a></li>
</ul>
</li>
<li><a href="https://www.udacity.com/course/interactive-3d-graphics--cs291">Interactive 3D Graphics by Autodesk</a></li>
</ul>
<h2 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h2>
<ul>
<li><a href="https://github.com/netpyoung/unity.shader.sandbox">https://github.com/netpyoung/unity.shader.sandbox</a>
<ul>
<li><a href="https://docs.google.com/presentation/d/12RrqyAkFanKmfL96ZHvhDCozE-_rKFPlU1YVwej4_bc">setchi - ビルトイン関数の使い方いろいろ！シェーダアートの表現力を高める小技集</a>
<ul>
<li><a href="https://docs.google.com/presentation/d/1zga066sEmZMnZeIaIuDt0ijVIF0ii271Atl2okzCw6c">번역: 빌트인 함수 사용법 이것저것! 셰이더 아트의 표현력을 높이는 잔기술</a></li>
</ul>
</li>
<li><a href="https://docs.google.com/presentation/d/1NMhx4HWuNZsjNRRlaFOu2ysjo04NgcpFlEhzodE8Rlg">setchi - 楽しい！Unityシェーダーお絵描き入門！</a>
<ul>
<li><a href="https://docs.google.com/presentation/d/13VJ470UGLtMUOdNGrGZVvI-aHW3BLkNa0XUOZLvppKI">번역: 신나는! Unity 셰이더 그림 그리기 입문!</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="돈아까움"><a class="header" href="#돈아까움">돈아까움</a></h2>
<ul>
<li>the GAME GRAPHICS: 유니티 비주얼 테크닉</li>
<li>유니티짱 툰쉐이더 2.0 슈퍼테크닉</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="etclink"><a class="header" href="#etclink">EtcLink</a></h1>
<h2 id="그래픽-링크-모음집"><a class="header" href="#그래픽-링크-모음집">그래픽 링크 모음집</a></h2>
<ul>
<li><a href="https://kesen.realtimerendering.com/">https://kesen.realtimerendering.com/</a></li>
<li><a href="http://trowley.org/">http://trowley.org/</a></li>
<li>https://cgworld.jp/</li>
<li>https://discourse.techart.online/</li>
<li>https://archive.org/details/gdcextras</li>
<li>https://indievisuallab.github.io/</li>
<li><a href="https://1mafx.teachable.com/p/about">1mafx</a></li>
<li><a href="https://www.youtube.com/playlist?list=PL4neAtv21WOmIrTrkNO3xCyrxg4LKkrF7">Shader Tutorial Series</a></li>
</ul>
<h2 id="리서치"><a class="header" href="#리서치">리서치</a></h2>
<ul>
<li><a href="https://www.gdcvault.com/">GDC</a></li>
<li><a href="http://research.tri-ace.com/">tri-Ace</a></li>
<li><a href="https://developer.arm.com/solutions/graphics-and-gaming/gaming-engine/unity/presentations">ARM</a></li>
</ul>
<h2 id="그래프"><a class="header" href="#그래프">그래프</a></h2>
<ul>
<li><a href="https://www.geogebra.org/graphing">https://www.geogebra.org/graphing</a></li>
<li><a href="https://www.desmos.com/calculator">https://www.desmos.com/calculator</a></li>
<li><a href="https://graphtoy.com/">https://graphtoy.com/</a></li>
<li><a href="http://tobyschachman.com/Shadershop/editor/">http://tobyschachman.com/Shadershop/editor/</a></li>
</ul>
<h2 id="모델-1"><a class="header" href="#모델-1">모델</a></h2>
<ul>
<li>https://3dnchu.com/archives/cg-test-models/</li>
</ul>
<h2 id="튜토리얼"><a class="header" href="#튜토리얼">튜토리얼</a></h2>
<ul>
<li><a href="https://www.ronja-tutorials.com/">https://www.ronja-tutorials.com/</a></li>
<li><a href="https://guru/unity-cpu-performance/mesh-baker-interview-ian-deane/">https://guru/unity-cpu-performance/mesh-baker-interview-ian-deane/</a></li>
<li><a href="https://www.gamedevpensieve.com/graphics/3d/3d_lighting">https://www.gamedevpensieve.com/graphics/3d/3d_lighting</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLyuV91SJJre7DeREVCzx8VG599PCGTtL2">게임 아티스트를 위한 CG 최적화이론</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/hlsl.min.js"></script>
        <script src="theme/juxtapose.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
